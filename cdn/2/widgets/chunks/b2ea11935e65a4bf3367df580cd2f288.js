"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-node_modules_arcgis_core_identity_IdentityManager_js"],{

/***/ "./node_modules/@stencil/core/internal/client/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/client/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BUILD": () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD),
/* harmony export */   "Build": () => (/* binding */ Build),
/* harmony export */   "CSS": () => (/* binding */ CSS),
/* harmony export */   "Context": () => (/* binding */ Context),
/* harmony export */   "Env": () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.Env),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "H": () => (/* binding */ H),
/* harmony export */   "HTMLElement": () => (/* binding */ H),
/* harmony export */   "Host": () => (/* binding */ Host),
/* harmony export */   "NAMESPACE": () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE),
/* harmony export */   "STENCIL_DEV_MODE": () => (/* binding */ STENCIL_DEV_MODE),
/* harmony export */   "addHostEventListeners": () => (/* binding */ addHostEventListeners),
/* harmony export */   "bootstrapLazy": () => (/* binding */ bootstrapLazy),
/* harmony export */   "cmpModules": () => (/* binding */ cmpModules),
/* harmony export */   "connectedCallback": () => (/* binding */ connectedCallback),
/* harmony export */   "consoleDevError": () => (/* binding */ consoleDevError),
/* harmony export */   "consoleDevInfo": () => (/* binding */ consoleDevInfo),
/* harmony export */   "consoleDevWarn": () => (/* binding */ consoleDevWarn),
/* harmony export */   "consoleError": () => (/* binding */ consoleError),
/* harmony export */   "createEvent": () => (/* binding */ createEvent),
/* harmony export */   "defineCustomElement": () => (/* binding */ defineCustomElement),
/* harmony export */   "disconnectedCallback": () => (/* binding */ disconnectedCallback),
/* harmony export */   "doc": () => (/* binding */ doc),
/* harmony export */   "forceModeUpdate": () => (/* binding */ forceModeUpdate),
/* harmony export */   "forceUpdate": () => (/* binding */ forceUpdate),
/* harmony export */   "getAssetPath": () => (/* binding */ getAssetPath),
/* harmony export */   "getConnect": () => (/* binding */ getConnect),
/* harmony export */   "getContext": () => (/* binding */ getContext),
/* harmony export */   "getElement": () => (/* binding */ getElement),
/* harmony export */   "getHostRef": () => (/* binding */ getHostRef),
/* harmony export */   "getMode": () => (/* binding */ getMode),
/* harmony export */   "getRenderingRef": () => (/* binding */ getRenderingRef),
/* harmony export */   "getValue": () => (/* binding */ getValue),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "insertVdomAnnotations": () => (/* binding */ insertVdomAnnotations),
/* harmony export */   "isMemberInElement": () => (/* binding */ isMemberInElement),
/* harmony export */   "loadModule": () => (/* binding */ loadModule),
/* harmony export */   "modeResolutionChain": () => (/* binding */ modeResolutionChain),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "parsePropertyValue": () => (/* binding */ parsePropertyValue),
/* harmony export */   "plt": () => (/* binding */ plt),
/* harmony export */   "postUpdateComponent": () => (/* binding */ postUpdateComponent),
/* harmony export */   "promiseResolve": () => (/* binding */ promiseResolve),
/* harmony export */   "proxyComponent": () => (/* binding */ proxyComponent),
/* harmony export */   "proxyCustomElement": () => (/* binding */ proxyCustomElement),
/* harmony export */   "readTask": () => (/* binding */ readTask),
/* harmony export */   "registerHost": () => (/* binding */ registerHost),
/* harmony export */   "registerInstance": () => (/* binding */ registerInstance),
/* harmony export */   "renderVdom": () => (/* binding */ renderVdom),
/* harmony export */   "setAssetPath": () => (/* binding */ setAssetPath),
/* harmony export */   "setErrorHandler": () => (/* binding */ setErrorHandler),
/* harmony export */   "setMode": () => (/* binding */ setMode),
/* harmony export */   "setNonce": () => (/* binding */ setNonce),
/* harmony export */   "setPlatformHelpers": () => (/* binding */ setPlatformHelpers),
/* harmony export */   "setPlatformOptions": () => (/* binding */ setPlatformOptions),
/* harmony export */   "setValue": () => (/* binding */ setValue),
/* harmony export */   "styles": () => (/* binding */ styles),
/* harmony export */   "supportsConstructableStylesheets": () => (/* binding */ supportsConstructableStylesheets),
/* harmony export */   "supportsListenerOptions": () => (/* binding */ supportsListenerOptions),
/* harmony export */   "supportsShadow": () => (/* binding */ supportsShadow),
/* harmony export */   "win": () => (/* binding */ win),
/* harmony export */   "writeTask": () => (/* binding */ writeTask)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/app-data */ "./node_modules/@stencil/core/internal/app-data/index.js");
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/snabbdom/snabbdom/blob/master/LICENSE
 *
 * Modified for Stencil's renderer and slot projection
 */
let scopeId;
let contentRef;
let hostTagName;
let customError;
let i = 0;
let useNativeShadowDom = false;
let checkSlotFallbackVisibility = false;
let checkSlotRelocate = false;
let isSvgMode = false;
let renderingRef = null;
let queueCongestion = 0;
let queuePending = false;
/*
 Stencil Client Platform v2.22.3 | MIT Licensed | https://stenciljs.com
 */

const Build = {
    isDev: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev ? true : false,
    isBrowser: true,
    isServer: false,
    isTesting: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isTesting ? true : false,
};
const Context = {};
const getAssetPath = (path) => {
    const assetUrl = new URL(path, plt.$resourcesUrl$);
    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
};
const setAssetPath = (path) => (plt.$resourcesUrl$ = path);
const createTime = (fnName, tagName = '') => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.mark) {
        const key = `st:${fnName}:${tagName}:${i++}`;
        // Start
        performance.mark(key);
        // End
        return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);
    }
    else {
        return () => {
            return;
        };
    }
};
const uniqueTime = (key, measureText) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.mark) {
        if (performance.getEntriesByName(key, 'mark').length === 0) {
            performance.mark(key);
        }
        return () => {
            if (performance.getEntriesByName(measureText, 'measure').length === 0) {
                performance.measure(measureText, key);
            }
        };
    }
    else {
        return () => {
            return;
        };
    }
};
const inspect = (ref) => {
    const hostRef = getHostRef(ref);
    if (!hostRef) {
        return undefined;
    }
    const flags = hostRef.$flags$;
    const hostElement = hostRef.$hostElement$;
    return {
        renderCount: hostRef.$renderCount$,
        flags: {
            hasRendered: !!(flags & 2 /* HOST_FLAGS.hasRendered */),
            hasConnected: !!(flags & 1 /* HOST_FLAGS.hasConnected */),
            isWaitingForChildren: !!(flags & 4 /* HOST_FLAGS.isWaitingForChildren */),
            isConstructingInstance: !!(flags & 8 /* HOST_FLAGS.isConstructingInstance */),
            isQueuedForUpdate: !!(flags & 16 /* HOST_FLAGS.isQueuedForUpdate */),
            hasInitializedComponent: !!(flags & 32 /* HOST_FLAGS.hasInitializedComponent */),
            hasLoadedComponent: !!(flags & 64 /* HOST_FLAGS.hasLoadedComponent */),
            isWatchReady: !!(flags & 128 /* HOST_FLAGS.isWatchReady */),
            isListenReady: !!(flags & 256 /* HOST_FLAGS.isListenReady */),
            needsRerender: !!(flags & 512 /* HOST_FLAGS.needsRerender */),
        },
        instanceValues: hostRef.$instanceValues$,
        ancestorComponent: hostRef.$ancestorComponent$,
        hostElement,
        lazyInstance: hostRef.$lazyInstance$,
        vnode: hostRef.$vnode$,
        modeName: hostRef.$modeName$,
        onReadyPromise: hostRef.$onReadyPromise$,
        onReadyResolve: hostRef.$onReadyResolve$,
        onInstancePromise: hostRef.$onInstancePromise$,
        onInstanceResolve: hostRef.$onInstanceResolve$,
        onRenderResolve: hostRef.$onRenderResolve$,
        queuedListeners: hostRef.$queuedListeners$,
        rmListeners: hostRef.$rmListeners$,
        ['s-id']: hostElement['s-id'],
        ['s-cr']: hostElement['s-cr'],
        ['s-lr']: hostElement['s-lr'],
        ['s-p']: hostElement['s-p'],
        ['s-rc']: hostElement['s-rc'],
        ['s-sc']: hostElement['s-sc'],
    };
};
const installDevTools = () => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.devTools) {
        const stencil = (win.stencil = win.stencil || {});
        const originalInspect = stencil.inspect;
        stencil.inspect = (ref) => {
            let result = inspect(ref);
            if (!result && typeof originalInspect === 'function') {
                result = originalInspect(ref);
            }
            return result;
        };
    }
};
const CONTENT_REF_ID = 'r';
const ORG_LOCATION_ID = 'o';
const SLOT_NODE_ID = 's';
const TEXT_NODE_ID = 't';
const HYDRATE_ID = 's-id';
const HYDRATED_STYLE_ID = 'sty-id';
const HYDRATE_CHILD_ID = 'c-id';
const HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';
const XLINK_NS = 'http://www.w3.org/1999/xlink';
/**
 * Default style mode id
 */
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */
const EMPTY_OBJ = {};
/**
 * Namespaces
 */
const SVG_NS = 'http://www.w3.org/2000/svg';
const HTML_NS = 'http://www.w3.org/1999/xhtml';
const isDef = (v) => v != null;
const isComplexType = (o) => {
    // https://jsperf.com/typeof-fn-object/5
    o = typeof o;
    return o === 'object' || o === 'function';
};
/**
 * Helper method for querying a `meta` tag that contains a nonce value
 * out of a DOM's head.
 *
 * @param doc The DOM containing the `head` to query against
 * @returns The content of the meta tag representing the nonce value, or `undefined` if no tag
 * exists or the tag has no content.
 */
function queryNonceMetaTagContent(doc) {
    var _a, _b, _c;
    return (_c = (_b = (_a = doc.head) === null || _a === void 0 ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) === null || _b === void 0 ? void 0 : _b.getAttribute('content')) !== null && _c !== void 0 ? _c : undefined;
}
/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;
const h = (nodeName, vnodeData, ...children) => {
    let child = null;
    let key = null;
    let slotName = null;
    let simple = false;
    let lastSimple = false;
    const vNodeChildren = [];
    const walk = (c) => {
        for (let i = 0; i < c.length; i++) {
            child = c[i];
            if (Array.isArray(child)) {
                walk(child);
            }
            else if (child != null && typeof child !== 'boolean') {
                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {
                    child = String(child);
                }
                else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && typeof nodeName !== 'function' && child.$flags$ === undefined) {
                    consoleDevError(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`);
                }
                if (simple && lastSimple) {
                    // If the previous child was simple (string), we merge both
                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;
                }
                else {
                    // Append a new vNode, if it's text, we create a text vNode
                    vNodeChildren.push(simple ? newVNode(null, child) : child);
                }
                lastSimple = simple;
            }
        }
    };
    walk(children);
    if (vnodeData) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && nodeName === 'input') {
            validateInputProperties(vnodeData);
        }
        // normalize class / classname attributes
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && vnodeData.key) {
            key = vnodeData.key;
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && vnodeData.name) {
            slotName = vnodeData.name;
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomClass) {
            const classData = vnodeData.className || vnodeData.class;
            if (classData) {
                vnodeData.class =
                    typeof classData !== 'object'
                        ? classData
                        : Object.keys(classData)
                            .filter((k) => classData[k])
                            .join(' ');
            }
        }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && vNodeChildren.some(isHost)) {
        consoleDevError(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomFunctional && typeof nodeName === 'function') {
        // nodeName is a functional component
        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
    }
    const vnode = newVNode(nodeName, null);
    vnode.$attrs$ = vnodeData;
    if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {
        vnode.$key$ = key;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
        vnode.$name$ = slotName;
    }
    return vnode;
};
/**
 * A utility function for creating a virtual DOM node from a tag and some
 * possible text content.
 *
 * @param tag the tag for this element
 * @param text possible text content for the node
 * @returns a newly-minted virtual DOM node
 */
const newVNode = (tag, text) => {
    const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text,
        $elm$: null,
        $children$: null,
    };
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute) {
        vnode.$attrs$ = null;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {
        vnode.$key$ = null;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
        vnode.$name$ = null;
    }
    return vnode;
};
const Host = {};
/**
 * Check whether a given node is a Host node or not
 *
 * @param node the virtual DOM node to check
 * @returns whether it's a Host node or not
 */
const isHost = (node) => node && node.$tag$ === Host;
/**
 * Implementation of {@link d.FunctionalUtilities} for Stencil's VDom.
 *
 * Note that these functions convert from {@link d.VNode} to
 * {@link d.ChildNode} to give functional component developers a friendly
 * interface.
 */
const vdomFnUtils = {
    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),
};
/**
 * Convert a {@link d.VNode} to a {@link d.ChildNode} in order to present a
 * friendlier public interface (hence, 'convertToPublic').
 *
 * @param node the virtual DOM node to convert
 * @returns a converted child node
 */
const convertToPublic = (node) => ({
    vattrs: node.$attrs$,
    vchildren: node.$children$,
    vkey: node.$key$,
    vname: node.$name$,
    vtag: node.$tag$,
    vtext: node.$text$,
});
/**
 * Convert a {@link d.ChildNode} back to an equivalent {@link d.VNode} in
 * order to use the resulting object in the virtual DOM. The initial object was
 * likely created as part of presenting a public API, so converting it back
 * involved making it 'private' again (hence, `convertToPrivate`).
 *
 * @param node the child node to convert
 * @returns a converted virtual DOM node
 */
const convertToPrivate = (node) => {
    if (typeof node.vtag === 'function') {
        const vnodeData = Object.assign({}, node.vattrs);
        if (node.vkey) {
            vnodeData.key = node.vkey;
        }
        if (node.vname) {
            vnodeData.name = node.vname;
        }
        return h(node.vtag, vnodeData, ...(node.vchildren || []));
    }
    const vnode = newVNode(node.vtag, node.vtext);
    vnode.$attrs$ = node.vattrs;
    vnode.$children$ = node.vchildren;
    vnode.$key$ = node.vkey;
    vnode.$name$ = node.vname;
    return vnode;
};
/**
 * Validates the ordering of attributes on an input element
 *
 * @param inputElm the element to validate
 */
const validateInputProperties = (inputElm) => {
    const props = Object.keys(inputElm);
    const value = props.indexOf('value');
    if (value === -1) {
        return;
    }
    const typeIndex = props.indexOf('type');
    const minIndex = props.indexOf('min');
    const maxIndex = props.indexOf('max');
    const stepIndex = props.indexOf('step');
    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {
        consoleDevWarn(`The "value" prop of <input> should be set after "min", "max", "type" and "step"`);
    }
};
const initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {
    const endHydrate = createTime('hydrateClient', tagName);
    const shadowRoot = hostElm.shadowRoot;
    const childRenderNodes = [];
    const slotNodes = [];
    const shadowRootNodes = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRoot ? [] : null;
    const vnode = (hostRef.$vnode$ = newVNode(tagName, null));
    if (!plt.$orgLocNodes$) {
        initializeDocumentHydrate(doc.body, (plt.$orgLocNodes$ = new Map()));
    }
    hostElm[HYDRATE_ID] = hostId;
    hostElm.removeAttribute(HYDRATE_ID);
    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);
    childRenderNodes.map((c) => {
        const orgLocationId = c.$hostId$ + '.' + c.$nodeId$;
        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);
        const node = c.$elm$;
        if (orgLocationNode && supportsShadow && orgLocationNode['s-en'] === '') {
            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);
        }
        if (!shadowRoot) {
            node['s-hn'] = tagName;
            if (orgLocationNode) {
                node['s-ol'] = orgLocationNode;
                node['s-ol']['s-nr'] = node;
            }
        }
        plt.$orgLocNodes$.delete(orgLocationId);
    });
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRoot) {
        shadowRootNodes.map((shadowRootNode) => {
            if (shadowRootNode) {
                shadowRoot.appendChild(shadowRootNode);
            }
        });
    }
    endHydrate();
};
const clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {
    let childNodeType;
    let childIdSplt;
    let childVNode;
    let i;
    if (node.nodeType === 1 /* NODE_TYPE.ElementNode */) {
        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);
        if (childNodeType) {
            // got the node data from the element's attribute
            // `${hostId}.${nodeId}.${depth}.${index}`
            childIdSplt = childNodeType.split('.');
            if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {
                childVNode = {
                    $flags$: 0,
                    $hostId$: childIdSplt[0],
                    $nodeId$: childIdSplt[1],
                    $depth$: childIdSplt[2],
                    $index$: childIdSplt[3],
                    $tag$: node.tagName.toLowerCase(),
                    $elm$: node,
                    $attrs$: null,
                    $children$: null,
                    $key$: null,
                    $name$: null,
                    $text$: null,
                };
                childRenderNodes.push(childVNode);
                node.removeAttribute(HYDRATE_CHILD_ID);
                // this is a new child vnode
                // so ensure its parent vnode has the vchildren array
                if (!parentVNode.$children$) {
                    parentVNode.$children$ = [];
                }
                // add our child vnode to a specific index of the vnode's children
                parentVNode.$children$[childVNode.$index$] = childVNode;
                // this is now the new parent vnode for all the next child checks
                parentVNode = childVNode;
                if (shadowRootNodes && childVNode.$depth$ === '0') {
                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                }
            }
        }
        // recursively drill down, end to start so we can remove nodes
        for (i = node.childNodes.length - 1; i >= 0; i--) {
            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);
        }
        if (node.shadowRoot) {
            // keep drilling down through the shadow root nodes
            for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {
                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);
            }
        }
    }
    else if (node.nodeType === 8 /* NODE_TYPE.CommentNode */) {
        // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`
        childIdSplt = node.nodeValue.split('.');
        if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {
            // comment node for either the host id or a 0 host id
            childNodeType = childIdSplt[0];
            childVNode = {
                $flags$: 0,
                $hostId$: childIdSplt[1],
                $nodeId$: childIdSplt[2],
                $depth$: childIdSplt[3],
                $index$: childIdSplt[4],
                $elm$: node,
                $attrs$: null,
                $children$: null,
                $key$: null,
                $name$: null,
                $tag$: null,
                $text$: null,
            };
            if (childNodeType === TEXT_NODE_ID) {
                childVNode.$elm$ = node.nextSibling;
                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* NODE_TYPE.TextNode */) {
                    childVNode.$text$ = childVNode.$elm$.textContent;
                    childRenderNodes.push(childVNode);
                    // remove the text comment since it's no longer needed
                    node.remove();
                    if (!parentVNode.$children$) {
                        parentVNode.$children$ = [];
                    }
                    parentVNode.$children$[childVNode.$index$] = childVNode;
                    if (shadowRootNodes && childVNode.$depth$ === '0') {
                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                    }
                }
            }
            else if (childVNode.$hostId$ === hostId) {
                // this comment node is specifcally for this host id
                if (childNodeType === SLOT_NODE_ID) {
                    // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;
                    childVNode.$tag$ = 'slot';
                    if (childIdSplt[5]) {
                        node['s-sn'] = childVNode.$name$ = childIdSplt[5];
                    }
                    else {
                        node['s-sn'] = '';
                    }
                    node['s-sr'] = true;
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRootNodes) {
                        // browser support shadowRoot and this is a shadow dom component
                        // create an actual slot element
                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);
                        if (childVNode.$name$) {
                            // add the slot name attribute
                            childVNode.$elm$.setAttribute('name', childVNode.$name$);
                        }
                        // insert the new slot element before the slot comment
                        node.parentNode.insertBefore(childVNode.$elm$, node);
                        // remove the slot comment since it's not needed for shadow
                        node.remove();
                        if (childVNode.$depth$ === '0') {
                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                        }
                    }
                    slotNodes.push(childVNode);
                    if (!parentVNode.$children$) {
                        parentVNode.$children$ = [];
                    }
                    parentVNode.$children$[childVNode.$index$] = childVNode;
                }
                else if (childNodeType === CONTENT_REF_ID) {
                    // `${CONTENT_REF_ID}.${hostId}`;
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRootNodes) {
                        // remove the content ref comment since it's not needed for shadow
                        node.remove();
                    }
                    else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
                        hostElm['s-cr'] = node;
                        node['s-cn'] = true;
                    }
                }
            }
        }
    }
    else if (parentVNode && parentVNode.$tag$ === 'style') {
        const vnode = newVNode(null, node.textContent);
        vnode.$elm$ = node;
        vnode.$index$ = '0';
        parentVNode.$children$ = [vnode];
    }
};
const initializeDocumentHydrate = (node, orgLocNodes) => {
    if (node.nodeType === 1 /* NODE_TYPE.ElementNode */) {
        let i = 0;
        for (; i < node.childNodes.length; i++) {
            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);
        }
        if (node.shadowRoot) {
            for (i = 0; i < node.shadowRoot.childNodes.length; i++) {
                initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);
            }
        }
    }
    else if (node.nodeType === 8 /* NODE_TYPE.CommentNode */) {
        const childIdSplt = node.nodeValue.split('.');
        if (childIdSplt[0] === ORG_LOCATION_ID) {
            orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);
            node.nodeValue = '';
            // useful to know if the original location is
            // the root light-dom of a shadow dom component
            node['s-en'] = childIdSplt[3];
        }
    }
};
// Private
const computeMode = (elm) => modeResolutionChain.map((h) => h(elm)).find((m) => !!m);
// Public
const setMode = (handler) => modeResolutionChain.push(handler);
const getMode = (ref) => getHostRef(ref).$modeName$;
/**
 * Parse a new property value for a given property type.
 *
 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
 *   1. `any`, the type given to `propValue` in the function signature
 *   2. the type stored from `propType`.
 *
 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
 *
 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
 * ```tsx
 * <my-cmp prop-val={0}></my-cmp>
 * ```
 *
 * HTML prop values on the other hand, will always a string
 *
 * @param propValue the new value to coerce to some type
 * @param propType the type of the prop, expressed as a binary number
 * @returns the parsed/coerced value
 */
const parsePropertyValue = (propValue, propType) => {
    // ensure this value is of the correct prop type
    if (propValue != null && !isComplexType(propValue)) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propBoolean && propType & 4 /* MEMBER_FLAGS.Boolean */) {
            // per the HTML spec, any string value means it is a boolean true value
            // but we'll cheat here and say that the string "false" is the boolean false
            return propValue === 'false' ? false : propValue === '' || !!propValue;
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propNumber && propType & 2 /* MEMBER_FLAGS.Number */) {
            // force it to be a number
            return parseFloat(propValue);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propString && propType & 1 /* MEMBER_FLAGS.String */) {
            // could have been passed as a number or boolean
            // but we still want it as a string
            return String(propValue);
        }
        // redundant return here for better minification
        return propValue;
    }
    // not sure exactly what type we want
    // so no need to change to a different type
    return propValue;
};
const getElement = (ref) => (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref);
const createEvent = (ref, name, flags) => {
    const elm = getElement(ref);
    return {
        emit: (detail) => {
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && !elm.isConnected) {
                consoleDevWarn(`The "${name}" event was emitted, but the dispatcher node is no longer connected to the dom.`);
            }
            return emitEvent(elm, name, {
                bubbles: !!(flags & 4 /* EVENT_FLAGS.Bubbles */),
                composed: !!(flags & 2 /* EVENT_FLAGS.Composed */),
                cancelable: !!(flags & 1 /* EVENT_FLAGS.Cancellable */),
                detail,
            });
        },
    };
};
/**
 * Helper function to create & dispatch a custom Event on a provided target
 * @param elm the target of the Event
 * @param name the name to give the custom Event
 * @param opts options for configuring a custom Event
 * @returns the custom Event
 */
const emitEvent = (elm, name, opts) => {
    const ev = plt.ce(name, opts);
    elm.dispatchEvent(ev);
    return ev;
};
const rootAppliedStyles = /*@__PURE__*/ new WeakMap();
const registerStyle = (scopeId, cssText, allowCS) => {
    let style = styles.get(scopeId);
    if (supportsConstructableStylesheets && allowCS) {
        style = (style || new CSSStyleSheet());
        if (typeof style === 'string') {
            style = cssText;
        }
        else {
            style.replaceSync(cssText);
        }
    }
    else {
        style = cssText;
    }
    styles.set(scopeId, style);
};
const addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {
    var _a;
    let scopeId = getScopeId(cmpMeta, mode);
    const style = styles.get(scopeId);
    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.attachStyles) {
        return scopeId;
    }
    // if an element is NOT connected then getRootNode() will return the wrong root node
    // so the fallback is to always use the document for the root node in those cases
    styleContainerNode = styleContainerNode.nodeType === 11 /* NODE_TYPE.DocumentFragment */ ? styleContainerNode : doc;
    if (style) {
        if (typeof style === 'string') {
            styleContainerNode = styleContainerNode.head || styleContainerNode;
            let appliedStyles = rootAppliedStyles.get(styleContainerNode);
            let styleElm;
            if (!appliedStyles) {
                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));
            }
            if (!appliedStyles.has(scopeId)) {
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide &&
                    styleContainerNode.host &&
                    (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}="${scopeId}"]`))) {
                    // This is only happening on native shadow-dom, do not needs CSS var shim
                    styleElm.innerHTML = style;
                }
                else {
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim && plt.$cssShim$) {
                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* CMP_FLAGS.needsScopedEncapsulation */));
                        const newScopeId = styleElm['s-sc'];
                        if (newScopeId) {
                            scopeId = newScopeId;
                            // we don't want to add this styleID to the appliedStyles Set
                            // since the cssVarShim might need to apply several different
                            // stylesheets for the same component
                            appliedStyles = null;
                        }
                    }
                    else {
                        styleElm = doc.createElement('style');
                        styleElm.innerHTML = style;
                    }
                    // Apply CSP nonce to the style tag if it exists
                    const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
                    if (nonce != null) {
                        styleElm.setAttribute('nonce', nonce);
                    }
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {
                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);
                    }
                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));
                }
                if (appliedStyles) {
                    appliedStyles.add(scopeId);
                }
            }
        }
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {
            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
        }
    }
    return scopeId;
};
const attachStyles = (hostRef) => {
    const cmpMeta = hostRef.$cmpMeta$;
    const elm = hostRef.$hostElement$;
    const flags = cmpMeta.$flags$;
    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);
    const scopeId = addStyle(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);
    if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped) && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations && flags & 10 /* CMP_FLAGS.needsScopedEncapsulation */) {
        // only required when we're NOT using native shadow dom (slot)
        // or this browser doesn't support native shadow dom
        // and this host element was NOT created with SSR
        // let's pick out the inner content for slot projection
        // create a node to represent where the original
        // content was first placed, which is useful later on
        // DOM WRITE!!
        elm['s-sc'] = scopeId;
        elm.classList.add(scopeId + '-h');
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped && flags & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {
            elm.classList.add(scopeId + '-s');
        }
    }
    endAttachStyles();
};
const getScopeId = (cmp, mode) => 'sc-' + (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode && mode && cmp.$flags$ & 32 /* CMP_FLAGS.hasMode */ ? cmp.$tagName$ + '-' + mode : cmp.$tagName$);
const convertScopedToShadow = (css) => css.replace(/\/\*!@([^\/]+)\*\/[^\{]+\{/g, '$1{');
/**
 * Production setAccessor() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
    if (oldValue !== newValue) {
        let isProp = isMemberInElement(elm, memberName);
        let ln = memberName.toLowerCase();
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomClass && memberName === 'class') {
            const classList = elm.classList;
            const oldClasses = parseClassList(oldValue);
            const newClasses = parseClassList(newValue);
            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
        }
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomStyle && memberName === 'style') {
            // update style attribute, css properties and values
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {
                for (const prop in oldValue) {
                    if (!newValue || newValue[prop] == null) {
                        if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && prop.includes('-')) {
                            elm.style.removeProperty(prop);
                        }
                        else {
                            elm.style[prop] = '';
                        }
                    }
                }
            }
            for (const prop in newValue) {
                if (!oldValue || newValue[prop] !== oldValue[prop]) {
                    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && prop.includes('-')) {
                        elm.style.setProperty(prop, newValue[prop]);
                    }
                    else {
                        elm.style[prop] = newValue[prop];
                    }
                }
            }
        }
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && memberName === 'key')
            ;
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRef && memberName === 'ref') {
            // minifier will clean this up
            if (newValue) {
                newValue(elm);
            }
        }
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomListener &&
            (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) &&
            memberName[0] === 'o' &&
            memberName[1] === 'n') {
            // Event Handlers
            // so if the member name starts with "on" and the 3rd characters is
            // a capital letter, and it's not already a member on the element,
            // then we're assuming it's an event listener
            if (memberName[2] === '-') {
                // on- prefixed events
                // allows to be explicit about the dom event to listen without any magic
                // under the hood:
                // <my-cmp on-click> // listens for "click"
                // <my-cmp on-Click> // listens for "Click"
                // <my-cmp on-ionChange> // listens for "ionChange"
                // <my-cmp on-EVENTS> // listens for "EVENTS"
                memberName = memberName.slice(3);
            }
            else if (isMemberInElement(win, ln)) {
                // standard event
                // the JSX attribute could have been "onMouseOver" and the
                // member name "onmouseover" is on the window's prototype
                // so let's add the listener "mouseover", which is all lowercased
                memberName = ln.slice(2);
            }
            else {
                // custom event
                // the JSX attribute could have been "onMyCustomEvent"
                // so let's trim off the "on" prefix and lowercase the first character
                // and add the listener "myCustomEvent"
                // except for the first character, we keep the event name case
                memberName = ln[2] + memberName.slice(3);
            }
            if (oldValue) {
                plt.rel(elm, memberName, oldValue, false);
            }
            if (newValue) {
                plt.ael(elm, memberName, newValue, false);
            }
        }
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomPropOrAttr) {
            // Set property if it exists and it's not a SVG
            const isComplex = isComplexType(newValue);
            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {
                try {
                    if (!elm.tagName.includes('-')) {
                        const n = newValue == null ? '' : newValue;
                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued
                        if (memberName === 'list') {
                            isProp = false;
                        }
                        else if (oldValue == null || elm[memberName] != n) {
                            elm[memberName] = n;
                        }
                    }
                    else {
                        elm[memberName] = newValue;
                    }
                }
                catch (e) { }
            }
            /**
             * Need to manually update attribute if:
             * - memberName is not an attribute
             * - if we are rendering the host element in order to reflect attribute
             * - if it's a SVG, since properties might not work in <svg>
             * - if the newValue is null/undefined or 'false'.
             */
            let xlink = false;
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink) {
                if (ln !== (ln = ln.replace(/^xlink\:?/, ''))) {
                    memberName = ln;
                    xlink = true;
                }
            }
            if (newValue == null || newValue === false) {
                if (newValue !== false || elm.getAttribute(memberName) === '') {
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink && xlink) {
                        elm.removeAttributeNS(XLINK_NS, memberName);
                    }
                    else {
                        elm.removeAttribute(memberName);
                    }
                }
            }
            else if ((!isProp || flags & 4 /* VNODE_FLAGS.isHost */ || isSvg) && !isComplex) {
                newValue = newValue === true ? '' : newValue;
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink && xlink) {
                    elm.setAttributeNS(XLINK_NS, memberName, newValue);
                }
                else {
                    elm.setAttribute(memberName, newValue);
                }
            }
        }
    }
};
const parseClassListRegex = /\s/;
const parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));
const updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {
    // if the element passed in is a shadow root, which is a document fragment
    // then we want to be adding attrs/props to the shadow root's "host" element
    // if it's not a shadow root, then we add attrs/props to the same element
    const elm = newVnode.$elm$.nodeType === 11 /* NODE_TYPE.DocumentFragment */ && newVnode.$elm$.host
        ? newVnode.$elm$.host
        : newVnode.$elm$;
    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;
    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {
        // remove attributes no longer present on the vnode by setting them to undefined
        for (memberName in oldVnodeAttrs) {
            if (!(memberName in newVnodeAttrs)) {
                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
            }
        }
    }
    // add new & update changed attributes
    for (memberName in newVnodeAttrs) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
    }
};
/**
 * Create a DOM Node corresponding to one of the children of a given VNode.
 *
 * @param oldParentVNode the parent VNode from the previous render
 * @param newParentVNode the parent VNode from the current render
 * @param childIndex the index of the VNode, in the _new_ parent node's
 * children, for which we will create a new DOM node
 * @param parentElm the parent DOM node which our new node will be a child of
 * @returns the newly created node
 */
const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
    // tslint:disable-next-line: prefer-const
    const newVNode = newParentVNode.$children$[childIndex];
    let i = 0;
    let elm;
    let childNode;
    let oldVNode;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && !useNativeShadowDom) {
        // remember for later we need to check to relocate nodes
        checkSlotRelocate = true;
        if (newVNode.$tag$ === 'slot') {
            if (scopeId) {
                // scoped css needs to add its scoped id to the parent element
                parentElm.classList.add(scopeId + '-s');
            }
            newVNode.$flags$ |= newVNode.$children$
                ? // slot element has fallback content
                    2 /* VNODE_FLAGS.isSlotFallback */
                : // slot element does not have fallback content
                    1 /* VNODE_FLAGS.isSlotReference */;
        }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && newVNode.$elm$) {
        consoleDevError(`The JSX ${newVNode.$text$ !== null ? `"${newVNode.$text$}" text` : `"${newVNode.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && newVNode.$text$ !== null) {
        // create text node
        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
    }
    else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && newVNode.$flags$ & 1 /* VNODE_FLAGS.isSlotReference */) {
        // create a slot reference node
        elm = newVNode.$elm$ =
            _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode('');
    }
    else {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg && !isSvgMode) {
            isSvgMode = newVNode.$tag$ === 'svg';
        }
        // create element
        elm = newVNode.$elm$ = (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg
            ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && newVNode.$flags$ & 2 /* VNODE_FLAGS.isSlotFallback */
                ? 'slot-fb'
                : newVNode.$tag$)
            : doc.createElement(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && newVNode.$flags$ & 2 /* VNODE_FLAGS.isSlotFallback */
                ? 'slot-fb'
                : newVNode.$tag$));
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg && isSvgMode && newVNode.$tag$ === 'foreignObject') {
            isSvgMode = false;
        }
        // add css classes, attrs, props, listeners, etc.
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute) {
            updateElement(null, newVNode, isSvgMode);
        }
        if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped) && isDef(scopeId) && elm['s-si'] !== scopeId) {
            // if there is a scopeId and this is the initial render
            // then let's add the scopeId as a css class
            elm.classList.add((elm['s-si'] = scopeId));
        }
        if (newVNode.$children$) {
            for (i = 0; i < newVNode.$children$.length; ++i) {
                // create the node
                childNode = createElm(oldParentVNode, newVNode, i, elm);
                // return node could have been null
                if (childNode) {
                    // append our new node
                    elm.appendChild(childNode);
                }
            }
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg) {
            if (newVNode.$tag$ === 'svg') {
                // Only reset the SVG context when we're exiting <svg> element
                isSvgMode = false;
            }
            else if (elm.tagName === 'foreignObject') {
                // Reenter SVG context when we're exiting <foreignObject> element
                isSvgMode = true;
            }
        }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
        elm['s-hn'] = hostTagName;
        if (newVNode.$flags$ & (2 /* VNODE_FLAGS.isSlotFallback */ | 1 /* VNODE_FLAGS.isSlotReference */)) {
            // remember the content reference comment
            elm['s-sr'] = true;
            // remember the content reference comment
            elm['s-cr'] = contentRef;
            // remember the slot name, or empty string for default slot
            elm['s-sn'] = newVNode.$name$ || '';
            // check if we've got an old vnode for this slot
            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {
                // we've got an old slot vnode and the wrapper is being replaced
                // so let's move the old slot content back to it's original location
                putBackInOriginalLocation(oldParentVNode.$elm$, false);
            }
        }
    }
    return elm;
};
const putBackInOriginalLocation = (parentElm, recursive) => {
    plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;
    const oldSlotChildNodes = parentElm.childNodes;
    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {
        const childNode = oldSlotChildNodes[i];
        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {
            // // this child node in the old element is from another component
            // // remove this node from the old slot's parent
            // childNode.remove();
            // and relocate it back to it's original location
            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
            // remove the old original location comment entirely
            // later on the patch function will know what to do
            // and move this to the correct spot in need be
            childNode['s-ol'].remove();
            childNode['s-ol'] = undefined;
            checkSlotRelocate = true;
        }
        if (recursive) {
            putBackInOriginalLocation(childNode, recursive);
        }
    }
    plt.$flags$ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;
};
/**
 * Create DOM nodes corresponding to a list of {@link d.Vnode} objects and
 * add them to the DOM in the appropriate place.
 *
 * @param parentElm the DOM node which should be used as a parent for the new
 * DOM nodes
 * @param before a child of the `parentElm` which the new children should be
 * inserted before (optional)
 * @param parentVNode the parent virtual DOM node
 * @param vnodes the new child virtual DOM nodes to produce DOM nodes for
 * @param startIdx the index in the child virtual DOM nodes at which to start
 * creating DOM nodes (inclusive)
 * @param endIdx the index in the child virtual DOM nodes at which to stop
 * creating DOM nodes (inclusive)
 */
const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
    let containerElm = ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);
    let childNode;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
    }
    for (; startIdx <= endIdx; ++startIdx) {
        if (vnodes[startIdx]) {
            childNode = createElm(null, parentVNode, startIdx, parentElm);
            if (childNode) {
                vnodes[startIdx].$elm$ = childNode;
                containerElm.insertBefore(childNode, _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation ? referenceNode(before) : before);
            }
        }
    }
};
/**
 * Remove the DOM elements corresponding to a list of {@link d.VNode} objects.
 * This can be used to, for instance, clean up after a list of children which
 * should no longer be shown.
 *
 * This function also handles some of Stencil's slot relocation logic.
 *
 * @param vnodes a list of virtual DOM nodes to remove
 * @param startIdx the index at which to start removing nodes (inclusive)
 * @param endIdx the index at which to stop removing nodes (inclusive)
 * @param vnode a VNode
 * @param elm an element
 */
const removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {
    for (; startIdx <= endIdx; ++startIdx) {
        if ((vnode = vnodes[startIdx])) {
            elm = vnode.$elm$;
            callNodeRefs(vnode);
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
                // we're removing this element
                // so it's possible we need to show slot fallback content now
                checkSlotFallbackVisibility = true;
                if (elm['s-ol']) {
                    // remove the original location comment
                    elm['s-ol'].remove();
                }
                else {
                    // it's possible that child nodes of the node
                    // that's being removed are slot nodes
                    putBackInOriginalLocation(elm, true);
                }
            }
            // remove the vnode's element from the dom
            elm.remove();
        }
    }
};
/**
 * Reconcile the children of a new VNode with the children of an old VNode by
 * traversing the two collections of children, identifying nodes that are
 * conserved or changed, calling out to `patch` to make any necessary
 * updates to the DOM, and rearranging DOM nodes as needed.
 *
 * The algorithm for reconciling children works by analyzing two 'windows' onto
 * the two arrays of children (`oldCh` and `newCh`). We keep track of the
 * 'windows' by storing start and end indices and references to the
 * corresponding array entries. Initially the two 'windows' are basically equal
 * to the entire array, but we progressively narrow the windows until there are
 * no children left to update by doing the following:
 *
 * 1. Skip any `null` entries at the beginning or end of the two arrays, so
 *    that if we have an initial array like the following we'll end up dealing
 *    only with a window bounded by the highlighted elements:
 *
 *    [null, null, VNode1 , ... , VNode2, null, null]
 *                 ^^^^^^         ^^^^^^
 *
 * 2. Check to see if the elements at the head and tail positions are equal
 *    across the windows. This will basically detect elements which haven't
 *    been added, removed, or changed position, i.e. if you had the following
 *    VNode elements (represented as HTML):
 *
 *    oldVNode: `<div><p><span>HEY</span></p></div>`
 *    newVNode: `<div><p><span>THERE</span></p></div>`
 *
 *    Then when comparing the children of the `<div>` tag we check the equality
 *    of the VNodes corresponding to the `<p>` tags and, since they are the
 *    same tag in the same position, we'd be able to avoid completely
 *    re-rendering the subtree under them with a new DOM element and would just
 *    call out to `patch` to handle reconciling their children and so on.
 *
 * 3. Check, for both windows, to see if the element at the beginning of the
 *    window corresponds to the element at the end of the other window. This is
 *    a heuristic which will let us identify _some_ situations in which
 *    elements have changed position, for instance it _should_ detect that the
 *    children nodes themselves have not changed but merely moved in the
 *    following example:
 *
 *    oldVNode: `<div><element-one /><element-two /></div>`
 *    newVNode: `<div><element-two /><element-one /></div>`
 *
 *    If we find cases like this then we also need to move the concrete DOM
 *    elements corresponding to the moved children to write the re-order to the
 *    DOM.
 *
 * 4. Finally, if VNodes have the `key` attribute set on them we check for any
 *    nodes in the old children which have the same key as the first element in
 *    our window on the new children. If we find such a node we handle calling
 *    out to `patch`, moving relevant DOM nodes, and so on, in accordance with
 *    what we find.
 *
 * Finally, once we've narrowed our 'windows' to the point that either of them
 * collapse (i.e. they have length 0) we then handle any remaining VNode
 * insertion or deletion that needs to happen to get a DOM state that correctly
 * reflects the new child VNodes. If, for instance, after our window on the old
 * children has collapsed we still have more nodes on the new children that
 * we haven't dealt with yet then we need to add them, or if the new children
 * collapse but we still have unhandled _old_ children then we need to make
 * sure the corresponding DOM nodes are removed.
 *
 * @param parentElm the node into which the parent VNode is rendered
 * @param oldCh the old children of the parent node
 * @param newVNode the new VNode which will replace the parent
 * @param newCh the new children of the parent node
 */
const updateChildren = (parentElm, oldCh, newVNode, newCh) => {
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let idxInOld = 0;
    let i = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let node;
    let elmToMove;
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (oldStartVnode == null) {
            // VNode might have been moved left
            oldStartVnode = oldCh[++oldStartIdx];
        }
        else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx];
        }
        else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx];
        }
        else if (newEndVnode == null) {
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldStartVnode, newStartVnode)) {
            // if the start nodes are the same then we should patch the new VNode
            // onto the old one, and increment our `newStartIdx` and `oldStartIdx`
            // indices to reflect that. We don't need to move any DOM Nodes around
            // since things are matched up in order.
            patch(oldStartVnode, newStartVnode);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
        }
        else if (isSameVnode(oldEndVnode, newEndVnode)) {
            // likewise, if the end nodes are the same we patch new onto old and
            // decrement our end indices, and also likewise in this case we don't
            // need to move any DOM Nodes.
            patch(oldEndVnode, newEndVnode);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldStartVnode, newEndVnode)) {
            // case: "Vnode moved right"
            //
            // We've found that the last node in our window on the new children is
            // the same VNode as the _first_ node in our window on the old children
            // we're dealing with now. Visually, this is the layout of these two
            // nodes:
            //
            // newCh: [..., newStartVnode , ... , newEndVnode , ...]
            //                                    ^^^^^^^^^^^
            // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]
            //              ^^^^^^^^^^^^^
            //
            // In this situation we need to patch `newEndVnode` onto `oldStartVnode`
            // and move the DOM element for `oldStartVnode`.
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {
                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
            }
            patch(oldStartVnode, newEndVnode);
            // We need to move the element for `oldStartVnode` into a position which
            // will be appropriate for `newEndVnode`. For this we can use
            // `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a
            // sibling for `oldEndVnode.$elm$` then we want to move the DOM node for
            // `oldStartVnode` between `oldEndVnode` and it's sibling, like so:
            //
            // <old-start-node />
            // <some-intervening-node />
            // <old-end-node />
            // <!-- ->              <-- `oldStartVnode.$elm$` should be inserted here
            // <next-sibling />
            //
            // If instead `oldEndVnode.$elm$` has no sibling then we just want to put
            // the node for `oldStartVnode` at the end of the children of
            // `parentElm`. Luckily, `Node.nextSibling` will return `null` if there
            // aren't any siblings, and passing `null` to `Node.insertBefore` will
            // append it to the children of the parent element.
            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldEndVnode, newStartVnode)) {
            // case: "Vnode moved left"
            //
            // We've found that the first node in our window on the new children is
            // the same VNode as the _last_ node in our window on the old children.
            // Visually, this is the layout of these two nodes:
            //
            // newCh: [..., newStartVnode , ... , newEndVnode , ...]
            //              ^^^^^^^^^^^^^
            // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]
            //                                    ^^^^^^^^^^^
            //
            // In this situation we need to patch `newStartVnode` onto `oldEndVnode`
            // (which will handle updating any changed attributes, reconciling their
            // children etc) but we also need to move the DOM node to which
            // `oldEndVnode` corresponds.
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {
                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
            }
            patch(oldEndVnode, newStartVnode);
            // We've already checked above if `oldStartVnode` and `newStartVnode` are
            // the same node, so since we're here we know that they are not. Thus we
            // can move the element for `oldEndVnode` _before_ the element for
            // `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the
            // future.
            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
        }
        else {
            // Here we do some checks to match up old and new nodes based on the
            // `$key$` attribute, which is set by putting a `key="my-key"` attribute
            // in the JSX for a DOM element in the implementation of a Stencil
            // component.
            //
            // First we check to see if there are any nodes in the array of old
            // children which have the same key as the first node in the new
            // children.
            idxInOld = -1;
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {
                for (i = oldStartIdx; i <= oldEndIdx; ++i) {
                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
                        idxInOld = i;
                        break;
                    }
                }
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && idxInOld >= 0) {
                // We found a node in the old children which matches up with the first
                // node in the new children! So let's deal with that
                elmToMove = oldCh[idxInOld];
                if (elmToMove.$tag$ !== newStartVnode.$tag$) {
                    // the tag doesn't match so we'll need a new DOM element
                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);
                }
                else {
                    patch(elmToMove, newStartVnode);
                    // invalidate the matching old node so that we won't try to update it
                    // again later on
                    oldCh[idxInOld] = undefined;
                    node = elmToMove.$elm$;
                }
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                // We either didn't find an element in the old children that matches
                // the key of the first new child OR the build is not using `key`
                // attributes at all. In either case we need to create a new element
                // for the new node.
                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);
                newStartVnode = newCh[++newStartIdx];
            }
            if (node) {
                // if we created a new node then handle inserting it to the DOM
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
                }
                else {
                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
                }
            }
        }
    }
    if (oldStartIdx > oldEndIdx) {
        // we have some more new nodes to add which don't match up with old nodes
        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
    }
    else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && newStartIdx > newEndIdx) {
        // there are nodes in the `oldCh` array which no longer correspond to nodes
        // in the new array, so lets remove them (which entails cleaning up the
        // relevant DOM nodes)
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
};
/**
 * Compare two VNodes to determine if they are the same
 *
 * **NB**: This function is an equality _heuristic_ based on the available
 * information set on the two VNodes and can be misleading under certain
 * circumstances. In particular, if the two nodes do not have `key` attrs
 * (available under `$key$` on VNodes) then the function falls back on merely
 * checking that they have the same tag.
 *
 * So, in other words, if `key` attrs are not set on VNodes which may be
 * changing order within a `children` array or something along those lines then
 * we could obtain a false negative and then have to do needless re-rendering
 * (i.e. we'd say two VNodes aren't equal when in fact they should be).
 *
 * @param leftVNode the first VNode to check
 * @param rightVNode the second VNode to check
 * @returns whether they're equal or not
 */
const isSameVnode = (leftVNode, rightVNode) => {
    // compare if two vnode to see if they're "technically" the same
    // need to have the same element tag, and same key to be the same
    if (leftVNode.$tag$ === rightVNode.$tag$) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && leftVNode.$tag$ === 'slot') {
            return leftVNode.$name$ === rightVNode.$name$;
        }
        // this will be set if components in the build have `key` attrs set on them
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {
            return leftVNode.$key$ === rightVNode.$key$;
        }
        return true;
    }
    return false;
};
const referenceNode = (node) => {
    // this node was relocated to a new location in the dom
    // because of some other component's slot
    // but we still have an html comment in place of where
    // it's original location was according to it's original vdom
    return (node && node['s-ol']) || node;
};
const parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;
/**
 * Handle reconciling an outdated VNode with a new one which corresponds to
 * it. This function handles flushing updates to the DOM and reconciling the
 * children of the two nodes (if any).
 *
 * @param oldVNode an old VNode whose DOM element and children we want to update
 * @param newVNode a new VNode representing an updated version of the old one
 */
const patch = (oldVNode, newVNode) => {
    const elm = (newVNode.$elm$ = oldVNode.$elm$);
    const oldChildren = oldVNode.$children$;
    const newChildren = newVNode.$children$;
    const tag = newVNode.$tag$;
    const text = newVNode.$text$;
    let defaultHolder;
    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText || text === null) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg) {
            // test if we're rendering an svg element, or still rendering nodes inside of one
            // only add this to the when the compiler sees we're using an svg somewhere
            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot && tag === 'slot')
                ;
            else {
                // either this is the first render of an element OR it's an update
                // AND we already know it's possible it could have changed
                // this updates the element's css classes, attrs, props, listeners, etc.
                updateElement(oldVNode, newVNode, isSvgMode);
            }
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && oldChildren !== null && newChildren !== null) {
            // looks like there's child vnodes for both the old and new vnodes
            // so we need to call `updateChildren` to reconcile them
            updateChildren(elm, oldChildren, newVNode, newChildren);
        }
        else if (newChildren !== null) {
            // no old child vnodes, but there are new child vnodes to add
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && oldVNode.$text$ !== null) {
                // the old vnode was text, so be sure to clear it out
                elm.textContent = '';
            }
            // add the new vnode children
            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
        }
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && oldChildren !== null) {
            // no new child vnodes, but there are old child vnodes to remove
            removeVnodes(oldChildren, 0, oldChildren.length - 1);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg && isSvgMode && tag === 'svg') {
            isSvgMode = false;
        }
    }
    else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && (defaultHolder = elm['s-cr'])) {
        // this element has slotted content
        defaultHolder.parentNode.textContent = text;
    }
    else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && oldVNode.$text$ !== text) {
        // update the text content for the text only vnode
        // and also only if the text is different than before
        elm.data = text;
    }
};
const updateFallbackSlotVisibility = (elm) => {
    // tslint:disable-next-line: prefer-const
    const childNodes = elm.childNodes;
    let childNode;
    let i;
    let ilen;
    let j;
    let slotNameAttr;
    let nodeType;
    for (i = 0, ilen = childNodes.length; i < ilen; i++) {
        childNode = childNodes[i];
        if (childNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {
            if (childNode['s-sr']) {
                // this is a slot fallback node
                // get the slot name for this slot reference node
                slotNameAttr = childNode['s-sn'];
                // by default always show a fallback slot node
                // then hide it if there are other slots in the light dom
                childNode.hidden = false;
                for (j = 0; j < ilen; j++) {
                    nodeType = childNodes[j].nodeType;
                    if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {
                        // this sibling node is from a different component OR is a named fallback slot node
                        if (nodeType === 1 /* NODE_TYPE.ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {
                            childNode.hidden = true;
                            break;
                        }
                    }
                    else {
                        // this is a default fallback slot node
                        // any element or text node (with content)
                        // should hide the default fallback slot node
                        if (nodeType === 1 /* NODE_TYPE.ElementNode */ ||
                            (nodeType === 3 /* NODE_TYPE.TextNode */ && childNodes[j].textContent.trim() !== '')) {
                            childNode.hidden = true;
                            break;
                        }
                    }
                }
            }
            // keep drilling down
            updateFallbackSlotVisibility(childNode);
        }
    }
};
const relocateNodes = [];
const relocateSlotContent = (elm) => {
    // tslint:disable-next-line: prefer-const
    let childNode;
    let node;
    let hostContentNodes;
    let slotNameAttr;
    let relocateNodeData;
    let j;
    let i = 0;
    const childNodes = elm.childNodes;
    const ilen = childNodes.length;
    for (; i < ilen; i++) {
        childNode = childNodes[i];
        if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {
            // first got the content reference comment node
            // then we got it's parent, which is where all the host content is in now
            hostContentNodes = node.parentNode.childNodes;
            slotNameAttr = childNode['s-sn'];
            for (j = hostContentNodes.length - 1; j >= 0; j--) {
                node = hostContentNodes[j];
                if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {
                    // let's do some relocating to its new home
                    // but never relocate a content reference node
                    // that is suppose to always represent the original content location
                    if (isNodeLocatedInSlot(node, slotNameAttr)) {
                        // it's possible we've already decided to relocate this node
                        relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
                        // made some changes to slots
                        // let's make sure we also double check
                        // fallbacks are correctly hidden or shown
                        checkSlotFallbackVisibility = true;
                        node['s-sn'] = node['s-sn'] || slotNameAttr;
                        if (relocateNodeData) {
                            // previously we never found a slot home for this node
                            // but turns out we did, so let's remember it now
                            relocateNodeData.$slotRefNode$ = childNode;
                        }
                        else {
                            // add to our list of nodes to relocate
                            relocateNodes.push({
                                $slotRefNode$: childNode,
                                $nodeToRelocate$: node,
                            });
                        }
                        if (node['s-sr']) {
                            relocateNodes.map((relocateNode) => {
                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {
                                    relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {
                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                                    }
                                }
                            });
                        }
                    }
                    else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {
                        // so far this element does not have a slot home, not setting slotRefNode on purpose
                        // if we never find a home for this element then we'll need to hide it
                        relocateNodes.push({
                            $nodeToRelocate$: node,
                        });
                    }
                }
            }
        }
        if (childNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {
            relocateSlotContent(childNode);
        }
    }
};
const isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {
    if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {
        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {
            return true;
        }
        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {
            return true;
        }
        return false;
    }
    if (nodeToRelocate['s-sn'] === slotNameAttr) {
        return true;
    }
    return slotNameAttr === '';
};
const callNodeRefs = (vNode) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRef) {
        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
        vNode.$children$ && vNode.$children$.map(callNodeRefs);
    }
};
/**
 * The main entry point for Stencil's virtual DOM-based rendering engine
 *
 * Given a {@link d.HostRef} container and some virtual DOM nodes, this
 * function will handle creating a virtual DOM tree with a single root, patching
 * the current virtual DOM tree onto an old one (if any), dealing with slot
 * relocation, and reflecting attributes.
 *
 * @param hostRef data needed to root and render the virtual DOM tree, such as
 * the DOM node into which it should be rendered.
 * @param renderFnResults the virtual DOM nodes to be rendered
 */
const renderVdom = (hostRef, renderFnResults) => {
    const hostElm = hostRef.$hostElement$;
    const cmpMeta = hostRef.$cmpMeta$;
    const oldVNode = hostRef.$vnode$ || newVNode(null, null);
    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
    hostTagName = hostElm.tagName;
    // <Host> runtime check
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {
        throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${hostTagName.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect && cmpMeta.$attrsToReflect$) {
        rootVnode.$attrs$ = rootVnode.$attrs$ || {};
        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));
    }
    rootVnode.$tag$ = null;
    rootVnode.$flags$ |= 4 /* VNODE_FLAGS.isHost */;
    hostRef.$vnode$ = rootVnode;
    rootVnode.$elm$ = oldVNode.$elm$ = (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom) {
        scopeId = hostElm['s-sc'];
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
        contentRef = hostElm['s-cr'];
        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) !== 0;
        // always reset
        checkSlotFallbackVisibility = false;
    }
    // synchronous patch
    patch(oldVNode, rootVnode);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
        // while we're moving nodes around existing nodes, temporarily disable
        // the disconnectCallback from working
        plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;
        if (checkSlotRelocate) {
            relocateSlotContent(rootVnode.$elm$);
            let relocateData;
            let nodeToRelocate;
            let orgLocationNode;
            let parentNodeRef;
            let insertBeforeNode;
            let refNode;
            let i = 0;
            for (; i < relocateNodes.length; i++) {
                relocateData = relocateNodes[i];
                nodeToRelocate = relocateData.$nodeToRelocate$;
                if (!nodeToRelocate['s-ol']) {
                    // add a reference node marking this node's original location
                    // keep a reference to this node for later lookups
                    orgLocationNode =
                        _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide
                            ? originalLocationDebugNode(nodeToRelocate)
                            : doc.createTextNode('');
                    orgLocationNode['s-nr'] = nodeToRelocate;
                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);
                }
            }
            for (i = 0; i < relocateNodes.length; i++) {
                relocateData = relocateNodes[i];
                nodeToRelocate = relocateData.$nodeToRelocate$;
                if (relocateData.$slotRefNode$) {
                    // by default we're just going to insert it directly
                    // after the slot reference node
                    parentNodeRef = relocateData.$slotRefNode$.parentNode;
                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;
                    orgLocationNode = nodeToRelocate['s-ol'];
                    while ((orgLocationNode = orgLocationNode.previousSibling)) {
                        refNode = orgLocationNode['s-nr'];
                        if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {
                            refNode = refNode.nextSibling;
                            if (!refNode || !refNode['s-nr']) {
                                insertBeforeNode = refNode;
                                break;
                            }
                        }
                    }
                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) ||
                        nodeToRelocate.nextSibling !== insertBeforeNode) {
                        // we've checked that it's worth while to relocate
                        // since that the node to relocate
                        // has a different next sibling or parent relocated
                        if (nodeToRelocate !== insertBeforeNode) {
                            if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {
                                // probably a component in the index.html that doesn't have it's hostname set
                                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;
                            }
                            // add it back to the dom but in its new home
                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
                        }
                    }
                }
                else {
                    // this node doesn't have a slot home to go to, so let's hide it
                    if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {
                        nodeToRelocate.hidden = true;
                    }
                }
            }
        }
        if (checkSlotFallbackVisibility) {
            updateFallbackSlotVisibility(rootVnode.$elm$);
        }
        // done moving nodes around
        // allow the disconnect callback to work again
        plt.$flags$ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;
        // always reset
        relocateNodes.length = 0;
    }
};
// slot comment debug nodes only created with the `--debug` flag
// otherwise these nodes are text nodes w/out content
const slotReferenceDebugNode = (slotVNode) => doc.createComment(`<slot${slotVNode.$name$ ? ' name="' + slotVNode.$name$ + '"' : ''}> (host=${hostTagName.toLowerCase()})`);
const originalLocationDebugNode = (nodeToRelocate) => doc.createComment(`org-location for ` +
    (nodeToRelocate.localName
        ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})`
        : `[${nodeToRelocate.textContent}]`));
const attachToAncestor = (hostRef, ancestorComponent) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));
    }
};
const scheduleUpdate = (hostRef, isInitialLoad) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {
        hostRef.$flags$ |= 16 /* HOST_FLAGS.isQueuedForUpdate */;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && hostRef.$flags$ & 4 /* HOST_FLAGS.isWaitingForChildren */) {
        hostRef.$flags$ |= 512 /* HOST_FLAGS.needsRerender */;
        return;
    }
    attachToAncestor(hostRef, hostRef.$ancestorComponent$);
    // there is no ancestor component or the ancestor component
    // has already fired off its lifecycle update then
    // fire off the initial update
    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
    return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue ? writeTask(dispatch) : dispatch();
};
const dispatchHooks = (hostRef, isInitialLoad) => {
    const elm = hostRef.$hostElement$;
    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
    const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    let promise;
    if (isInitialLoad) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {
            hostRef.$flags$ |= 256 /* HOST_FLAGS.isListenReady */;
            if (hostRef.$queuedListeners$) {
                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));
                hostRef.$queuedListeners$ = null;
            }
        }
        emitLifecycleEvent(elm, 'componentWillLoad');
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillLoad) {
            promise = safeCall(instance, 'componentWillLoad');
        }
    }
    else {
        emitLifecycleEvent(elm, 'componentWillUpdate');
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillUpdate) {
            promise = safeCall(instance, 'componentWillUpdate');
        }
    }
    emitLifecycleEvent(elm, 'componentWillRender');
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillRender) {
        promise = then(promise, () => safeCall(instance, 'componentWillRender'));
    }
    endSchedule();
    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));
};
const updateComponent = async (hostRef, instance, isInitialLoad) => {
    // updateComponent
    const elm = hostRef.$hostElement$;
    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
    const rc = elm['s-rc'];
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style && isInitialLoad) {
        // DOM WRITE!
        attachStyles(hostRef);
    }
    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
        hostRef.$flags$ |= 1024 /* HOST_FLAGS.devOnRender */;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide) {
        await callRender(hostRef, instance, elm);
    }
    else {
        callRender(hostRef, instance, elm);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim && plt.$cssShim$) {
        plt.$cssShim$.updateHost(elm);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
        hostRef.$renderCount$++;
        hostRef.$flags$ &= ~1024 /* HOST_FLAGS.devOnRender */;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide) {
        try {
            // manually connected child components during server-side hydrate
            serverSideConnected(elm);
            if (isInitialLoad) {
                // using only during server-side hydrate
                if (hostRef.$cmpMeta$.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
                    elm['s-en'] = '';
                }
                else if (hostRef.$cmpMeta$.$flags$ & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {
                    elm['s-en'] = 'c';
                }
            }
        }
        catch (e) {
            consoleError(e, elm);
        }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && rc) {
        // ok, so turns out there are some child host elements
        // waiting on this parent element to load
        // let's fire off all update callbacks waiting
        rc.map((cb) => cb());
        elm['s-rc'] = undefined;
    }
    endRender();
    endUpdate();
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {
        const childrenPromises = elm['s-p'];
        const postUpdate = () => postUpdateComponent(hostRef);
        if (childrenPromises.length === 0) {
            postUpdate();
        }
        else {
            Promise.all(childrenPromises).then(postUpdate);
            hostRef.$flags$ |= 4 /* HOST_FLAGS.isWaitingForChildren */;
            childrenPromises.length = 0;
        }
    }
    else {
        postUpdateComponent(hostRef);
    }
};
const callRender = (hostRef, instance, elm) => {
    // in order for bundlers to correctly treeshake the BUILD object
    // we need to ensure BUILD is not deoptimized within a try/catch
    // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization
    const allRenderFn = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.allRenderFn ? true : false;
    const lazyLoad = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? true : false;
    const taskQueue = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue ? true : false;
    const updatable = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable ? true : false;
    try {
        renderingRef = instance;
        instance = allRenderFn ? instance.render() : instance.render && instance.render();
        if (updatable && taskQueue) {
            hostRef.$flags$ &= ~16 /* HOST_FLAGS.isQueuedForUpdate */;
        }
        if (updatable || lazyLoad) {
            hostRef.$flags$ |= 2 /* HOST_FLAGS.hasRendered */;
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hasRenderFn || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRender || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {
                // looks like we've got child nodes to render into this host element
                // or we need to update the css class/attrs on the host element
                // DOM WRITE!
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide) {
                    return Promise.resolve(instance).then((value) => renderVdom(hostRef, value));
                }
                else {
                    renderVdom(hostRef, instance);
                }
            }
            else {
                elm.textContent = instance;
            }
        }
    }
    catch (e) {
        consoleError(e, hostRef.$hostElement$);
    }
    renderingRef = null;
    return null;
};
const getRenderingRef = () => renderingRef;
const postUpdateComponent = (hostRef) => {
    const tagName = hostRef.$cmpMeta$.$tagName$;
    const elm = hostRef.$hostElement$;
    const endPostUpdate = createTime('postUpdate', tagName);
    const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    const ancestorComponent = hostRef.$ancestorComponent$;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidRender) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
            hostRef.$flags$ |= 1024 /* HOST_FLAGS.devOnRender */;
        }
        safeCall(instance, 'componentDidRender');
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
            hostRef.$flags$ &= ~1024 /* HOST_FLAGS.devOnRender */;
        }
    }
    emitLifecycleEvent(elm, 'componentDidRender');
    if (!(hostRef.$flags$ & 64 /* HOST_FLAGS.hasLoadedComponent */)) {
        hostRef.$flags$ |= 64 /* HOST_FLAGS.hasLoadedComponent */;
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations) {
            // DOM WRITE!
            addHydratedFlag(elm);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidLoad) {
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
                hostRef.$flags$ |= 2048 /* HOST_FLAGS.devOnDidLoad */;
            }
            safeCall(instance, 'componentDidLoad');
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
                hostRef.$flags$ &= ~2048 /* HOST_FLAGS.devOnDidLoad */;
            }
        }
        emitLifecycleEvent(elm, 'componentDidLoad');
        endPostUpdate();
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {
            hostRef.$onReadyResolve$(elm);
            if (!ancestorComponent) {
                appDidLoad(tagName);
            }
        }
    }
    else {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidUpdate) {
            // we've already loaded this component
            // fire off the user's componentDidUpdate method (if one was provided)
            // componentDidUpdate runs AFTER render() has been called
            // and all child components have finished updating
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
                hostRef.$flags$ |= 1024 /* HOST_FLAGS.devOnRender */;
            }
            safeCall(instance, 'componentDidUpdate');
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
                hostRef.$flags$ &= ~1024 /* HOST_FLAGS.devOnRender */;
            }
        }
        emitLifecycleEvent(elm, 'componentDidUpdate');
        endPostUpdate();
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {
        elm['s-hmr-load'] && elm['s-hmr-load']();
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {
        hostRef.$onInstanceResolve$(elm);
    }
    // load events fire from bottom to top
    // the deepest elements load first then bubbles up
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {
        if (hostRef.$onRenderResolve$) {
            hostRef.$onRenderResolve$();
            hostRef.$onRenderResolve$ = undefined;
        }
        if (hostRef.$flags$ & 512 /* HOST_FLAGS.needsRerender */) {
            nextTick(() => scheduleUpdate(hostRef, false));
        }
        hostRef.$flags$ &= ~(4 /* HOST_FLAGS.isWaitingForChildren */ | 512 /* HOST_FLAGS.needsRerender */);
    }
    // ( _)
    // ( _)>-
    // (_)
};
const forceUpdate = (ref) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {
        const hostRef = getHostRef(ref);
        const isConnected = hostRef.$hostElement$.isConnected;
        if (isConnected &&
            (hostRef.$flags$ & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
            scheduleUpdate(hostRef, false);
        }
        // Returns "true" when the forced update was successfully scheduled
        return isConnected;
    }
    return false;
};
const appDidLoad = (who) => {
    // on appload
    // we have finish the first big initial render
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations) {
        addHydratedFlag(doc.documentElement);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {
        plt.$flags$ |= 2 /* PLATFORM_FLAGS.appLoaded */;
    }
    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE } }));
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.measure) {
        performance.measure(`[Stencil] ${_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE} initial load (by ${who})`, 'st:app:start');
    }
};
const safeCall = (instance, method, arg) => {
    if (instance && instance[method]) {
        try {
            return instance[method](arg);
        }
        catch (e) {
            consoleError(e);
        }
    }
    return undefined;
};
const then = (promise, thenFn) => {
    return promise && promise.then ? promise.then(thenFn) : thenFn();
};
const emitLifecycleEvent = (elm, lifecycleName) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lifecycleDOMEvents) {
        emitEvent(elm, 'stencil_' + lifecycleName, {
            bubbles: true,
            composed: true,
            detail: {
                namespace: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE,
            },
        });
    }
};
const addHydratedFlag = (elm) => _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedClass
    ? elm.classList.add('hydrated')
    : _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedAttribute
        ? elm.setAttribute('hydrated', '')
        : undefined;
const serverSideConnected = (elm) => {
    const children = elm.children;
    if (children != null) {
        for (let i = 0, ii = children.length; i < ii; i++) {
            const childElm = children[i];
            if (typeof childElm.connectedCallback === 'function') {
                childElm.connectedCallback();
            }
            serverSideConnected(childElm);
        }
    }
};
const getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
const setValue = (ref, propName, newVal, cmpMeta) => {
    // check our new property value against our internal value
    const hostRef = getHostRef(ref);
    const elm = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$hostElement$ : ref;
    const oldVal = hostRef.$instanceValues$.get(propName);
    const flags = hostRef.$flags$;
    const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
    // explicitly check for NaN on both sides, as `NaN === NaN` is always false
    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
    const didValueChange = newVal !== oldVal && !areBothNaN;
    if ((!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || !(flags & 8 /* HOST_FLAGS.isConstructingInstance */) || oldVal === undefined) && didValueChange) {
        // gadzooks! the property's value has changed!!
        // set our new value!
        hostRef.$instanceValues$.set(propName, newVal);
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
            if (hostRef.$flags$ & 1024 /* HOST_FLAGS.devOnRender */) {
                consoleDevWarn(`The state/prop "${propName}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, '\nElement', elm, '\nNew value', newVal, '\nOld value', oldVal);
            }
            else if (hostRef.$flags$ & 2048 /* HOST_FLAGS.devOnDidLoad */) {
                consoleDevWarn(`The state/prop "${propName}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`, '\nElement', elm, '\nNew value', newVal, '\nOld value', oldVal);
            }
        }
        if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || instance) {
            // get an array of method names of watch functions to call
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* HOST_FLAGS.isWatchReady */) {
                const watchMethods = cmpMeta.$watchers$[propName];
                if (watchMethods) {
                    // this instance is watching for when this property changed
                    watchMethods.map((watchMethodName) => {
                        try {
                            // fire off each of the watch methods that are watching this property
                            instance[watchMethodName](newVal, oldVal, propName);
                        }
                        catch (e) {
                            consoleError(e, elm);
                        }
                    });
                }
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable &&
                (flags & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {
                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
                        return;
                    }
                }
                // looks like this value actually changed, so we've got work to do!
                // but only if we've already rendered, otherwise just chill out
                // queue that we need to do an update, but don't worry about queuing
                // up millions cuz this function ensures it only runs once
                scheduleUpdate(hostRef, false);
            }
        }
    }
};
/**
 * Attach a series of runtime constructs to a compiled Stencil component
 * constructor, including getters and setters for the `@Prop` and `@State`
 * decorators, callbacks for when attributes change, and so on.
 *
 * @param Cstr the constructor for a component that we need to process
 * @param cmpMeta metadata collected previously about the component
 * @param flags a number used to store a series of bit flags
 * @returns a reference to the same constructor passed in (but now mutated)
 */
const proxyComponent = (Cstr, cmpMeta, flags) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member && cmpMeta.$members$) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback && Cstr.watchers) {
            cmpMeta.$watchers$ = Cstr.watchers;
        }
        // It's better to have a const than two Object.entries()
        const members = Object.entries(cmpMeta.$members$);
        const prototype = Cstr.prototype;
        members.map(([memberName, [memberFlags]]) => {
            if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.prop || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.state) &&
                (memberFlags & 31 /* MEMBER_FLAGS.Prop */ ||
                    ((!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || flags & 2 /* PROXY_FLAGS.proxyState */) && memberFlags & 32 /* MEMBER_FLAGS.State */))) {
                // proxyComponent - prop
                Object.defineProperty(prototype, memberName, {
                    get() {
                        // proxyComponent, get value
                        return getValue(this, memberName);
                    },
                    set(newValue) {
                        // only during dev time
                        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
                            const ref = getHostRef(this);
                            if (
                            // we are proxying the instance (not element)
                            (flags & 1 /* PROXY_FLAGS.isElementConstructor */) === 0 &&
                                // the element is not constructing
                                (ref.$flags$ & 8 /* HOST_FLAGS.isConstructingInstance */) === 0 &&
                                // the member is a prop
                                (memberFlags & 31 /* MEMBER_FLAGS.Prop */) !== 0 &&
                                // the member is not mutable
                                (memberFlags & 1024 /* MEMBER_FLAGS.Mutable */) === 0) {
                                consoleDevWarn(`@Prop() "${memberName}" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);
                            }
                        }
                        // proxyComponent, set value
                        setValue(this, memberName, newValue, cmpMeta);
                    },
                    configurable: true,
                    enumerable: true,
                });
            }
            else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad &&
                _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method &&
                flags & 1 /* PROXY_FLAGS.isElementConstructor */ &&
                memberFlags & 64 /* MEMBER_FLAGS.Method */) {
                // proxyComponent - method
                Object.defineProperty(prototype, memberName, {
                    value(...args) {
                        const ref = getHostRef(this);
                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));
                    },
                });
            }
        });
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.observeAttribute && (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || flags & 1 /* PROXY_FLAGS.isElementConstructor */)) {
            const attrNameToPropName = new Map();
            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {
                plt.jmp(() => {
                    const propName = attrNameToPropName.get(attrName);
                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
                    //  in the case where an attribute was set inline.
                    //  ```html
                    //    <my-component some-attribute="some-value"></my-component>
                    //  ```
                    //
                    //  There is an edge case where a developer sets the attribute inline on a custom element and then
                    //  programmatically changes it before it has been upgraded as shown below:
                    //
                    //  ```html
                    //    <!-- this component has _not_ been upgraded yet -->
                    //    <my-component id="test" some-attribute="some-value"></my-component>
                    //    <script>
                    //      // grab non-upgraded component
                    //      el = document.querySelector("#test");
                    //      el.someAttribute = "another-value";
                    //      // upgrade component
                    //      customElements.define('my-component', MyComponent);
                    //    </script>
                    //  ```
                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback
                    //  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
                    //  to the value that was set inline i.e. "some-value" from above example. When
                    //  the connectedCallback attempts to unshadow it will use "some-value" as the initial value rather than "another-value"
                    //
                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed
                    //  by connectedCallback as this attributeChangedCallback will not fire.
                    //
                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
                    //
                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
                    //  properties here given that this goes against best practices outlined here
                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy
                    if (this.hasOwnProperty(propName)) {
                        newValue = this[propName];
                        delete this[propName];
                    }
                    else if (prototype.hasOwnProperty(propName) &&
                        typeof this[propName] === 'number' &&
                        this[propName] == newValue) {
                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
                        return;
                    }
                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;
                });
            };
            // create an array of attributes to observe
            // and also create a map of html attribute name to js property name
            Cstr.observedAttributes = members
                .filter(([_, m]) => m[0] & 15 /* MEMBER_FLAGS.HasAttribute */) // filter to only keep props that should match attributes
                .map(([propName, m]) => {
                const attrName = m[1] || propName;
                attrNameToPropName.set(attrName, propName);
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect && m[0] & 512 /* MEMBER_FLAGS.ReflectAttr */) {
                    cmpMeta.$attrsToReflect$.push([propName, attrName]);
                }
                return attrName;
            });
        }
    }
    return Cstr;
};
const initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
    // initializeComponent
    if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style) &&
        (hostRef.$flags$ & 32 /* HOST_FLAGS.hasInitializedComponent */) === 0) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide) {
            // we haven't initialized this element yet
            hostRef.$flags$ |= 32 /* HOST_FLAGS.hasInitializedComponent */;
            // lazy loaded components
            // request the component's implementation to be
            // wired up with the host element
            Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);
            if (Cstr.then) {
                // Await creates a micro-task avoid if possible
                const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);
                Cstr = await Cstr;
                endLoad();
            }
            if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug) && !Cstr) {
                throw new Error(`Constructor for "${cmpMeta.$tagName$}#${hostRef.$modeName$}" was not found`);
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member && !Cstr.isProxied) {
                // we've never proxied this Constructor before
                // let's add the getters/setters to its prototype before
                // the first time we create an instance of the implementation
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {
                    cmpMeta.$watchers$ = Cstr.watchers;
                }
                proxyComponent(Cstr, cmpMeta, 2 /* PROXY_FLAGS.proxyState */);
                Cstr.isProxied = true;
            }
            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);
            // ok, time to construct the instance
            // but let's keep track of when we start and stop
            // so that the getters/setters don't incorrectly step on data
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {
                hostRef.$flags$ |= 8 /* HOST_FLAGS.isConstructingInstance */;
            }
            // construct the lazy-loaded component implementation
            // passing the hostRef is very important during
            // construction in order to directly wire together the
            // host element and the lazy-loaded instance
            try {
                new Cstr(hostRef);
            }
            catch (e) {
                consoleError(e);
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {
                hostRef.$flags$ &= ~8 /* HOST_FLAGS.isConstructingInstance */;
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {
                hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */;
            }
            endNewInstance();
            fireConnectedCallback(hostRef.$lazyInstance$);
        }
        else {
            // sync constructor component
            Cstr = elm.constructor;
            hostRef.$flags$ |= 32 /* HOST_FLAGS.hasInitializedComponent */;
            // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,
            // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_
            // Stencil has completed instantiating the component.
            customElements.whenDefined(cmpMeta.$tagName$).then(() => (hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */));
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style && Cstr.style) {
            // this component has styles but we haven't registered them yet
            let style = Cstr.style;
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode && typeof style !== 'string') {
                style = style[(hostRef.$modeName$ = computeMode(elm))];
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && hostRef.$modeName$) {
                    elm.setAttribute('s-mode', hostRef.$modeName$);
                }
            }
            const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);
            if (!styles.has(scopeId)) {
                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);
                if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide &&
                    _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom &&
                    _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDomShim &&
                    cmpMeta.$flags$ & 8 /* CMP_FLAGS.needsShadowDomShim */) {
                    style = await __webpack_require__.e(/*! import() */ "vendors-node_modules_stencil_core_internal_client_shadow-css_js").then(__webpack_require__.bind(__webpack_require__, /*! ./shadow-css.js */ "./node_modules/@stencil/core/internal/client/shadow-css.js")).then((m) => m.scopeCss(style, scopeId, false));
                }
                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */));
                endRegisterStyles();
            }
        }
    }
    // we've successfully created a lazy instance
    const ancestorComponent = hostRef.$ancestorComponent$;
    const schedule = () => scheduleUpdate(hostRef, true);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && ancestorComponent && ancestorComponent['s-rc']) {
        // this is the initial load and this component it has an ancestor component
        // but the ancestor component has NOT fired its will update lifecycle yet
        // so let's just cool our jets and wait for the ancestor to continue first
        // this will get fired off when the ancestor component
        // finally gets around to rendering its lazy self
        // fire off the initial update
        ancestorComponent['s-rc'].push(schedule);
    }
    else {
        schedule();
    }
};
const fireConnectedCallback = (instance) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.connectedCallback) {
        safeCall(instance, 'connectedCallback');
    }
};
const connectedCallback = (elm) => {
    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
        const hostRef = getHostRef(elm);
        const cmpMeta = hostRef.$cmpMeta$;
        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent) {
            // only run if we have listeners being attached to a parent
            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);
        }
        if (!(hostRef.$flags$ & 1 /* HOST_FLAGS.hasConnected */)) {
            // first time this component has connected
            hostRef.$flags$ |= 1 /* HOST_FLAGS.hasConnected */;
            let hostId;
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide) {
                hostId = elm.getAttribute(HYDRATE_ID);
                if (hostId) {
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
                        const scopeId = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode
                            ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode'))
                            : addStyle(elm.shadowRoot, cmpMeta);
                        elm.classList.remove(scopeId + '-h', scopeId + '-s');
                    }
                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);
                }
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && !hostId) {
                // initUpdate
                // if the slot polyfill is required we'll need to put some nodes
                // in here to act as original content anchors as we move nodes around
                // host element has been connected to the DOM
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ||
                    ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom) &&
                        cmpMeta.$flags$ & (4 /* CMP_FLAGS.hasSlotRelocation */ | 8 /* CMP_FLAGS.needsShadowDomShim */))) {
                    setContentReference(elm);
                }
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {
                // find the first ancestor component (if there is one) and register
                // this component as one of the actively loading child components for its ancestor
                let ancestorComponent = elm;
                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {
                    // climb up the ancestors looking for the first
                    // component that hasn't finished its lifecycle update yet
                    if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide &&
                        ancestorComponent.nodeType === 1 /* NODE_TYPE.ElementNode */ &&
                        ancestorComponent.hasAttribute('s-id') &&
                        ancestorComponent['s-p']) ||
                        ancestorComponent['s-p']) {
                        // we found this components first ancestor component
                        // keep a reference to this component's ancestor component
                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));
                        break;
                    }
                }
            }
            // Lazy properties
            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.prop && !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && cmpMeta.$members$) {
                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
                    if (memberFlags & 31 /* MEMBER_FLAGS.Prop */ && elm.hasOwnProperty(memberName)) {
                        const value = elm[memberName];
                        delete elm[memberName];
                        elm[memberName] = value;
                    }
                });
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.initializeNextTick) {
                // connectedCallback, taskQueue, initialLoad
                // angular sets attribute AFTER connectCallback
                // https://github.com/angular/angular/issues/18909
                // https://github.com/angular/angular/issues/19940
                nextTick(() => initializeComponent(elm, hostRef, cmpMeta));
            }
            else {
                initializeComponent(elm, hostRef, cmpMeta);
            }
        }
        else {
            // not the first time this has connected
            // reattach any event listeners to the host
            // since they would have been removed when disconnected
            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
            // fire off connectedCallback() on component instance
            fireConnectedCallback(hostRef.$lazyInstance$);
        }
        endConnected();
    }
};
const setContentReference = (elm) => {
    // only required when we're NOT using native shadow dom (slot)
    // or this browser doesn't support native shadow dom
    // and this host element was NOT created with SSR
    // let's pick out the inner content for slot projection
    // create a node to represent where the original
    // content was first placed, which is useful later on
    const contentRefElm = (elm['s-cr'] = doc.createComment(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug ? `content-ref (host=${elm.localName})` : ''));
    contentRefElm['s-cn'] = true;
    elm.insertBefore(contentRefElm, elm.firstChild);
};
const disconnectedCallback = (elm) => {
    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
        const hostRef = getHostRef(elm);
        const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {
            if (hostRef.$rmListeners$) {
                hostRef.$rmListeners$.map((rmListener) => rmListener());
                hostRef.$rmListeners$ = undefined;
            }
        }
        // clear CSS var-shim tracking
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim && plt.$cssShim$) {
            plt.$cssShim$.removeHost(elm);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.disconnectedCallback) {
            safeCall(instance, 'disconnectedCallback');
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidUnload) {
            safeCall(instance, 'componentDidUnload');
        }
    }
};
const defineCustomElement = (Cstr, compactMeta) => {
    customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));
};
const proxyCustomElement = (Cstr, compactMeta) => {
    const cmpMeta = {
        $flags$: compactMeta[0],
        $tagName$: compactMeta[1],
    };
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {
        cmpMeta.$members$ = compactMeta[2];
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {
        cmpMeta.$listeners$ = compactMeta[3];
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {
        cmpMeta.$watchers$ = Cstr.$watchers$;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {
        cmpMeta.$attrsToReflect$ = [];
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
        cmpMeta.$flags$ |= 8 /* CMP_FLAGS.needsShadowDomShim */;
    }
    const originalConnectedCallback = Cstr.prototype.connectedCallback;
    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
    Object.assign(Cstr.prototype, {
        __registerHost() {
            registerHost(this, cmpMeta);
        },
        connectedCallback() {
            connectedCallback(this);
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.connectedCallback && originalConnectedCallback) {
                originalConnectedCallback.call(this);
            }
        },
        disconnectedCallback() {
            disconnectedCallback(this);
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.disconnectedCallback && originalDisconnectedCallback) {
                originalDisconnectedCallback.call(this);
            }
        },
        __attachShadow() {
            if (supportsShadow) {
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDelegatesFocus) {
                    this.attachShadow({
                        mode: 'open',
                        delegatesFocus: !!(cmpMeta.$flags$ & 16 /* CMP_FLAGS.shadowDelegatesFocus */),
                    });
                }
                else {
                    this.attachShadow({ mode: 'open' });
                }
            }
            else {
                this.shadowRoot = this;
            }
        },
    });
    Cstr.is = cmpMeta.$tagName$;
    return proxyComponent(Cstr, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */ | 2 /* PROXY_FLAGS.proxyState */);
};
const forceModeUpdate = (elm) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode && !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {
        const mode = computeMode(elm);
        const hostRef = getHostRef(elm);
        if (hostRef.$modeName$ !== mode) {
            const cmpMeta = hostRef.$cmpMeta$;
            const oldScopeId = elm['s-sc'];
            const scopeId = getScopeId(cmpMeta, mode);
            const style = elm.constructor.style[mode];
            const flags = cmpMeta.$flags$;
            if (style) {
                if (!styles.has(scopeId)) {
                    registerStyle(scopeId, style, !!(flags & 1 /* CMP_FLAGS.shadowDomEncapsulation */));
                }
                hostRef.$modeName$ = mode;
                elm.classList.remove(oldScopeId + '-h', oldScopeId + '-s');
                attachStyles(hostRef);
                forceUpdate(elm);
            }
        }
    }
};
const patchCloneNode = (HostElementPrototype) => {
    const orgCloneNode = HostElementPrototype.cloneNode;
    HostElementPrototype.cloneNode = function (deep) {
        const srcNode = this;
        const isShadowDom = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;
        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot && !isShadowDom && deep) {
            let i = 0;
            let slotted, nonStencilNode;
            const stencilPrivates = [
                's-id',
                's-cr',
                's-lr',
                's-rc',
                's-sc',
                's-p',
                's-cn',
                's-sr',
                's-sn',
                's-hn',
                's-ol',
                's-nr',
                's-si',
            ];
            for (; i < srcNode.childNodes.length; i++) {
                slotted = srcNode.childNodes[i]['s-nr'];
                nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i][privateField]);
                if (slotted) {
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.appendChildSlotFix && clonedNode.__appendChild) {
                        clonedNode.__appendChild(slotted.cloneNode(true));
                    }
                    else {
                        clonedNode.appendChild(slotted.cloneNode(true));
                    }
                }
                if (nonStencilNode) {
                    clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));
                }
            }
        }
        return clonedNode;
    };
};
const patchSlotAppendChild = (HostElementPrototype) => {
    HostElementPrototype.__appendChild = HostElementPrototype.appendChild;
    HostElementPrototype.appendChild = function (newChild) {
        const slotName = (newChild['s-sn'] = getSlotName(newChild));
        const slotNode = getHostSlotNode(this.childNodes, slotName);
        if (slotNode) {
            const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);
            const appendAfter = slotChildNodes[slotChildNodes.length - 1];
            return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);
        }
        return this.__appendChild(newChild);
    };
};
/**
 * Patches the text content of an unnamed slotted node inside a scoped component
 * @param hostElementPrototype the `Element` to be patched
 * @param cmpMeta component runtime metadata used to determine if the component should be patched or not
 */
const patchTextContent = (hostElementPrototype, cmpMeta) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped && cmpMeta.$flags$ & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {
        const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent');
        Object.defineProperty(hostElementPrototype, '__textContent', descriptor);
        Object.defineProperty(hostElementPrototype, 'textContent', {
            get() {
                var _a;
                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is
                // the empty string
                const slotNode = getHostSlotNode(this.childNodes, '');
                // when a slot node is found, the textContent _may_ be found in the next sibling (text) node, depending on how
                // nodes were reordered during the vdom render. first try to get the text content from the sibling.
                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* NODE_TYPES.TEXT_NODE */) {
                    return slotNode.nextSibling.textContent;
                }
                else if (slotNode) {
                    return slotNode.textContent;
                }
                else {
                    // fallback to the original implementation
                    return this.__textContent;
                }
            },
            set(value) {
                var _a;
                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is
                // the empty string
                const slotNode = getHostSlotNode(this.childNodes, '');
                // when a slot node is found, the textContent _may_ need to be placed in the next sibling (text) node,
                // depending on how nodes were reordered during the vdom render. first try to set the text content on the
                // sibling.
                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* NODE_TYPES.TEXT_NODE */) {
                    slotNode.nextSibling.textContent = value;
                }
                else if (slotNode) {
                    slotNode.textContent = value;
                }
                else {
                    // we couldn't find a slot, but that doesn't mean that there isn't one. if this check ran before the DOM
                    // loaded, we could have missed it. check for a content reference element on the scoped component and insert
                    // it there
                    this.__textContent = value;
                    const contentRefElm = this['s-cr'];
                    if (contentRefElm) {
                        this.insertBefore(contentRefElm, this.firstChild);
                    }
                }
            },
        });
    }
};
const patchChildSlotNodes = (elm, cmpMeta) => {
    class FakeNodeList extends Array {
        item(n) {
            return this[n];
        }
    }
    if (cmpMeta.$flags$ & 8 /* CMP_FLAGS.needsShadowDomShim */) {
        const childNodesFn = elm.__lookupGetter__('childNodes');
        Object.defineProperty(elm, 'children', {
            get() {
                return this.childNodes.map((n) => n.nodeType === 1);
            },
        });
        Object.defineProperty(elm, 'childElementCount', {
            get() {
                return elm.children.length;
            },
        });
        Object.defineProperty(elm, 'childNodes', {
            get() {
                const childNodes = childNodesFn.call(this);
                if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0 &&
                    getHostRef(this).$flags$ & 2 /* HOST_FLAGS.hasRendered */) {
                    const result = new FakeNodeList();
                    for (let i = 0; i < childNodes.length; i++) {
                        const slot = childNodes[i]['s-nr'];
                        if (slot) {
                            result.push(slot);
                        }
                    }
                    return result;
                }
                return FakeNodeList.from(childNodes);
            },
        });
    }
};
const getSlotName = (node) => node['s-sn'] || (node.nodeType === 1 && node.getAttribute('slot')) || '';
/**
 * Recursively searches a series of child nodes for a slot with the provided name.
 * @param childNodes the nodes to search for a slot with a specific name.
 * @param slotName the name of the slot to match on.
 * @returns a reference to the slot node that matches the provided name, `null` otherwise
 */
const getHostSlotNode = (childNodes, slotName) => {
    let i = 0;
    let childNode;
    for (; i < childNodes.length; i++) {
        childNode = childNodes[i];
        if (childNode['s-sr'] && childNode['s-sn'] === slotName) {
            return childNode;
        }
        childNode = getHostSlotNode(childNode.childNodes, slotName);
        if (childNode) {
            return childNode;
        }
    }
    return null;
};
const getHostSlotChildNodes = (n, slotName) => {
    const childNodes = [n];
    while ((n = n.nextSibling) && n['s-sn'] === slotName) {
        childNodes.push(n);
    }
    return childNodes;
};
const hmrStart = (elm, cmpMeta, hmrVersionId) => {
    // \_()_/
    const hostRef = getHostRef(elm);
    // reset state flags to only have been connected
    hostRef.$flags$ = 1 /* HOST_FLAGS.hasConnected */;
    // TODO
    // detatch any event listeners that may have been added
    // because we're not passing an exact event name it'll
    // remove all of this element's event, which is good
    // create a callback for when this component finishes hmr
    elm['s-hmr-load'] = () => {
        // finished hmr for this element
        delete elm['s-hmr-load'];
    };
    // re-initialize the component
    initializeComponent(elm, hostRef, cmpMeta, hmrVersionId);
};
const bootstrapLazy = (lazyBundles, options = {}) => {
    var _a;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.mark) {
        performance.mark('st:app:start');
    }
    installDevTools();
    const endBootstrap = createTime('bootstrapLazy');
    const cmpTags = [];
    const exclude = options.exclude || [];
    const customElements = win.customElements;
    const head = doc.head;
    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');
    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');
    const deferredConnectedCallbacks = [];
    const styles = /*@__PURE__*/ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);
    let appLoadFallback;
    let isBootstrapping = true;
    let i = 0;
    Object.assign(plt, options);
    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {
        if (options.syncQueue) {
            plt.$flags$ |= 4 /* PLATFORM_FLAGS.queueSync */;
        }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide) {
        // If the app is already hydrated there is not point to disable the
        // async queue. This will improve the first input delay
        plt.$flags$ |= 2 /* PLATFORM_FLAGS.appLoaded */;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom) {
        for (; i < styles.length; i++) {
            registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);
        }
    }
    lazyBundles.map((lazyBundle) => {
        lazyBundle[1].map((compactMeta) => {
            const cmpMeta = {
                $flags$: compactMeta[0],
                $tagName$: compactMeta[1],
                $members$: compactMeta[2],
                $listeners$: compactMeta[3],
            };
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {
                cmpMeta.$members$ = compactMeta[2];
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {
                cmpMeta.$listeners$ = compactMeta[3];
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {
                cmpMeta.$attrsToReflect$ = [];
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {
                cmpMeta.$watchers$ = {};
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
                cmpMeta.$flags$ |= 8 /* CMP_FLAGS.needsShadowDomShim */;
            }
            const tagName = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.transformTagName && options.transformTagName
                ? options.transformTagName(cmpMeta.$tagName$)
                : cmpMeta.$tagName$;
            const HostElement = class extends HTMLElement {
                // StencilLazyHost
                constructor(self) {
                    // @ts-ignore
                    super(self);
                    self = this;
                    registerHost(self, cmpMeta);
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
                        // this component is using shadow dom
                        // and this browser supports shadow dom
                        // add the read-only property "shadowRoot" to the host element
                        // adding the shadow root build conditionals to minimize runtime
                        if (supportsShadow) {
                            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDelegatesFocus) {
                                self.attachShadow({
                                    mode: 'open',
                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* CMP_FLAGS.shadowDelegatesFocus */),
                                });
                            }
                            else {
                                self.attachShadow({ mode: 'open' });
                            }
                        }
                        else if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && !('shadowRoot' in self)) {
                            self.shadowRoot = self;
                        }
                    }
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotChildNodesFix) {
                        patchChildSlotNodes(self, cmpMeta);
                    }
                }
                connectedCallback() {
                    if (appLoadFallback) {
                        clearTimeout(appLoadFallback);
                        appLoadFallback = null;
                    }
                    if (isBootstrapping) {
                        // connectedCallback will be processed once all components have been registered
                        deferredConnectedCallbacks.push(this);
                    }
                    else {
                        plt.jmp(() => connectedCallback(this));
                    }
                }
                disconnectedCallback() {
                    plt.jmp(() => disconnectedCallback(this));
                }
                componentOnReady() {
                    return getHostRef(this).$onReadyPromise$;
                }
            };
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cloneNodeFix) {
                patchCloneNode(HostElement.prototype);
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.appendChildSlotFix) {
                patchSlotAppendChild(HostElement.prototype);
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {
                HostElement.prototype['s-hmr'] = function (hmrVersionId) {
                    hmrStart(this, cmpMeta, hmrVersionId);
                };
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scopedSlotTextContentFix) {
                patchTextContent(HostElement.prototype, cmpMeta);
            }
            cmpMeta.$lazyBundleId$ = lazyBundle[0];
            if (!exclude.includes(tagName) && !customElements.get(tagName)) {
                cmpTags.push(tagName);
                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */));
            }
        });
    });
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.invisiblePrehydration && (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedClass || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedAttribute)) {
        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;
        visibilityStyle.setAttribute('data-styles', '');
        // Apply CSP nonce to the style tag if it exists
        const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
        if (nonce != null) {
            visibilityStyle.setAttribute('nonce', nonce);
        }
        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);
    }
    // Process deferred connectedCallbacks now all components have been registered
    isBootstrapping = false;
    if (deferredConnectedCallbacks.length) {
        deferredConnectedCallbacks.map((host) => host.connectedCallback());
    }
    else {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile) {
            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30, 'timeout')));
        }
        else {
            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));
        }
    }
    // Fallback appLoad event
    endBootstrap();
};
const getConnect = (_ref, tagName) => {
    const componentOnReady = () => {
        let elm = doc.querySelector(tagName);
        if (!elm) {
            elm = doc.createElement(tagName);
            doc.body.appendChild(elm);
        }
        return typeof elm.componentOnReady === 'function' ? elm.componentOnReady() : Promise.resolve(elm);
    };
    const create = (...args) => {
        return componentOnReady().then((el) => el.create(...args));
    };
    return {
        create,
        componentOnReady,
    };
};
const getContext = (_elm, context) => {
    if (context in Context) {
        return Context[context];
    }
    else if (context === 'window') {
        return win;
    }
    else if (context === 'document') {
        return doc;
    }
    else if (context === 'isServer' || context === 'isPrerender') {
        return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? true : false;
    }
    else if (context === 'isClient') {
        return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? false : true;
    }
    else if (context === 'resourcesUrl' || context === 'publicPath') {
        return getAssetPath('.');
    }
    else if (context === 'queue') {
        return {
            write: writeTask,
            read: readTask,
            tick: {
                then(cb) {
                    return nextTick(cb);
                },
            },
        };
    }
    return undefined;
};
const Fragment = (_, children) => children;
const addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener && listeners) {
        // this is called immediately within the element's constructor
        // initialize our event listeners on the host element
        // we do this now so that we can listen to events that may
        // have fired even before the instance is ready
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent) {
            // this component may have event listeners that should be attached to the parent
            if (attachParentListeners) {
                // this is being ran from within the connectedCallback
                // which is important so that we know the host element actually has a parent element
                // filter out the listeners to only have the ones that ARE being attached to the parent
                listeners = listeners.filter(([flags]) => flags & 32 /* LISTENER_FLAGS.TargetParent */);
            }
            else {
                // this is being ran from within the component constructor
                // everything BUT the parent element listeners should be attached at this time
                // filter out the listeners that are NOT being attached to the parent
                listeners = listeners.filter(([flags]) => !(flags & 32 /* LISTENER_FLAGS.TargetParent */));
            }
        }
        listeners.map(([flags, name, method]) => {
            const target = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;
            const handler = hostListenerProxy(hostRef, method);
            const opts = hostListenerOpts(flags);
            plt.ael(target, name, handler, opts);
            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
        });
    }
};
const hostListenerProxy = (hostRef, methodName) => (ev) => {
    try {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {
            if (hostRef.$flags$ & 256 /* HOST_FLAGS.isListenReady */) {
                // instance is ready, let's call it's member method for this event
                hostRef.$lazyInstance$[methodName](ev);
            }
            else {
                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
            }
        }
        else {
            hostRef.$hostElement$[methodName](ev);
        }
    }
    catch (e) {
        consoleError(e);
    }
};
const getHostListenerTarget = (elm, flags) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetDocument && flags & 4 /* LISTENER_FLAGS.TargetDocument */)
        return doc;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetWindow && flags & 8 /* LISTENER_FLAGS.TargetWindow */)
        return win;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetBody && flags & 16 /* LISTENER_FLAGS.TargetBody */)
        return doc.body;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent && flags & 32 /* LISTENER_FLAGS.TargetParent */)
        return elm.parentElement;
    return elm;
};
// prettier-ignore
const hostListenerOpts = (flags) => supportsListenerOptions
    ? ({
        passive: (flags & 1 /* LISTENER_FLAGS.Passive */) !== 0,
        capture: (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0,
    })
    : (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0;
/**
 * Assigns the given value to the nonce property on the runtime platform object.
 * During runtime, this value is used to set the nonce attribute on all dynamically created script and style tags.
 * @param nonce The value to be assigned to the platform nonce property.
 * @returns void
 */
const setNonce = (nonce) => (plt.$nonce$ = nonce);
const setPlatformOptions = (opts) => Object.assign(plt, opts);
const insertVdomAnnotations = (doc, staticComponents) => {
    if (doc != null) {
        const docData = {
            hostIds: 0,
            rootLevelIds: 0,
            staticComponents: new Set(staticComponents),
        };
        const orgLocationNodes = [];
        parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);
        orgLocationNodes.forEach((orgLocationNode) => {
            if (orgLocationNode != null) {
                const nodeRef = orgLocationNode['s-nr'];
                let hostId = nodeRef['s-host-id'];
                let nodeId = nodeRef['s-node-id'];
                let childId = `${hostId}.${nodeId}`;
                if (hostId == null) {
                    hostId = 0;
                    docData.rootLevelIds++;
                    nodeId = docData.rootLevelIds;
                    childId = `${hostId}.${nodeId}`;
                    if (nodeRef.nodeType === 1 /* NODE_TYPE.ElementNode */) {
                        nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);
                    }
                    else if (nodeRef.nodeType === 3 /* NODE_TYPE.TextNode */) {
                        if (hostId === 0) {
                            const textContent = nodeRef.nodeValue.trim();
                            if (textContent === '') {
                                // useless whitespace node at the document root
                                orgLocationNode.remove();
                                return;
                            }
                        }
                        const commentBeforeTextNode = doc.createComment(childId);
                        commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;
                        nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);
                    }
                }
                let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;
                const orgLocationParentNode = orgLocationNode.parentElement;
                if (orgLocationParentNode) {
                    if (orgLocationParentNode['s-en'] === '') {
                        // ending with a "." means that the parent element
                        // of this node's original location is a SHADOW dom element
                        // and this node is apart of the root level light dom
                        orgLocationNodeId += `.`;
                    }
                    else if (orgLocationParentNode['s-en'] === 'c') {
                        // ending with a ".c" means that the parent element
                        // of this node's original location is a SCOPED element
                        // and this node is apart of the root level light dom
                        orgLocationNodeId += `.c`;
                    }
                }
                orgLocationNode.nodeValue = orgLocationNodeId;
            }
        });
    }
};
const parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {
    if (node == null) {
        return;
    }
    if (node['s-nr'] != null) {
        orgLocationNodes.push(node);
    }
    if (node.nodeType === 1 /* NODE_TYPE.ElementNode */) {
        node.childNodes.forEach((childNode) => {
            const hostRef = getHostRef(childNode);
            if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {
                const cmpData = {
                    nodeIds: 0,
                };
                insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);
            }
            parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);
        });
    }
};
const insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {
    if (vnode != null) {
        const hostId = ++docData.hostIds;
        hostElm.setAttribute(HYDRATE_ID, hostId);
        if (hostElm['s-cr'] != null) {
            hostElm['s-cr'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;
        }
        if (vnode.$children$ != null) {
            const depth = 0;
            vnode.$children$.forEach((vnodeChild, index) => {
                insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);
            });
        }
        if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute('c-id')) {
            const parent = hostElm.parentElement;
            if (parent && parent.childNodes) {
                const parentChildNodes = Array.from(parent.childNodes);
                const comment = parentChildNodes.find((node) => node.nodeType === 8 /* NODE_TYPE.CommentNode */ && node['s-sr']);
                if (comment) {
                    const index = parentChildNodes.indexOf(hostElm) - 1;
                    vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);
                }
            }
        }
    }
};
const insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {
    const childElm = vnodeChild.$elm$;
    if (childElm == null) {
        return;
    }
    const nodeId = cmpData.nodeIds++;
    const childId = `${hostId}.${nodeId}.${depth}.${index}`;
    childElm['s-host-id'] = hostId;
    childElm['s-node-id'] = nodeId;
    if (childElm.nodeType === 1 /* NODE_TYPE.ElementNode */) {
        childElm.setAttribute(HYDRATE_CHILD_ID, childId);
    }
    else if (childElm.nodeType === 3 /* NODE_TYPE.TextNode */) {
        const parentNode = childElm.parentNode;
        const nodeName = parentNode.nodeName;
        if (nodeName !== 'STYLE' && nodeName !== 'SCRIPT') {
            const textNodeId = `${TEXT_NODE_ID}.${childId}`;
            const commentBeforeTextNode = doc.createComment(textNodeId);
            parentNode.insertBefore(commentBeforeTextNode, childElm);
        }
    }
    else if (childElm.nodeType === 8 /* NODE_TYPE.CommentNode */) {
        if (childElm['s-sr']) {
            const slotName = childElm['s-sn'] || '';
            const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;
            childElm.nodeValue = slotNodeId;
        }
    }
    if (vnodeChild.$children$ != null) {
        const childDepth = depth + 1;
        vnodeChild.$children$.forEach((vnode, index) => {
            insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);
        });
    }
};
const hostRefs = /*@__PURE__*/ new WeakMap();
const getHostRef = (ref) => hostRefs.get(ref);
const registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);
const registerHost = (elm, cmpMeta) => {
    const hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $cmpMeta$: cmpMeta,
        $instanceValues$: new Map(),
    };
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
        hostRef.$renderCount$ = 0;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {
        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {
        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));
        elm['s-p'] = [];
        elm['s-rc'] = [];
    }
    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
    return hostRefs.set(elm, hostRef);
};
const isMemberInElement = (elm, memberName) => memberName in elm;
const consoleError = (e, el) => (customError || console.error)(e, el);
const STENCIL_DEV_MODE = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isTesting
    ? ['STENCIL:'] // E2E testing
    : [
        '%cstencil',
        'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px',
    ];
const consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);
const consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);
const consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);
const setErrorHandler = (handler) => (customError = handler);
const cmpModules = /*@__PURE__*/ new Map();
const loadModule = (cmpMeta, hostRef, hmrVersionId) => {
    // loadModuleImport
    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');
    const bundleId = cmpMeta.$lazyBundleId$;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && typeof bundleId !== 'string') {
        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode "${hostRef.$modeName$}", but it does not exist.`);
        return undefined;
    }
    const module = !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;
    if (module) {
        return module[exportName];
    }
    /*!__STENCIL_STATIC_IMPORT_SWITCH__*/
    return __webpack_require__("./node_modules/@stencil/core/internal/client lazy recursive ^\\.\\/.*\\.entry\\.js.*$ include: \\.entry\\.js$ exclude: \\.system\\.entry\\.js$")(`./${bundleId}.entry.js${_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement && hmrVersionId ? '?s-hmr=' + hmrVersionId : ''}`).then((importedModule) => {
        if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {
            cmpModules.set(bundleId, importedModule);
        }
        return importedModule[exportName];
    }, consoleError);
};
const styles = /*@__PURE__*/ new Map();
const modeResolutionChain = [];
const win = typeof window !== 'undefined' ? window : {};
const CSS = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim ? win.CSS : null;
const doc = win.document || { head: {} };
const H = (win.HTMLElement || class {
});
const plt = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: (h) => h(),
    raf: (h) => requestAnimationFrame(h),
    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
    ce: (eventName, opts) => new CustomEvent(eventName, opts),
};
const setPlatformHelpers = (helpers) => {
    Object.assign(plt, helpers);
};
const supportsShadow = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDomShim && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom
    ? /*@__PURE__*/ (() => (doc.head.attachShadow + '').indexOf('[native') > -1)()
    : true;
const supportsListenerOptions = /*@__PURE__*/ (() => {
    let supportsListenerOptions = false;
    try {
        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {
            get() {
                supportsListenerOptions = true;
            },
        }));
    }
    catch (e) { }
    return supportsListenerOptions;
})();
const promiseResolve = (v) => Promise.resolve(v);
const supportsConstructableStylesheets = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.constructableCSS
    ? /*@__PURE__*/ (() => {
        try {
            new CSSStyleSheet();
            return typeof new CSSStyleSheet().replaceSync === 'function';
        }
        catch (e) { }
        return false;
    })()
    : false;
const queueDomReads = [];
const queueDomWrites = [];
const queueDomWritesLow = [];
const queueTask = (queue, write) => (cb) => {
    queue.push(cb);
    if (!queuePending) {
        queuePending = true;
        if (write && plt.$flags$ & 4 /* PLATFORM_FLAGS.queueSync */) {
            nextTick(flush);
        }
        else {
            plt.raf(flush);
        }
    }
};
const consume = (queue) => {
    for (let i = 0; i < queue.length; i++) {
        try {
            queue[i](performance.now());
        }
        catch (e) {
            consoleError(e);
        }
    }
    queue.length = 0;
};
const consumeTimeout = (queue, timeout) => {
    let i = 0;
    let ts = 0;
    while (i < queue.length && (ts = performance.now()) < timeout) {
        try {
            queue[i++](ts);
        }
        catch (e) {
            consoleError(e);
        }
    }
    if (i === queue.length) {
        queue.length = 0;
    }
    else if (i !== 0) {
        queue.splice(0, i);
    }
};
const flush = () => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {
        queueCongestion++;
    }
    // always force a bunch of medium callbacks to run, but still have
    // a throttle on how many can run in a certain time
    // DOM READS!!!
    consume(queueDomReads);
    // DOM WRITES!!!
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {
        const timeout = (plt.$flags$ & 6 /* PLATFORM_FLAGS.queueMask */) === 2 /* PLATFORM_FLAGS.appLoaded */
            ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0))
            : Infinity;
        consumeTimeout(queueDomWrites, timeout);
        consumeTimeout(queueDomWritesLow, timeout);
        if (queueDomWrites.length > 0) {
            queueDomWritesLow.push(...queueDomWrites);
            queueDomWrites.length = 0;
        }
        if ((queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0)) {
            // still more to do yet, but we've run out of time
            // let's let this thing cool off and try again in the next tick
            plt.raf(flush);
        }
        else {
            queueCongestion = 0;
        }
    }
    else {
        consume(queueDomWrites);
        if ((queuePending = queueDomReads.length > 0)) {
            // still more to do yet, but we've run out of time
            // let's let this thing cool off and try again in the next tick
            plt.raf(flush);
        }
    }
};
const nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);
const readTask = /*@__PURE__*/ queueTask(queueDomReads, false);
const writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);




/***/ }),

/***/ "./node_modules/focus-trap/dist/focus-trap.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/focus-trap/dist/focus-trap.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFocusTrap": () => (/* binding */ createFocusTrap)
/* harmony export */ });
/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tabbable */ "./node_modules/tabbable/dist/index.esm.js");
/*!
* focus-trap 7.4.3
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/


function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      // move this existing trap to the front of the queue
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var isSelectableInput = function isSelectableInput(node) {
  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
};
var isEscapeEvent = function isEscapeEvent(e) {
  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
};
var isTabEvent = function isTabEvent(e) {
  return e.key === 'Tab' || e.keyCode === 9;
};

// checks for TAB by default
var isKeyForward = function isKeyForward(e) {
  return isTabEvent(e) && !e.shiftKey;
};

// checks for SHIFT+TAB by default
var isKeyBackward = function isKeyBackward(e) {
  return isTabEvent(e) && e.shiftKey;
};
var delay = function delay(fn) {
  return setTimeout(fn, 0);
};

// Array.find/findIndex() are not supported on IE; this replicates enough
//  of Array.findIndex() for our needs
var findIndex = function findIndex(arr, fn) {
  var idx = -1;
  arr.every(function (value, i) {
    if (fn(value)) {
      idx = i;
      return false; // break
    }

    return true; // next
  });

  return idx;
};

/**
 * Get an option's value when it could be a plain value, or a handler that provides
 *  the value.
 * @param {*} value Option's value to check.
 * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.
 * @returns {*} The `value`, or the handler's returned value.
 */
var valueOrHandler = function valueOrHandler(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === 'function' ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget(event) {
  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the
  //  shadow host. However, event.target.composedPath() will be an array of
  //  nodes "clicked" from inner-most (the actual element inside the shadow) to
  //  outer-most (the host HTML document). If we have access to composedPath(),
  //  then use its first element; otherwise, fall back to event.target (and
  //  this only works for an _open_ shadow DOM; otherwise,
  //  composedPath()[0] === event.target always).
  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;
};

// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this
//  current instance use the same stack if `userOptions.trapStack` isn't specified
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap(elements, userOptions) {
  // SSR: a live trap shouldn't be created in this type of environment so this
  //  should be safe code to execute if the `document` option isn't specified
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward: isKeyForward,
    isKeyBackward: isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list

    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: undefined
  };
  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later

  /**
   * Gets a configuration option value.
   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,
   *  value will be taken from this object. Otherwise, value will be taken from base configuration.
   * @param {string} optionName Name of the option whose value is sought.
   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`
   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.
   */
  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };

  /**
   * Finds the index of the container that contains the element.
   * @param {HTMLElement} element
   * @param {Event} [event]
   * @returns {number} Index of the container in either `state.containers` or
   *  `state.containerGroups` (the order/length of these lists are the same); -1
   *  if the element isn't found.
   */
  var findContainerIndex = function findContainerIndex(element, event) {
    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;
    // NOTE: search `containerGroups` because it's possible a group contains no tabbable
    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)
    //  and we still need to find the element in there
    return state.containerGroups.findIndex(function (_ref) {
      var container = _ref.container,
        tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || ( // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {
        return node === element;
      });
    });
  };

  /**
   * Gets the node for the given option, which is expected to be an option that
   *  can be either a DOM node, a string that is a selector to get a node, `false`
   *  (if a node is explicitly NOT given), or a function that returns any of these
   *  values.
   * @param {string} optionName
   * @returns {undefined | false | HTMLElement | SVGElement} Returns
   *  `undefined` if the option is not specified; `false` if the option
   *  resolved to `false` (node explicitly not given); otherwise, the resolved
   *  DOM node.
   * @throws {Error} If the option is set, not `false`, and is not, or does not
   *  resolve to a node.
   */
  var getNodeForOption = function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === 'function') {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = undefined; // use default value
    }

    if (!optionValue) {
      if (optionValue === undefined || optionValue === false) {
        return optionValue;
      }
      // else, empty string (invalid), null (invalid), 0 (invalid)

      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point

    if (typeof optionValue === 'string') {
      node = doc.querySelector(optionValue); // resolve to node, or null if fails
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode() {
    var node = getNodeForOption('initialFocus');

    // false explicitly indicates we want no initialFocus at all
    if (node === false) {
      return false;
    }
    if (node === undefined || !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(node, config.tabbableOptions)) {
      // option not specified nor focusable: use fallback options
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;

        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)
        node = firstTabbableNode || getNodeForOption('fallbackFocus');
      }
    }
    if (!node) {
      throw new Error('Your focus-trap needs to have at least one focusable element');
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes() {
    state.containerGroups = state.containers.map(function (container) {
      var tabbableNodes = (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.tabbable)(container, config.tabbableOptions);

      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes
      //  are a superset of tabbable nodes
      var focusableNodes = (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.focusable)(container, config.tabbableOptions);
      return {
        container: container,
        tabbableNodes: tabbableNodes,
        focusableNodes: focusableNodes,
        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          // NOTE: If tabindex is positive (in order to manipulate the tab order separate
          //  from the DOM order), this __will not work__ because the list of focusableNodes,
          //  while it contains tabbable nodes, does not sort its nodes in any order other
          //  than DOM order, because it can't: Where would you place focusable (but not
          //  tabbable) nodes in that order? They have no order, because they aren't tabbale...
          // Support for positive tabindex is already broken and hard to manage (possibly
          //  not supportable, TBD), so this isn't going to make things worse than they
          //  already are, and at least makes things better for the majority of cases where
          //  tabindex is either 0/unset or negative.
          // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375
          var nodeIdx = focusableNodes.findIndex(function (n) {
            return n === node;
          });
          if (nodeIdx < 0) {
            return undefined;
          }
          if (forward) {
            return focusableNodes.slice(nodeIdx + 1).find(function (n) {
              return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(n, config.tabbableOptions);
            });
          }
          return focusableNodes.slice(0, nodeIdx).reverse().find(function (n) {
            return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(n, config.tabbableOptions);
          });
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function (group) {
      return group.tabbableNodes.length > 0;
    });

    // throw if no groups have tabbable nodes and we don't have a fallback focus node either
    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option
    ) {
      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');
    }
  };
  var tryFocus = function tryFocus(node) {
    if (node === false) {
      return;
    }
    if (node === doc.activeElement) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {
    var node = getNodeForOption('setReturnFocus', previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event.
  var checkPointerDown = function checkPointerDown(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      // allow the click since it ocurred inside the trap
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      // immediately deactivate the trap
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config.returnFocusOnDeactivate
      });
      return;
    }

    // This is needed for mobile devices.
    // (If we'll only let `click` events through,
    // then on mobile they will be blocked anyways if `touchstart` is blocked.)
    if (valueOrHandler(config.allowOutsideClick, e)) {
      // allow the click outside the trap to take place
      return;
    }

    // otherwise, prevent the click
    e.preventDefault();
  };

  // In case focus escapes the trap for some strange reason, pull it back in.
  var checkFocusIn = function checkFocusIn(e) {
    var target = getActualTarget(e);
    var targetContained = findContainerIndex(target, e) >= 0;

    // In Firefox when you Tab out of an iframe the Document is briefly focused.
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      // escaped! pull it back in to where it just left
      e.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }
  };

  // Hijack key nav events on the first and last focusable nodes of the trap,
  // in order to prevent focus from escaping. If it escapes for even a
  // moment it can end up scrolling the page and causing confusion so we
  // kind of need to capture the action at the keydown phase.
  var checkKeyNav = function checkKeyNav(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var target = getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      // make sure the target is actually contained in a group
      // NOTE: the target may also be the container itself if it's focusable
      //  with tabIndex='-1' and was given initial focus
      var containerIndex = findContainerIndex(target, event);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;
      if (containerIndex < 0) {
        // target not found in any group: quite possible focus has escaped the trap,
        //  so bring it back into...
        if (isBackward) {
          // ...the last node in the last group
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          // ...the first node in the first group
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        // REVERSE

        // is the target the first tabbable node in a group?
        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {
          var firstTabbableNode = _ref2.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions) && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          // an exception case where the target is either the container itself, or
          //  a non-tabbable node that was given focus (i.e. tabindex is negative
          //  and user clicked on it or node was programmatically given focus)
          //  and is not followed by any other tabbable node, in which
          //  case, we should handle shift+tab as if focus were on the container's
          //  first tabbable node, and go to the last tabbable node of the LAST group
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          // YES: then shift+tab should go to the last tabbable node in the
          //  previous group (and wrap around to the last tabbable node of
          //  the LAST group if it's the first tabbable node of the FIRST group)
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = destinationGroup.lastTabbableNode;
        } else if (!isTabEvent(event)) {
          // user must have customized the nav keys so we have to move focus manually _within_
          //  the active group: do this based on the order determined by tabbable()
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        // FORWARD

        // is the target the last tabbable node in a group?
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {
          var lastTabbableNode = _ref3.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions) && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          // an exception case where the target is the container itself, or
          //  a non-tabbable node that was given focus (i.e. tabindex is negative
          //  and user clicked on it or node was programmatically given focus)
          //  and is not followed by any other tabbable node, in which
          //  case, we should handle tab as if focus were on the container's
          //  last tabbable node, and go to the first tabbable node of the FIRST group
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          // YES: then tab should go to the first tabbable node in the next
          //  group (and wrap around to the first tabbable node of the FIRST
          //  group if it's the last tabbable node of the LAST group)
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = _destinationGroup.firstTabbableNode;
        } else if (!isTabEvent(event)) {
          // user must have customized the nav keys so we have to move focus manually _within_
          //  the active group: do this based on the order determined by tabbable()
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      // no groups available
      // NOTE: the fallbackFocus option does not support returning false to opt-out
      destinationNode = getNodeForOption('fallbackFocus');
    }
    if (destinationNode) {
      if (isTabEvent(event)) {
        // since tab natively moves focus, we wouldn't have a destination node unless we
        //  were on the edge of a container and had to move to the next/previous edge, in
        //  which case we want to prevent default to keep the browser from moving focus
        //  to where it normally would
        event.preventDefault();
      }
      tryFocus(destinationNode);
    }
    // else, let the browser take care of [shift+]tab and move the focus
  };

  var checkKey = function checkKey(event) {
    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
      return;
    }
    if (config.isKeyForward(event) || config.isKeyBackward(event)) {
      checkKeyNav(event, config.isKeyBackward(event));
    }
  };
  var checkClick = function checkClick(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };

  //
  // EVENT LISTENERS
  //

  var addListeners = function addListeners() {
    if (!state.active) {
      return;
    }

    // There can be only one listening focus trap at a time
    activeFocusTraps.activateTrap(trapStack, trap);

    // Delay ensures that the focused element doesn't capture the event
    // that caused the focus trap activation.
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener('focusin', checkFocusIn, true);
    doc.addEventListener('mousedown', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('touchstart', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('click', checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener('keydown', checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener('focusin', checkFocusIn, true);
    doc.removeEventListener('mousedown', checkPointerDown, true);
    doc.removeEventListener('touchstart', checkPointerDown, true);
    doc.removeEventListener('click', checkClick, true);
    doc.removeEventListener('keydown', checkKey, true);
    return trap;
  };

  //
  // MUTATION OBSERVER
  //

  var checkDomRemoval = function checkDomRemoval(mutations) {
    var isFocusedNodeRemoved = mutations.some(function (mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function (node) {
        return node === state.mostRecentlyFocusedNode;
      });
    });

    // If the currently focused is removed then browsers will move focus to the
    // <body> element. If this happens, try to move focus back into the trap.
    if (isFocusedNodeRemoved) {
      tryFocus(getInitialFocusNode());
    }
  };

  // Use MutationObserver - if supported - to detect if focused node is removed
  // from the DOM.
  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;
  var updateObservedNodes = function updateObservedNodes() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state.active && !state.paused) {
      state.containers.map(function (container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };

  //
  // TRAP DEFINITION
  //

  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, 'onActivate');
      var onPostActivate = getOption(activateOptions, 'onPostActivate');
      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      onActivate === null || onActivate === void 0 ? void 0 : onActivate();
      var finishActivation = function finishActivation() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 ? void 0 : onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer); // noop if undefined
      state.delayInitialFocusTimer = undefined;
      removeListeners();
      state.active = false;
      state.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, 'onDeactivate');
      var onPostDeactivate = getOption(options, 'onPostDeactivate');
      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');
      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');
      onDeactivate === null || onDeactivate === void 0 ? void 0 : onDeactivate();
      var finishDeactivation = function finishDeactivation() {
        delay(function () {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 ? void 0 : onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (state.paused || !state.active) {
        return this;
      }
      var onPause = getOption(pauseOptions, 'onPause');
      var onPostPause = getOption(pauseOptions, 'onPostPause');
      state.paused = true;
      onPause === null || onPause === void 0 ? void 0 : onPause();
      removeListeners();
      updateObservedNodes();
      onPostPause === null || onPostPause === void 0 ? void 0 : onPostPause();
      return this;
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.paused || !state.active) {
        return this;
      }
      var onUnpause = getOption(unpauseOptions, 'onUnpause');
      var onPostUnpause = getOption(unpauseOptions, 'onPostUnpause');
      state.paused = false;
      onUnpause === null || onUnpause === void 0 ? void 0 : onUnpause();
      updateTabbableNodes();
      addListeners();
      updateObservedNodes();
      onPostUnpause === null || onPostUnpause === void 0 ? void 0 : onPostUnpause();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function (element) {
        return typeof element === 'string' ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };

  // initialize container elements
  trap.updateContainerElements(elements);
  return trap;
};


//# sourceMappingURL=focus-trap.esm.js.map


/***/ }),

/***/ "./node_modules/tabbable/dist/index.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tabbable/dist/index.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "focusable": () => (/* binding */ focusable),
/* harmony export */   "isFocusable": () => (/* binding */ isFocusable),
/* harmony export */   "isTabbable": () => (/* binding */ isTabbable),
/* harmony export */   "tabbable": () => (/* binding */ tabbable)
/* harmony export */ });
/*!
* tabbable 6.1.2
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
// NOTE: separate `:not()` selectors has broader browser support than the newer
//  `:not([inert], [inert] *)` (Feb 2023)
// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes
//  the entire query to fail, resulting in no nodes found, which will break a lot
//  of things... so we have to rely on JS to identify nodes inside an inert container
var candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable="false"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];
var candidateSelector = /* #__PURE__ */candidateSelectors.join(',');
var NoElement = typeof Element === 'undefined';
var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function (element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};

/**
 * Determines if a node is inert or in an inert ancestor.
 * @param {Element} [node]
 * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to
 *  see if any of them are inert. If false, only `node` itself is considered.
 * @returns {boolean} True if inert itself or by way of being in an inert ancestor.
 *  False if `node` is falsy.
 */
var isInert = function isInert(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`
  //  JS API property; we have to check the attribute, which can either be empty or 'true';
  //  if it's `null` (not specified) or 'false', it's an active element
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');
  var inert = inertAtt === '' || inertAtt === 'true';

  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`
  //  if it weren't for `matches()` not being a function on shadow roots; the following
  //  code works for any kind of node
  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`
  //  so it likely would not support `:is([inert] *)` either...
  var result = inert || lookUp && node && isInert(node.parentNode); // recursive

  return result;
};

/**
 * Determines if a node's content is editable.
 * @param {Element} [node]
 * @returns True if it's content-editable; false if it's not or `node` is falsy.
 */
var isContentEditable = function isContentEditable(node) {
  var _node$getAttribute2;
  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have
  //  to use the attribute directly to check for this, which can either be empty or 'true';
  //  if it's `null` (not specified) or 'false', it's a non-editable element
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');
  return attValue === '' || attValue === 'true';
};

/**
 * @param {Element} el container to check in
 * @param {boolean} includeContainer add container to check
 * @param {(node: Element) => boolean} filter filter candidates
 * @returns {Element[]}
 */
var getCandidates = function getCandidates(el, includeContainer, filter) {
  // even if `includeContainer=false`, we still have to check it for inertness because
  //  if it's inert, all its children are inert
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};

/**
 * @callback GetShadowRoot
 * @param {Element} element to check for shadow root
 * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.
 */

/**
 * @callback ShadowRootFilter
 * @param {Element} shadowHostNode the element which contains shadow content
 * @returns {boolean} true if a shadow root could potentially contain valid candidates.
 */

/**
 * @typedef {Object} CandidateScope
 * @property {Element} scopeParent contains inner candidates
 * @property {Element[]} candidates list of candidates found in the scope parent
 */

/**
 * @typedef {Object} IterativeOptions
 * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;
 *  if a function, implies shadow support is enabled and either returns the shadow root of an element
 *  or a boolean stating if it has an undisclosed shadow root
 * @property {(node: Element) => boolean} filter filter candidates
 * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list
 * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;
 */

/**
 * @param {Element[]} elements list of element containers to match candidates from
 * @param {boolean} includeContainer add container list to check
 * @param {IterativeOptions} options
 * @returns {Array.<Element|CandidateScope>}
 */
var getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      // no need to look up since we're drilling down
      // anything inside this container will also be inert
      continue;
    }
    if (element.tagName === 'SLOT') {
      // add shadow dom slot scope (slot itself cannot be focusable)
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      // check candidate element
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }

      // iterate over shadow content if possible
      var shadowRoot = element.shadowRoot ||
      // check for an undisclosed shadow
      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);

      // no inert look up because we're already drilling down and checking for inertness
      //  on the way down, so all containers to this root node should have already been
      //  vetted as non-inert
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed
        //  shadow exists, so look at light dom children as fallback BUT create a scope for any
        //  child candidates found because they're likely slotted elements (elements that are
        //  children of the web component element (which has the shadow), in the light dom, but
        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,
        //  _after_ we return from this recursive call
        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        // there's not shadow so just dig into the element's (light dom) children
        //  __without__ giving the element special scope treatment
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex(node, isScope) {
  if (node.tabIndex < 0) {
    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
    // yet they are still part of the regular tab order; in FF, they get a default
    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab
    // order, consider their tab index to be 0.
    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.
    //
    // isScope is positive for custom element with shadow root or slot that by default
    // have tabIndex -1, but need to be sorted by document order in order for their
    // content to be inserted in the correct position
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput(node) {
  return node.tagName === 'INPUT';
};
var isHiddenInput = function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
};
var isDetailsWithSummary = function isDetailsWithSummary(node) {
  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
    return child.tagName === 'SUMMARY';
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio(node) {
  return isInput(node) && node.type === 'radio';
};
var isNonTabbableRadio = function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
};

// determines if a node is ultimately attached to the window's document
var isNodeAttached = function isNodeAttached(node) {
  var _nodeRoot;
  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
  //  (but NOT _the_ document; see second 'If' comment below for more).
  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
  //  is attached, and the one we need to check if it's in the document or not (because the
  //  shadow, and all nodes it contains, is never considered in the document since shadows
  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
  //  visibility, including all the nodes it contains). The host could be any normal node,
  //  or a custom element (i.e. web component). Either way, that's the one that is considered
  //  part of the document, not the shadow root, nor any of its children (i.e. the node being
  //  tested).
  // To further complicate things, we have to look all the way up until we find a shadow HOST
  //  that is attached (or find none) because the node might be in nested shadows...
  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
  //  document (per the docs) and while it's a Document-type object, that document does not
  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
  //  node is actually detached.
  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible
  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed
  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then
  //  `ownerDocument` will be `null`, hence the optional chaining on it.
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;

  // in some cases, a detached node will return itself as the root instead of a document or
  //  shadow root object, in which case, we shouldn't try to look further up the host chain
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
      //  which means we need to get the host's host and check if that parent host is contained
      //  in (i.e. attached to) the document
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(),
    width = _node$getBoundingClie.width,
    height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden(node, _ref) {
  var displayCheck = _ref.displayCheck,
    getShadowRoot = _ref.getShadowRoot;
  // NOTE: visibility will be `undefined` if node is detached from the document
  //  (see notes about this further down), which means we will consider it visible
  //  (this is legacy behavior from a very long way back)
  // NOTE: we check this regardless of `displayCheck="none"` because this is a
  //  _visibility_ check, not a _display_ check
  if (getComputedStyle(node).visibility === 'hidden') {
    return true;
  }
  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
    return true;
  }
  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
    if (typeof getShadowRoot === 'function') {
      // figure out if we should consider the node to be in an undisclosed shadow and use the
      //  'non-zero-area' fallback
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
        ) {
          // node has an undisclosed shadow which means we can only treat it as a black box, so we
          //  fall back to a non-zero-area test
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          // iterate up slot
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          // cross shadow boundary
          node = rootNode.host;
        } else {
          // iterate up normal dom
          node = parentElement;
        }
      }
      node = originalNode;
    }
    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
    //  it might be a falsy value, which means shadow DOM support is disabled

    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
    //  now we can just test to see if it would normally be visible or not, provided it's
    //  attached to the main document.
    // NOTE: We must consider case where node is inside a shadow DOM and given directly to
    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.

    if (isNodeAttached(node)) {
      // this works wherever the node is: if there's at least one client rect, it's
      //  somehow displayed; it also covers the CSS 'display: contents' case where the
      //  node itself is hidden in place of its contents; and there's no need to search
      //  up the hierarchy either
      return !node.getClientRects().length;
    }

    // Else, the node isn't attached to the document, which means the `getClientRects()`
    //  API will __always__ return zero rects (this can happen, for example, if React
    //  is used to render nodes onto a detached tree, as confirmed in this thread:
    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
    //
    // It also means that even window.getComputedStyle(node).display will return `undefined`
    //  because styles are only computed for nodes that are in the document.
    //
    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
    //  somehow. Though it was never stated officially, anyone who has ever used tabbable
    //  APIs on nodes in detached containers has actually implicitly used tabbable in what
    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
    //  considering __everything__ to be visible because of the innability to determine styles.
    //
    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
    //  nodes as visible with the 'none' fallback.__
    if (displayCheck !== 'legacy-full') {
      return true; // hidden
    }
    // else, fallback to 'none' mode and consider the node visible
  } else if (displayCheck === 'non-zero-area') {
    // NOTE: Even though this tests that the node's client rect is non-zero to determine
    //  whether it's displayed, and that a detached node will __always__ have a zero-area
    //  client rect, we don't special-case for whether the node is attached or not. In
    //  this mode, we do want to consider nodes that have a zero area to be hidden at all
    //  times, and that includes attached or not.
    return isZeroArea(node);
  }

  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
  //  it's visible
  return false;
};

// form fields (nested) inside a disabled fieldset are not focusable/tabbable
//  unless they are in the _first_ <legend> element of the top-most disabled
//  fieldset
var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    // check if `node` is contained in a disabled <fieldset>
    while (parentNode) {
      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
        // look for the first <legend> among the children of the disabled <fieldset>
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          // when the first <legend> (in document order) is found
          if (child.tagName === 'LEGEND') {
            // if its parent <fieldset> is not nested in another disabled <fieldset>,
            // return whether `node` is a descendant of its first <legend>
            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
          }
        }
        // the disabled <fieldset> containing `node` has no <legend>
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }

  // else, node's tabbable/focusable state should not be affected by a fieldset's
  //  enabled/disabled state
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
  if (node.disabled ||
  // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||
  // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  // If a custom element has an explicit negative tabindex,
  // browsers will not allow tab targeting said element's children.
  return false;
};

/**
 * @param {Array.<Element|CandidateScope>} candidates
 * @returns Element[]
 */
var sortByOrder = function sortByOrder(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function (item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item: item,
        isScope: isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');
var isFocusable = function isFocusable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};


//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "./node_modules/@arcgis/core/core/domUtils.js":
/*!****************************************************!*\
  !*** ./node_modules/@arcgis/core/core/domUtils.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "byId": () => (/* binding */ e),
/* harmony export */   "closest": () => (/* binding */ l),
/* harmony export */   "empty": () => (/* binding */ n),
/* harmony export */   "insertAfter": () => (/* binding */ t),
/* harmony export */   "insertBefore": () => (/* binding */ o),
/* harmony export */   "remove": () => (/* binding */ r),
/* harmony export */   "reparent": () => (/* binding */ i)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
function e(e){return"string"==typeof e?document.getElementById(e):e??null}function n(e){for(;e.hasChildNodes();)e.removeChild(e.firstChild)}function t(e,n){const t=n.parentNode;t&&(t.lastChild===n?t.appendChild(e):t.insertBefore(e,n.nextSibling))}function o(e,n){const t=n.parentNode;t&&t.insertBefore(e,n)}function i(e,n){for(;;){const t=e.firstChild;if(!t)break;n.appendChild(t)}}function r(e){e.parentNode&&e.parentNode.removeChild(e)}const l="function"==typeof Element.prototype.closest?(e,n)=>e.closest(n):(e,n)=>{let t=e;do{if(t.matches(n))return t;t=t.parentElement}while(null!==t&&1===t.nodeType);return null};


/***/ }),

/***/ "./node_modules/@arcgis/core/core/uuid.js":
/*!************************************************!*\
  !*** ./node_modules/@arcgis/core/core/uuid.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateBracedUUID": () => (/* binding */ r),
/* harmony export */   "generateUUID": () => (/* binding */ n)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const t="randomUUID"in crypto;function n(){if(t)return crypto.randomUUID();const n=crypto.getRandomValues(new Uint16Array(8));n[3]=4095&n[3]|16384,n[4]=16383&n[4]|32768;const r=t=>n[t].toString(16).padStart(4,"0");return r(0)+r(1)+"-"+r(2)+"-"+r(3)+"-"+r(4)+"-"+r(5)+r(6)+r(7)}function r(){return`{${n()}}`}


/***/ }),

/***/ "./node_modules/@arcgis/core/identity/IdentityForm.js":
/*!************************************************************!*\
  !*** ./node_modules/@arcgis/core/identity/IdentityForm.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ c)
/* harmony export */ });
/* harmony import */ var _chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunks/tslib.es6.js */ "./node_modules/@arcgis/core/chunks/tslib.es6.js");
/* harmony import */ var _core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/accessorSupport/decorators/property.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/property.js");
/* harmony import */ var _core_accessorSupport_ensureType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/accessorSupport/ensureType.js */ "./node_modules/@arcgis/core/core/accessorSupport/ensureType.js");
/* harmony import */ var _core_arrayUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/arrayUtils.js */ "./node_modules/@arcgis/core/core/arrayUtils.js");
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/accessorSupport/decorators/subclass.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/subclass.js");
/* harmony import */ var _intl_substitute_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../intl/substitute.js */ "./node_modules/@arcgis/core/intl/substitute.js");
/* harmony import */ var _widgets_Widget_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../widgets/Widget.js */ "./node_modules/@arcgis/core/widgets/Widget.js");
/* harmony import */ var _widgets_support_widgetUtils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../widgets/support/widgetUtils.js */ "./node_modules/@arcgis/core/widgets/support/widgetUtils.js");
/* harmony import */ var _widgets_support_decorators_messageBundle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../widgets/support/decorators/messageBundle.js */ "./node_modules/@arcgis/core/widgets/support/decorators/messageBundle.js");
/* harmony import */ var _widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../widgets/support/jsxFactory.js */ "./node_modules/@arcgis/core/widgets/support/jsxFactory.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const a="esri-identity-form",p={base:a,group:`${a}__group`,label:`${a}__label`,footer:`${a}__footer`,esriInput:"esri-input",esriButton:"esri-button",esriButtonSecondary:"esri-button--secondary"},l="ArcGIS Online";let d=class extends _widgets_Widget_js__WEBPACK_IMPORTED_MODULE_7__["default"]{constructor(s,e){super(s,e),this._usernameInputNode=null,this._passwordInputNode=null,this.signingIn=!1,this.server=null,this.resource=null,this.error=null,this.oAuthPrompt=!1}render(){const{error:s,server:e,resource:t,signingIn:o,oAuthPrompt:n,messages:a}=this,d=(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("div",{class:p.group},(0,_intl_substitute_js__WEBPACK_IMPORTED_MODULE_6__.substitute)(n?a.oAuthInfo:a.info,{server:e&&/\.arcgis\.com/i.test(e)?l:e,resource:`(${t||a.lblItem})`})),c=n?null:(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("div",{class:p.group,key:"username"},(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("label",{class:p.label},a.lblUser,(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("input",{value:"",required:!0,autocomplete:"off",spellcheck:!1,type:"text",bind:this,afterCreate:_widgets_support_widgetUtils_js__WEBPACK_IMPORTED_MODULE_8__.storeNode,"data-node-ref":"_usernameInputNode",class:p.esriInput}))),m=n?null:(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("div",{class:p.group,key:"password"},(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("label",{class:p.label},a.lblPwd,(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("input",{value:"",required:!0,type:"password",bind:this,afterCreate:_widgets_support_widgetUtils_js__WEBPACK_IMPORTED_MODULE_8__.storeNode,"data-node-ref":"_passwordInputNode",class:p.esriInput}))),h=(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("div",{class:this.classes(p.group,p.footer)},(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("input",{type:"submit",disabled:!!o,value:o?a.lblSigning:a.lblOk,class:p.esriButton}),(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("input",{type:"button",value:a.lblCancel,bind:this,onclick:this._cancel,class:this.classes(p.esriButton,p.esriButtonSecondary)})),b=s?(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("div",null,s.details&&s.details.httpStatus?a.invalidUser:a.noAuthService):null;return (0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("form",{class:p.base,bind:this,onsubmit:this._submit},d,b,c,m,h)}_cancel(){this._set("signingIn",!1),this._usernameInputNode&&(this._usernameInputNode.value=""),this._passwordInputNode&&(this._passwordInputNode.value=""),this.emit("cancel")}_submit(s){s.preventDefault(),this._set("signingIn",!0);const e=this.oAuthPrompt?{}:{username:this._usernameInputNode&&this._usernameInputNode.value,password:this._passwordInputNode&&this._passwordInputNode.value};this.emit("submit",e)}};(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)(),(0,_widgets_support_decorators_messageBundle_js__WEBPACK_IMPORTED_MODULE_9__.messageBundle)("esri/identity/t9n/identity")],d.prototype,"messages",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)()],d.prototype,"signingIn",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)()],d.prototype,"server",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)()],d.prototype,"resource",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)()],d.prototype,"error",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)()],d.prototype,"oAuthPrompt",void 0),d=(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_5__.subclass)("esri.identity.IdentityForm")],d);const c=d;


/***/ }),

/***/ "./node_modules/@arcgis/core/identity/IdentityManager.js":
/*!***************************************************************!*\
  !*** ./node_modules/@arcgis/core/identity/IdentityManager.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ s)
/* harmony export */ });
/* harmony import */ var _kernel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../kernel.js */ "./node_modules/@arcgis/core/kernel.js");
/* harmony import */ var _IdentityManagerBase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IdentityManagerBase.js */ "./node_modules/@arcgis/core/identity/IdentityManagerBase.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
class r extends _IdentityManagerBase_js__WEBPACK_IMPORTED_MODULE_1__.IdentityManagerBase{}r.prototype.declaredClass="esri.identity.IdentityManager";const s=new r;(0,_kernel_js__WEBPACK_IMPORTED_MODULE_0__.setId)(s);


/***/ }),

/***/ "./node_modules/@arcgis/core/identity/IdentityManagerBase.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@arcgis/core/identity/IdentityManagerBase.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Credential": () => (/* binding */ L),
/* harmony export */   "IdentityManagerBase": () => (/* binding */ E)
/* harmony export */ });
/* harmony import */ var _chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunks/tslib.es6.js */ "./node_modules/@arcgis/core/chunks/tslib.es6.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config.js */ "./node_modules/@arcgis/core/config.js");
/* harmony import */ var _kernel_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../kernel.js */ "./node_modules/@arcgis/core/kernel.js");
/* harmony import */ var _request_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../request.js */ "./node_modules/@arcgis/core/request.js");
/* harmony import */ var _core_Error_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Error.js */ "./node_modules/@arcgis/core/core/Error.js");
/* harmony import */ var _core_Evented_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Evented.js */ "./node_modules/@arcgis/core/core/Evented.js");
/* harmony import */ var _core_events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/events.js */ "./node_modules/@arcgis/core/core/events.js");
/* harmony import */ var _core_lang_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/lang.js */ "./node_modules/@arcgis/core/core/lang.js");
/* harmony import */ var _core_object_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/object.js */ "./node_modules/@arcgis/core/core/object.js");
/* harmony import */ var _core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/promiseUtils.js */ "./node_modules/@arcgis/core/core/promiseUtils.js");
/* harmony import */ var _core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/reactiveUtils.js */ "./node_modules/@arcgis/core/core/reactiveUtils.js");
/* harmony import */ var _core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../core/urlUtils.js */ "./node_modules/@arcgis/core/core/urlUtils.js");
/* harmony import */ var _core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../core/accessorSupport/decorators/property.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/property.js");
/* harmony import */ var _core_accessorSupport_ensureType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../core/accessorSupport/ensureType.js */ "./node_modules/@arcgis/core/core/accessorSupport/ensureType.js");
/* harmony import */ var _core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../core/accessorSupport/decorators/subclass.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/subclass.js");
/* harmony import */ var _IdentityForm_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./IdentityForm.js */ "./node_modules/@arcgis/core/identity/IdentityForm.js");
/* harmony import */ var _IdentityModal_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./IdentityModal.js */ "./node_modules/@arcgis/core/identity/IdentityModal.js");
/* harmony import */ var _OAuthCredential_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./OAuthCredential.js */ "./node_modules/@arcgis/core/identity/OAuthCredential.js");
/* harmony import */ var _OAuthInfo_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./OAuthInfo.js */ "./node_modules/@arcgis/core/identity/OAuthInfo.js");
/* harmony import */ var _ServerInfo_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./ServerInfo.js */ "./node_modules/@arcgis/core/identity/ServerInfo.js");
/* harmony import */ var _portal_support_urlUtils_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../portal/support/urlUtils.js */ "./node_modules/@arcgis/core/portal/support/urlUtils.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const C={},b=e=>{const t=new _core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.Url(e.owningSystemUrl).host,r=new _core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.Url(e.server).host,s=/.+\.arcgis\.com$/i;return s.test(t)&&s.test(r)},D=(e,t)=>!!(b(e)&&t&&t.some((t=>t.test(e.server))));let q=null,j=null;try{q=window.localStorage,j=window.sessionStorage}catch{}class E extends _core_Evented_js__WEBPACK_IMPORTED_MODULE_5__["default"]{constructor(){super(),this._portalConfig=globalThis.esriGeowConfig,this.serverInfos=[],this.oAuthInfos=[],this.credentials=[],this._soReqs=[],this._xoReqs=[],this._portals=[],this._defaultOAuthInfo=null,this._defaultTokenValidity=60,this.dialog=null,this.formConstructor=_IdentityForm_js__WEBPACK_IMPORTED_MODULE_15__["default"],this.tokenValidity=null,this.normalizeWebTierAuth=!1,this._appOrigin="null"!==window.origin?window.origin:window.location.origin,this._appUrlObj=(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.urlToObject)(window.location.href),this._busy=null,this._rejectOnPersistedPageShow=!1,this._oAuthLocationParams=null,this._gwTokenUrl="/sharing/rest/generateToken",this._agsRest="/rest/services",this._agsPortal=/\/sharing(\/|$)/i,this._agsAdmin=/(https?:\/\/[^\/]+\/[^\/]+)\/admin\/?(\/.*)?$/i,this._adminSvcs=/\/rest\/admin\/services(\/|$)/i,this._gwDomains=[{regex:/^https?:\/\/www\.arcgis\.com/i,customBaseUrl:"maps.arcgis.com",tokenServiceUrl:"https://www.arcgis.com/sharing/rest/generateToken"},{regex:/^https?:\/\/(?:dev|[a-z\d-]+\.mapsdev)\.arcgis\.com/i,customBaseUrl:"mapsdev.arcgis.com",tokenServiceUrl:"https://dev.arcgis.com/sharing/rest/generateToken"},{regex:/^https?:\/\/(?:devext|[a-z\d-]+\.mapsdevext)\.arcgis\.com/i,customBaseUrl:"mapsdevext.arcgis.com",tokenServiceUrl:"https://devext.arcgis.com/sharing/rest/generateToken"},{regex:/^https?:\/\/(?:qaext|[a-z\d-]+\.mapsqa)\.arcgis\.com/i,customBaseUrl:"mapsqa.arcgis.com",tokenServiceUrl:"https://qaext.arcgis.com/sharing/rest/generateToken"},{regex:/^https?:\/\/[a-z\d-]+\.maps\.arcgis\.com/i,customBaseUrl:"maps.arcgis.com",tokenServiceUrl:"https://www.arcgis.com/sharing/rest/generateToken"}],this._legacyFed=[],this._regexSDirUrl=/http.+\/rest\/services\/?/gi,this._regexServerType=/(\/(FeatureServer|GPServer|GeoDataServer|GeocodeServer|GeoenrichmentServer|GeometryServer|GlobeServer|ImageServer|KnowledgeGraphServer|MapServer|MissionServer|MobileServer|NAServer|NetworkDiagramServer|OGCFeatureServer|ParcelFabricServer|RelationalCatalogServer|SceneServer|StreamServer|UtilityNetworkServer|ValidationServer|VectorTileServer|VersionManagementServer|VideoServer)).*/gi,this._gwUser=/http.+\/users\/([^\/]+)\/?.*/i,this._gwItem=/http.+\/items\/([^\/]+)\/?.*/i,this._gwGroup=/http.+\/groups\/([^\/]+)\/?.*/i,this._rePortalTokenSvc=/\/sharing(\/rest)?\/generatetoken/i,this._createDefaultOAuthInfo=!0,this._hasTestedIfAppIsOnPortal=!1,this._getOAuthLocationParams(),window.addEventListener("pageshow",(e=>{this._pageShowHandler(e)}))}registerServers(e){const t=this.serverInfos;t?(e=e.filter((e=>!this.findServerInfo(e.server))),this.serverInfos=t.concat(e)):this.serverInfos=e,e.forEach((e=>{e.owningSystemUrl&&this._portals.push(e.owningSystemUrl),e.hasPortal&&this._portals.push(e.server)}))}registerOAuthInfos(e){const t=this.oAuthInfos;if(t){for(const r of e){const e=this.findOAuthInfo(r.portalUrl);e&&t.splice(t.indexOf(e),1)}this.oAuthInfos=t.concat(e)}else this.oAuthInfos=e}registerToken(e){e={...e};const t=this._sanitizeUrl(e.server),r=this._isServerRsrc(t);let s,i=this.findServerInfo(t),o=!0;i||(i=new _ServerInfo_js__WEBPACK_IMPORTED_MODULE_19__["default"],i.server=this._getServerInstanceRoot(t),r?i.hasServer=!0:(i.tokenServiceUrl=this._getTokenSvcUrl(t),i.hasPortal=!0),this.registerServers([i])),s=this._findCredential(t),s?(delete e.server,Object.assign(s,e),o=!1):(s=new L({userId:e.userId,server:i.server,token:e.token,expires:e.expires,ssl:e.ssl,scope:r?"server":"portal"}),s.resources=[t],this.credentials.push(s)),s.emitTokenChange(!1),o||s.refreshServerTokens()}toJSON(){return (0,_core_lang_js__WEBPACK_IMPORTED_MODULE_7__.fixJson)({serverInfos:this.serverInfos.map((e=>e.toJSON())),oAuthInfos:this.oAuthInfos.map((e=>e.toJSON())),credentials:this.credentials.map((e=>e.toJSON()))})}initialize(e){if(!e)return;"string"==typeof e&&(e=JSON.parse(e));const t=e.serverInfos,r=e.oAuthInfos,s=e.credentials;if(t){const e=[];t.forEach((t=>{t.server&&t.tokenServiceUrl&&e.push(t.declaredClass?t:new _ServerInfo_js__WEBPACK_IMPORTED_MODULE_19__["default"](t))})),e.length&&this.registerServers(e)}if(r){const e=[];r.forEach((t=>{t.appId&&e.push(t.declaredClass?t:new _OAuthInfo_js__WEBPACK_IMPORTED_MODULE_18__["default"](t))})),e.length&&this.registerOAuthInfos(e)}s&&s.forEach((e=>{e.server&&e.token&&e.expires&&e.expires>Date.now()&&((e=e.declaredClass?e:new L(e)).emitTokenChange(),this.credentials.push(e))}))}findServerInfo(e){let t;e=this._sanitizeUrl(e);for(const r of this.serverInfos)if(this._hasSameServerInstance(r.server,e)){t=r;break}return t}findOAuthInfo(e){let t;e=this._sanitizeUrl(e);for(const r of this.oAuthInfos)if(this._hasSameServerInstance(r.portalUrl,e)){t=r;break}return t}findCredential(e,t){if(!e)return;let r;e=this._sanitizeUrl(e);const s=this._isServerRsrc(e)?"server":"portal";if(t){for(const i of this.credentials)if(this._hasSameServerInstance(i.server,e)&&t===i.userId&&i.scope===s){r=i;break}}else for(const i of this.credentials)if(this._hasSameServerInstance(i.server,e)&&-1!==this._getIdenticalSvcIdx(e,i)&&i.scope===s){r=i;break}return r}getCredential(e,t){let r,s,o=!0;t&&(r=!!t.token,s=t.error,o=!1!==t.prompt),t={...t},e=this._sanitizeUrl(e);const n=new AbortController,a=(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_9__.createResolver)();if(t.signal&&(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_9__.onAbort)(t.signal,(()=>{n.abort()})),(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_9__.onAbort)(n,(()=>{a.reject(new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:user-aborted","ABORTED"))})),(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_9__.isAborted)(n))return a.promise;t.signal=n.signal;const h=this._isAdminResource(e),u=r?this.findCredential(e):null;let p;if(u&&s&&s.details&&498===s.details.httpStatus)u.destroy();else if(u)return p=new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:not-authorized","You are currently signed in as: '"+u.userId+"'. You do not have access to this resource: "+e,{error:s}),a.reject(p),a.promise;const f=this._findCredential(e,t);if(f)return a.resolve(f),a.promise;let g=this.findServerInfo(e);if(g)!g.hasServer&&this._isServerRsrc(e)&&(g._restInfoPms=this._getTokenSvcUrl(e),g.hasServer=!0);else{const t=this._getTokenSvcUrl(e);if(!t)return p=new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:unknown-resource","Unknown resource - could not find token service endpoint."),a.reject(p),a.promise;g=new _ServerInfo_js__WEBPACK_IMPORTED_MODULE_19__["default"],g.server=this._getServerInstanceRoot(e),"string"==typeof t?(g.tokenServiceUrl=t,g.hasPortal=!0):(g._restInfoPms=t,g.hasServer=!0),this.registerServers([g])}return g.hasPortal&&void 0===g._selfReq&&(o||(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.hasSameOrigin)(g.tokenServiceUrl,this._appOrigin)||this._gwDomains.some((e=>e.tokenServiceUrl===g.tokenServiceUrl)))&&(g._selfReq={owningTenant:t&&t.owningTenant,selfDfd:this._getPortalSelf(g.tokenServiceUrl.replace(this._rePortalTokenSvc,"/sharing/rest/portals/self"),e)}),this._enqueue(e,g,t,a,h)}getResourceName(e){return this._isRESTService(e)?e.replace(this._regexSDirUrl,"").replace(this._regexServerType,"")||"":this._gwUser.test(e)&&e.replace(this._gwUser,"$1")||this._gwItem.test(e)&&e.replace(this._gwItem,"$1")||this._gwGroup.test(e)&&e.replace(this._gwGroup,"$1")||""}generateToken(e,t,r){const o=this._rePortalTokenSvc.test(e.tokenServiceUrl),n=new _core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.Url(this._appOrigin),a=e.shortLivedTokenValidity;let h,l,c,d,u,p,g,m;t&&(m=this.tokenValidity||a||this._defaultTokenValidity,m>a&&a>0&&(m=a)),r&&(h=r.isAdmin,l=r.serverUrl,c=r.token,p=r.signal,g=r.ssl,e.customParameters=r.customParameters),h?d=e.adminTokenServiceUrl:(d=e.tokenServiceUrl,u=new _core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.Url(d.toLowerCase()),e.webTierAuth&&r?.serverUrl&&!g&&"http"===n.scheme&&((0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.hasSameOrigin)(n.uri,d,!0)||"https"===u.scheme&&n.host===u.host&&"7080"===n.port&&"7443"===u.port)&&(d=d.replace(/^https:/i,"http:").replace(/:7443/i,":7080")));const v={query:{request:"getToken",username:t?.username,password:t?.password,serverUrl:l,token:c,expiration:m,referer:h||o?this._appOrigin:null,client:h?"referer":null,f:"json",...e.customParameters},method:"post",authMode:"anonymous",useProxy:this._useProxy(e,r),signal:p,...r?.ioArgs};o||(v.withCredentials=!1);return (0,_request_js__WEBPACK_IMPORTED_MODULE_3__["default"])(d,v).then((r=>{const s=r.data;if(!s||!s.token)return new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:authentication-failed","Unable to generate token");const o=e.server;return C[o]||(C[o]={}),t&&(C[o][t.username]=t.password),s.validity=m,s}))}isBusy(){return!!this._busy}checkSignInStatus(e){return this.checkAppAccess(e,"").then((e=>e.credential))}checkAppAccess(e,t,r){let o=!1;return this.getCredential(e,{prompt:!1}).then((n=>{let a;const h={f:"json"};if("portal"===n.scope)if(t&&(this._doPortalSignIn(e)||r&&r.force))a=n.server+"/sharing/rest/oauth2/validateAppAccess",h.client_id=t;else{if(!n.token)return{credential:n};a=n.server+"/sharing/rest"}else{if(!n.token)return{credential:n};a=n.server+"/rest/services"}return n.token&&(h.token=n.token),(0,_request_js__WEBPACK_IMPORTED_MODULE_3__["default"])(a,{query:h,authMode:"anonymous"}).then((e=>{if(!1===e.data.valid)throw new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:not-authorized",`You are currently signed in as: '${n.userId}'.`,e.data);return o=!!e.data.viewOnlyUserTypeApp,{credential:n}})).catch((e=>{if("identity-manager:not-authorized"===e.name)throw e;const t=e.details&&e.details.httpStatus;if(498===t)throw n.destroy(),new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:not-authenticated","User is not signed in.");if(400===t)throw new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:invalid-request");return{credential:n}}))})).then((e=>({credential:e.credential,viewOnly:o})))}setOAuthResponseHash(e){e&&("#"===e.charAt(0)&&(e=e.substring(1)),this._processOAuthPopupParams((0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.queryToObject)(e)))}setOAuthRedirectionHandler(e){this._oAuthRedirectFunc=e}setProtocolErrorHandler(e){this._protocolFunc=e}signIn(e,t,r={}){const s=(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_9__.createResolver)(),o=()=>{h?.remove(),d?.remove(),p?.remove(),a?.destroy(),this.dialog?.destroy(),this.dialog=a=h=d=p=null},n=()=>{o(),this._oAuthDfd=null,s.reject(new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:user-aborted","ABORTED"))};r.signal&&(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_9__.onAbort)(r.signal,(()=>{n()}));let a=new this.formConstructor;a.resource=this.getResourceName(e),a.server=t.server,this.dialog=new _IdentityModal_js__WEBPACK_IMPORTED_MODULE_16__["default"],this.dialog.content=a,this.dialog.open=!0,this.emit("dialog-create");let h=a.on("cancel",n),d=(0,_core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_10__.watch)((()=>this.dialog.open),n),p=a.on("submit",(e=>{this.generateToken(t,e,{isAdmin:r.isAdmin,signal:r.signal}).then((i=>{o();const n=new L({userId:e.username,server:t.server,token:i.token,expires:null!=i.expires?Number(i.expires):null,ssl:!!i.ssl,isAdmin:r.isAdmin,validity:i.validity});s.resolve(n)})).catch((e=>{a.error=e,a.signingIn=!1}))}));return s.promise}oAuthSignIn(e,t,r,s){this._oAuthDfd=(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_9__.createResolver)();const o=this._oAuthDfd;let n;s?.signal&&(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_9__.onAbort)(s.signal,(()=>{const e=this._oAuthDfd&&this._oAuthDfd.oAuthWin_;e&&!e.closed?e.close():this.dialog&&f()})),o.resUrl_=e,o.sinfo_=t,o.oinfo_=r;const a=r._oAuthCred;if(a.storage&&("authorization-code"===r.flowType||"auto"===r.flowType&&!r.popup&&t.currentVersion>=8.4)){let e=crypto.getRandomValues(new Uint8Array(32));n=(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.base64UrlEncode)(e),a.codeVerifier=n,e=crypto.getRandomValues(new Uint8Array(32)),a.stateUID=(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.base64UrlEncode)(e),a.save()||(a.codeVerifier=n=null)}else a.codeVerifier=null;let h,d,p,_;this._getCodeChallenge(n).then((i=>{const o=!s||!1!==s.oAuthPopupConfirmation;r.popup&&o?(h=new this.formConstructor,h.oAuthPrompt=!0,h.server=t.server,this.dialog=new _IdentityModal_js__WEBPACK_IMPORTED_MODULE_16__["default"],this.dialog.content=h,this.dialog.open=!0,this.emit("dialog-create"),d=h.on("cancel",f),p=(0,_core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_10__.watch)((()=>this.dialog.open),f),_=h.on("submit",(()=>{g(),this._doOAuthSignIn(e,t,r,i)}))):this._doOAuthSignIn(e,t,r,i)}));const f=()=>{g(),this._oAuthDfd=null,o.reject(new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:user-aborted","ABORTED"))},g=()=>{d?.remove(),p?.remove(),_?.remove(),h?.destroy(),this.dialog?.destroy(),this.dialog=null};return o.promise}destroyCredentials(){if(this.credentials){this.credentials.slice().forEach((e=>{e.destroy()}))}this.emit("credentials-destroy")}enablePostMessageAuth(e="https://www.arcgis.com/sharing/rest"){this._postMessageAuthHandle&&this._postMessageAuthHandle.remove(),this._postMessageAuthHandle=(0,_core_events_js__WEBPACK_IMPORTED_MODULE_6__.on)(window,"message",(t=>{if((t.origin===this._appOrigin||t.origin.endsWith(".arcgis.com"))&&"arcgis:auth:requestCredential"===t.data?.type){const r=t.source;this.getCredential(e).then((e=>{r.postMessage({type:"arcgis:auth:credential",credential:{expires:e.expires,server:e.server,ssl:e.ssl,token:e.token,userId:e.userId}},t.origin)})).catch((e=>{r.postMessage({type:"arcgis:auth:error",error:{name:e.name,message:e.message}},t.origin)}))}}))}disablePostMessageAuth(){this._postMessageAuthHandle&&(this._postMessageAuthHandle.remove(),this._postMessageAuthHandle=null)}_getOAuthLocationParams(){let e=window.location.hash;if(e){"#"===e.charAt(0)&&(e=e.substring(1));const t=(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.queryToObject)(e);let r=!1;if(t.access_token&&t.expires_in&&t.state&&t.hasOwnProperty("username"))try{t.state=JSON.parse(t.state),t.state.portalUrl&&(this._oAuthLocationParams=t,r=!0)}catch{}else if(t.error&&t.error_description&&(console.log("IdentityManager OAuth Error: ",t.error," - ",t.error_description),"access_denied"===t.error&&(r=!0,t.state)))try{t.state=JSON.parse(t.state)}catch{}r&&(window.location.hash=t.state?.hash||"")}let t=window.location.search;if(t){"?"===t.charAt(0)&&(t=t.substring(1));const e=(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.queryToObject)(t);let r=!1;if(e.code&&e.state)try{e.state=JSON.parse(e.state),e.state.portalUrl&&e.state.uid&&(this._oAuthLocationParams=e,r=!0)}catch{}else if(e.error&&e.error_description&&(console.log("IdentityManager OAuth Error: ",e.error," - ",e.error_description),"access_denied"===e.error&&(r=!0,e.state)))try{e.state=JSON.parse(e.state)}catch{}if(r){const t={...e};["code","error","error_description","message_code","persist","state"].forEach((e=>{delete t[e]}));const r=(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.objectToQuery)(t),s=window.location.pathname+(r?`?${r}`:"")+(e.state?.hash||"");window.history.replaceState(window.history.state,"",s)}}}_getOAuthToken(e,t,r,i,o){return e=e.replace(/^http:/i,"https:"),(0,_request_js__WEBPACK_IMPORTED_MODULE_3__["default"])(`${e}/sharing/rest/oauth2/token`,{authMode:"anonymous",method:"post",query:i&&o?{grant_type:"authorization_code",code:t,redirect_uri:i,client_id:r,code_verifier:o}:{grant_type:"refresh_token",refresh_token:t,client_id:r}}).then((e=>e.data))}_getCodeChallenge(e){if(e&&globalThis.isSecureContext){const t=(new TextEncoder).encode(e);return crypto.subtle.digest("SHA-256",t).then((e=>(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.base64UrlEncode)(new Uint8Array(e))))}return Promise.resolve(null)}_pageShowHandler(e){if(e.persisted&&this.isBusy()&&this._rejectOnPersistedPageShow){const e=new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:user-aborted","ABORTED");this._errbackFunc(e)}}_findCredential(e,t){let r,s,i,o,n=-1;const a=t&&t.token,h=t&&t.resource,l=this._isServerRsrc(e)?"server":"portal",c=this.credentials.filter((t=>this._hasSameServerInstance(t.server,e)&&t.scope===l));if(e=h||e,c.length)if(1===c.length){if(r=c[0],i=this.findServerInfo(r.server),s=i&&i.owningSystemUrl,o=s?this.findCredential(s,r.userId):void 0,n=this._getIdenticalSvcIdx(e,r),!a)return-1===n&&r.resources.push(e),this._addResource(e,o),r;-1!==n&&(r.resources.splice(n,1),this._removeResource(e,o))}else{let t,r;if(c.some((a=>(r=this._getIdenticalSvcIdx(e,a),-1!==r&&(t=a,i=this.findServerInfo(t.server),s=i&&i.owningSystemUrl,o=s?this.findCredential(s,t.userId):void 0,n=r,!0)))),a)t&&(t.resources.splice(n,1),this._removeResource(e,o));else if(t)return this._addResource(e,o),t}}_findOAuthInfo(e){let t=this.findOAuthInfo(e);if(!t)for(const r of this.oAuthInfos)if(this._isIdProvider(r.portalUrl,e)){t=r;break}return t}_addResource(e,t){t&&-1===this._getIdenticalSvcIdx(e,t)&&t.resources.push(e)}_removeResource(e,t){let r=-1;t&&(r=this._getIdenticalSvcIdx(e,t),r>-1&&t.resources.splice(r,1))}_useProxy(e,t){return t&&t.isAdmin&&!(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.hasSameOrigin)(e.adminTokenServiceUrl,this._appOrigin)||!this._isPortalDomain(e.tokenServiceUrl)&&"10.1"===String(e.currentVersion)&&!(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.hasSameOrigin)(e.tokenServiceUrl,this._appOrigin)}_getOrigin(e){const t=new _core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.Url(e);return t.scheme+"://"+t.host+(null!=t.port?":"+t.port:"")}_getServerInstanceRoot(e){const t=e.toLowerCase();let r=t.indexOf(this._agsRest);return-1===r&&this._isAdminResource(e)&&(r=this._agsAdmin.test(e)?e.replace(this._agsAdmin,"$1").length:e.search(this._adminSvcs)),-1!==r||(0,_portal_support_urlUtils_js__WEBPACK_IMPORTED_MODULE_20__.isSecureProxyService)(t)||(r=t.indexOf("/sharing")),-1===r&&"/"===t.substr(-1)&&(r=t.length-1),r>-1?e.substring(0,r):e}_hasSameServerInstance(e,t){return"/"===e.substr(-1)&&(e=e.slice(0,-1)),e=e.toLowerCase(),t=this._getServerInstanceRoot(t).toLowerCase(),e=this._normalizeAGOLorgDomain(e),t=this._normalizeAGOLorgDomain(t),(e=e.substr(e.indexOf(":")))===(t=t.substr(t.indexOf(":")))}_normalizeAGOLorgDomain(e){const t=/^https?:\/\/(?:cdn|[a-z\d-]+\.maps)\.arcgis\.com/i,r=/^https?:\/\/(?:cdndev|[a-z\d-]+\.mapsdevext)\.arcgis\.com/i,s=/^https?:\/\/(?:cdnqa|[a-z\d-]+\.mapsqa)\.arcgis\.com/i;return t.test(e)?e=e.replace(t,"https://www.arcgis.com"):r.test(e)?e=e.replace(r,"https://devext.arcgis.com"):s.test(e)&&(e=e.replace(s,"https://qaext.arcgis.com")),e}_sanitizeUrl(e){const r=(_config_js__WEBPACK_IMPORTED_MODULE_1__["default"].request.proxyUrl||"").toLowerCase(),s=r?e.toLowerCase().indexOf(r+"?"):-1;return-1!==s&&(e=e.substring(s+r.length+1)),e=(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.normalize)(e),(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.urlToObject)(e).path}_isRESTService(e){return e.includes(this._agsRest)}_isAdminResource(e){return this._agsAdmin.test(e)||this._adminSvcs.test(e)}_isServerRsrc(e){return this._isRESTService(e)||this._isAdminResource(e)}_isIdenticalService(e,t){let r=!1;if(this._isRESTService(e)&&this._isRESTService(t)){const s=this._getSuffix(e).toLowerCase(),i=this._getSuffix(t).toLowerCase();if(r=s===i,!r){const e=/(.*)\/(MapServer|FeatureServer|UtilityNetworkServer).*/gi;r=s.replaceAll(e,"$1")===i.replaceAll(e,"$1")}}else this._isAdminResource(e)&&this._isAdminResource(t)?r=!0:this._isServerRsrc(e)||this._isServerRsrc(t)||!this._isPortalDomain(e)||(r=!0);return r}_isPortalDomain(e){const r=new _core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.Url(e.toLowerCase()),s=this._portalConfig;let i=this._gwDomains.some((e=>e.regex.test(r.uri)));return!i&&s&&(i=this._hasSameServerInstance(this._getServerInstanceRoot(s.restBaseUrl),r.uri)),i||_config_js__WEBPACK_IMPORTED_MODULE_1__["default"].portalUrl&&(i=(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.hasSameOrigin)(r,_config_js__WEBPACK_IMPORTED_MODULE_1__["default"].portalUrl,!0)),i||(i=this._portals.some((e=>this._hasSameServerInstance(e,r.uri)))),i=i||this._agsPortal.test(r.path),i}_isIdProvider(e,t){let r=-1,s=-1;this._gwDomains.forEach(((i,o)=>{-1===r&&i.regex.test(e)&&(r=o),-1===s&&i.regex.test(t)&&(s=o)}));let i=!1;if(r>-1&&s>-1&&(0===r||4===r?0!==s&&4!==s||(i=!0):1===r?1!==s&&2!==s||(i=!0):2===r?2===s&&(i=!0):3===r&&3===s&&(i=!0)),!i){const r=this.findServerInfo(t),s=r&&r.owningSystemUrl;s&&b(r)&&this._isPortalDomain(s)&&this._isIdProvider(e,s)&&(i=!0)}return i}_getIdenticalSvcIdx(e,t){let r=-1;for(let s=0;s<t.resources.length;s++){const i=t.resources[s];if(this._isIdenticalService(e,i)){r=s;break}}return r}_getSuffix(e){return e.replace(this._regexSDirUrl,"").replace(this._regexServerType,"$1")}_getTokenSvcUrl(e){let t,r,i;if(this._isRESTService(e)||this._isAdminResource(e)){const i=this._getServerInstanceRoot(e);return t=i+"/admin/generateToken",r=(0,_request_js__WEBPACK_IMPORTED_MODULE_3__["default"])(e=i+"/rest/info",{query:{f:"json"}}).then((e=>e.data)),{adminUrl:t,promise:r}}if(this._isPortalDomain(e)){let t="";if(this._gwDomains.some((r=>(r.regex.test(e)&&(t=r.tokenServiceUrl),!!t))),t||this._portals.some((r=>(this._hasSameServerInstance(r,e)&&(t=r+this._gwTokenUrl),!!t))),t||(i=e.toLowerCase().indexOf("/sharing"),-1!==i&&(t=e.substring(0,i)+this._gwTokenUrl)),t||(t=this._getOrigin(e)+this._gwTokenUrl),t){const r=new _core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.Url(e).port;/^http:\/\//i.test(e)&&"7080"===r&&(t=t.replace(/:7080/i,":7443")),t=t.replace(/http:/i,"https:")}return t}if(e.toLowerCase().includes("premium.arcgisonline.com"))return"https://premium.arcgisonline.com/server/tokens"}_processOAuthResponseParams(e,t,r){const s=t._oAuthCred;if(e.code){const i=s.codeVerifier;return s.codeVerifier=null,s.stateUID=null,s.save(),this._getOAuthToken(r.server,e.code,t.appId,this._getRedirectURI(t,!0),i).then((i=>{const o=new L({userId:i.username,server:r.server,token:i.access_token,expires:Date.now()+1e3*i.expires_in,ssl:i.ssl,oAuthState:e.state,_oAuthCred:s});return t.userId=o.userId,s.storage=i.persist?q:j,s.refreshToken=i.refresh_token,s.token=null,s.expires=i.refresh_token_expires_in?Date.now()+1e3*i.refresh_token_expires_in:null,s.userId=o.userId,s.ssl=o.ssl,s.save(),o}))}const i=new L({userId:e.username,server:r.server,token:e.access_token,expires:Date.now()+1e3*Number(e.expires_in),ssl:"true"===e.ssl,oAuthState:e.state,_oAuthCred:s});return t.userId=i.userId,s.storage=e.persist?q:j,s.refreshToken=null,s.token=i.token,s.expires=i.expires,s.userId=i.userId,s.ssl=i.ssl,s.save(),Promise.resolve(i)}_processOAuthPopupParams(e){const t=this._oAuthDfd;if(this._oAuthDfd=null,t)if(clearInterval(this._oAuthIntervalId),this._oAuthOnPopupHandle?.remove(),e.error){const r="access_denied"===e.error,s=new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"](r?"identity-manager:user-aborted":"identity-manager:authentication-failed",r?"ABORTED":"OAuth: "+e.error+" - "+e.error_description);t.reject(s)}else this._processOAuthResponseParams(e,t.oinfo_,t.sinfo_).then((e=>{t.resolve(e)})).catch((e=>{t.reject(e)}))}_setOAuthResponseQueryString(e){e&&("?"===e.charAt(0)&&(e=e.substring(1)),this._processOAuthPopupParams((0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.queryToObject)(e)))}_exchangeToken(e,t,r){return (0,_request_js__WEBPACK_IMPORTED_MODULE_3__["default"])(`${e}/sharing/rest/oauth2/exchangeToken`,{authMode:"anonymous",method:"post",query:{f:"json",client_id:t,token:r}}).then((e=>e.data.token))}_getPlatformSelf(e,t){return e=e.replace(/^http:/i,"https:"),(0,_request_js__WEBPACK_IMPORTED_MODULE_3__["default"])(`${e}/sharing/rest/oauth2/platformSelf`,{authMode:"anonymous",headers:{"X-Esri-Auth-Client-Id":t,"X-Esri-Auth-Redirect-Uri":window.location.href.replace(/#.*$/,"")},method:"post",query:{f:"json",expiration:30},withCredentials:!0}).then((e=>e.data))}_getPortalSelf(e,t){let r;if(this._gwDomains.some((t=>(t.regex.test(e)&&(r=t.customBaseUrl),!!r))),r)return Promise.resolve({allSSL:!0,currentVersion:"8.4",customBaseUrl:r,portalMode:"multitenant",supportsOAuth:!0});this._appOrigin.startsWith("https:")?e=e.replace(/^http:/i,"https:").replace(/:7080/i,":7443"):/^http:/i.test(t)&&(e=e.replace(/^https:/i,"http:").replace(/:7443/i,":7080"));return (0,_request_js__WEBPACK_IMPORTED_MODULE_3__["default"])(e,{query:{f:"json"},authMode:"anonymous",withCredentials:!0}).then((e=>e.data))}_doPortalSignIn(e){const t=this._portalConfig,r=window.location.href,s=this.findServerInfo(e);return!(!t&&!this._isPortalDomain(r)||!(s?s.hasPortal||s.owningSystemUrl&&this._isPortalDomain(s.owningSystemUrl):this._isPortalDomain(e))||!(this._isIdProvider(r,e)||t&&(this._hasSameServerInstance(this._getServerInstanceRoot(t.restBaseUrl),e)||this._isIdProvider(t.restBaseUrl,e))||(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.hasSameOrigin)(r,e,!0)))}_checkProtocol(e,t,r,s){let o=!0;const n=s?t.adminTokenServiceUrl:t.tokenServiceUrl;if(n.trim().toLowerCase().startsWith("https:")&&!this._appOrigin.startsWith("https:")&&(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.getProxyRule)(n)&&(o=!!this._protocolFunc&&!!this._protocolFunc({resourceUrl:e,serverInfo:t}),!o)){r(new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:aborted","Aborted the Sign-In process to avoid sending password over insecure connection."))}return o}_enqueue(e,t,r,s,i,o){return s||(s=(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_9__.createResolver)()),s.resUrl_=e,s.sinfo_=t,s.options_=r,s.admin_=i,s.refresh_=o,this._busy?this._hasSameServerInstance(this._getServerInstanceRoot(e),this._busy.resUrl_)?(this._oAuthDfd&&this._oAuthDfd.oAuthWin_&&this._oAuthDfd.oAuthWin_.focus(),this._soReqs.push(s)):this._xoReqs.push(s):this._doSignIn(s),s.promise}_doSignIn(e){this._busy=e,this._rejectOnPersistedPageShow=!1;const t=t=>{const r=e.options_&&e.options_.resource,s=e.resUrl_,i=e.refresh_;let o=!1;this.credentials.includes(t)||(i&&this.credentials.includes(i)?(i.userId=t.userId,i.token=t.token,i.expires=t.expires,i.validity=t.validity,i.ssl=t.ssl,i.creationTime=t.creationTime,o=!0,t=i):this.credentials.push(t)),t.resources||(t.resources=[]),t.resources.includes(r||s)||t.resources.push(r||s),t.scope=this._isServerRsrc(s)?"server":"portal",t.emitTokenChange();const n=this._soReqs,a={};this._soReqs=[],n.forEach((e=>{if(!this._isIdenticalService(s,e.resUrl_)){const r=this._getSuffix(e.resUrl_);a[r]||(a[r]=!0,t.resources.push(e.resUrl_))}})),e.resolve(t),n.forEach((e=>{this._hasSameServerInstance(this._getServerInstanceRoot(s),e.resUrl_)?e.resolve(t):this._soReqs.push(e)})),this._busy=e.resUrl_=e.sinfo_=e.refresh_=null,o||this.emit("credential-create",{credential:t}),this._soReqs.length?this._doSignIn(this._soReqs.shift()):this._xoReqs.length&&this._doSignIn(this._xoReqs.shift())},r=t=>{e.reject(t),this._busy=e.resUrl_=e.sinfo_=e.refresh_=null,this._soReqs.length?this._doSignIn(this._soReqs.shift()):this._xoReqs.length&&this._doSignIn(this._xoReqs.shift())},s=(o,a,h,l)=>{const d=e.sinfo_,u=!e.options_||!1!==e.options_.prompt,p=d.hasPortal&&this._findOAuthInfo(e.resUrl_);let f,g;if(o)t(new L({userId:o,server:d.server,token:h||null,expires:null!=l?Number(l):null,ssl:!!a}));else if(window!==window.parent&&this._appUrlObj.query?.["arcgis-auth-origin"]&&this._appUrlObj.query?.["arcgis-auth-portal"]&&this._hasSameServerInstance(this._getServerInstanceRoot(this._appUrlObj.query["arcgis-auth-portal"]),e.resUrl_)){window.parent.postMessage({type:"arcgis:auth:requestCredential"},this._appUrlObj.query["arcgis-auth-origin"]);const s=(0,_core_events_js__WEBPACK_IMPORTED_MODULE_6__.on)(window,"message",(e=>{e.source===window.parent&&e.data&&("arcgis:auth:credential"===e.data.type?(s.remove(),e.data.credential.expires<Date.now()?r(new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:credential-request-failed","Parent application's token has expired.")):t(new L(e.data.credential))):"arcgis:auth:error"===e.data.type&&(s.remove(),"tokenExpiredError"===e.data.error.name?r(new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:credential-request-failed","Parent application's token has expired.")):r(_core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"].fromJSON(e.data.error))))}));(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_9__.onAbort)(e.options_?.signal,(()=>{s.remove()}))}else if(p){let o=p._oAuthCred;if(!o){const e=new _OAuthCredential_js__WEBPACK_IMPORTED_MODULE_17__["default"](p,q),t=new _OAuthCredential_js__WEBPACK_IMPORTED_MODULE_17__["default"](p,j);e.isValid()&&t.isValid()?e.expires>t.expires?(o=e,t.destroy()):(o=t,e.destroy()):o=e.isValid()?e:t,p._oAuthCred=o}if(o.isValid()){f=new L({userId:o.userId,server:d.server,token:o.token,expires:o.expires,ssl:o.ssl,_oAuthCred:o});const r=p.appId!==o.appId&&this._doPortalSignIn(e.resUrl_);r||o.refreshToken?(e._pendingDfd=o.refreshToken?this._getOAuthToken(d.server,o.refreshToken,o.appId).then((e=>(f.expires=Date.now()+1e3*e.expires_in,f.token=e.access_token,f))):Promise.resolve(f),e._pendingDfd.then((e=>r?this._exchangeToken(e.server,p.appId,e.token).then((t=>(e.token=t,e))).catch((()=>e)):e)).then((e=>{t(e)})).catch((()=>{o?.destroy(),s()}))):t(f)}else if(this._oAuthLocationParams&&this._hasSameServerInstance(p.portalUrl,this._oAuthLocationParams.state.portalUrl)&&(this._oAuthLocationParams.access_token||this._oAuthLocationParams.code&&this._oAuthLocationParams.state.uid===o.stateUID&&o.codeVerifier)){const s=this._oAuthLocationParams;this._oAuthLocationParams=null,e._pendingDfd=this._processOAuthResponseParams(s,p,d).then((e=>{t(e)})).catch(r)}else{const s=()=>{u?e._pendingDfd=this.oAuthSignIn(e.resUrl_,d,p,e.options_).then(t,r):(g=new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:not-authenticated","User is not signed in."),r(g))};this._doPortalSignIn(e.resUrl_)?e._pendingDfd=this._getPlatformSelf(d.server,p.appId).then((e=>{(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.hasSameOrigin)(e.portalUrl,this._appOrigin,!0)?(f=new L({userId:e.username,server:d.server,expires:Date.now()+1e3*e.expires_in,token:e.token}),t(f)):s()})).catch(s):s()}}else if(u){if(this._checkProtocol(e.resUrl_,d,r,e.admin_)){let s=e.options_;e.admin_&&(s=s||{},s.isAdmin=!0),e._pendingDfd=this.signIn(e.resUrl_,d,s).then(t,r)}}else g=new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:not-authenticated","User is not signed in."),r(g)},o=()=>{const s=e.sinfo_,i=s.owningSystemUrl,o=e.options_;let n,a,h,l;if(o&&(n=o.token,a=o.error,h=o.prompt),l=this._findCredential(i,{token:n,resource:e.resUrl_}),!l)for(const e of this.credentials)if(this._isIdProvider(i,e.server)){l=e;break}if(l){const i=this.findCredential(e.resUrl_,l.userId);if(i)t(i);else if(D(s,this._legacyFed)){const e=l.toJSON();e.server=s.server,e.resources=null,t(new L(e))}else{(e._pendingDfd=this.generateToken(this.findServerInfo(l.server),null,{serverUrl:e.resUrl_,token:l.token,signal:e.options_.signal,ssl:l.ssl})).then((r=>{t(new L({userId:l?.userId,server:s.server,token:r.token,expires:null!=r.expires?Number(r.expires):null,ssl:!!r.ssl,isAdmin:e.admin_,validity:r.validity}))}),r)}}else{this._busy=null,n&&(e.options_.token=null);(e._pendingDfd=this.getCredential(i.replace(/\/?$/,"/sharing"),{resource:e.resUrl_,owningTenant:s.owningTenant,signal:e.options_.signal,token:n,error:a,prompt:h})).then((()=>{this._enqueue(e.resUrl_,e.sinfo_,e.options_,e,e.admin_)}),(t=>{e.resUrl_=e.sinfo_=e.refresh_=null,e.reject(t)}))}};this._errbackFunc=r;const a=e.sinfo_.owningSystemUrl,l=this._isServerRsrc(e.resUrl_),d=e.sinfo_._restInfoPms;d?d.promise.then((t=>{const r=e.sinfo_;if(r._restInfoPms){r.adminTokenServiceUrl=r._restInfoPms.adminUrl,r._restInfoPms=null,r.tokenServiceUrl=((0,_core_object_js__WEBPACK_IMPORTED_MODULE_8__.getDeepValue)("authInfo.tokenServicesUrl",t)||(0,_core_object_js__WEBPACK_IMPORTED_MODULE_8__.getDeepValue)("authInfo.tokenServiceUrl",t)||(0,_core_object_js__WEBPACK_IMPORTED_MODULE_8__.getDeepValue)("tokenServiceUrl",t))??null,r.shortLivedTokenValidity=(0,_core_object_js__WEBPACK_IMPORTED_MODULE_8__.getDeepValue)("authInfo.shortLivedTokenValidity",t)??null,r.currentVersion=t.currentVersion,r.owningTenant=t.owningTenant;const e=r.owningSystemUrl=t.owningSystemUrl;e&&this._portals.push(e)}l&&r.owningSystemUrl?o():s()}),(()=>{e.sinfo_._restInfoPms=null;const t=new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:server-identification-failed","Unknown resource - could not find token service endpoint.");r(t)})):l&&a?o():e.sinfo_._selfReq?e.sinfo_._selfReq.selfDfd.then((t=>{const r={};let s,i,o,n;return t&&(s=t.user&&t.user.username,r.username=s,r.allSSL=t.allSSL,i=t.supportsOAuth,n=parseFloat(t.currentVersion),"multitenant"===t.portalMode&&(o=t.customBaseUrl),e.sinfo_.currentVersion=n),e.sinfo_.webTierAuth=!!s,s&&this.normalizeWebTierAuth?this.generateToken(e.sinfo_,null,{ssl:r.allSSL}).catch((()=>null)).then((e=>(r.portalToken=e&&e.token,r.tokenExpiration=e&&e.expires,r))):!s&&i&&n>=4.4&&!this._findOAuthInfo(e.resUrl_)?this._generateOAuthInfo({portalUrl:e.sinfo_.server,customBaseUrl:o,owningTenant:e.sinfo_._selfReq.owningTenant}).catch((()=>null)).then((()=>r)):r})).catch((()=>null)).then((t=>{e.sinfo_._selfReq=null,t?s(t.username,t.allSSL,t.portalToken,t.tokenExpiration):s()})):s()}_generateOAuthInfo(e){let t,r=null,i=e.portalUrl;const o=e.customBaseUrl,n=e.owningTenant,a=!this._defaultOAuthInfo&&this._createDefaultOAuthInfo&&!this._hasTestedIfAppIsOnPortal;if(a){r=window.location.href;let e=r.indexOf("?");e>-1&&(r=r.slice(0,e)),e=r.search(/\/(apps|home)\//),r=e>-1?r.slice(0,e):null}return a&&r?(this._hasTestedIfAppIsOnPortal=!0,t=(0,_request_js__WEBPACK_IMPORTED_MODULE_3__["default"])(r+"/sharing/rest",{query:{f:"json"}}).then((()=>{this._defaultOAuthInfo=new _OAuthInfo_js__WEBPACK_IMPORTED_MODULE_18__["default"]({appId:"arcgisonline",popupCallbackUrl:r+"/home/oauth-callback.html"})}))):t=Promise.resolve(),t.then((()=>{if(this._defaultOAuthInfo)return i=i.replace(/^http:/i,"https:"),(0,_request_js__WEBPACK_IMPORTED_MODULE_3__["default"])(i+"/sharing/rest/oauth2/validateRedirectUri",{query:{accountId:n,client_id:this._defaultOAuthInfo.appId,redirect_uri:(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.makeAbsolute)(this._defaultOAuthInfo.popupCallbackUrl),f:"json"}}).then((e=>{if(e.data.valid){const t=this._defaultOAuthInfo.clone();e.data.urlKey&&o?t.portalUrl="https://"+e.data.urlKey.toLowerCase()+"."+o:t.portalUrl=i,t.popup=window!==window.top||!((0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.hasSameOrigin)(i,this._appOrigin)||this._gwDomains.some((e=>e.regex.test(i)&&e.regex.test(this._appOrigin)))),this.oAuthInfos.push(t)}}))}))}_doOAuthSignIn(e,t,r,s){const o=r._oAuthCred,a={portalUrl:r.portalUrl};!r.popup&&r.preserveUrlHash&&window.location.hash&&(a.hash=window.location.hash),o.stateUID&&(a.uid=o.stateUID);const h={client_id:r.appId,response_type:o.codeVerifier?"code":"token",state:JSON.stringify(a),expiration:r.expiration,locale:r.locale,redirect_uri:this._getRedirectURI(r,!!o.codeVerifier)};r.forceLogin&&(h.force_login=!0),r.forceUserId&&r.userId&&(h.prepopulatedusername=r.userId),!r.popup&&this._doPortalSignIn(e)&&(h.redirectToUserOrgUrl=!0),o.codeVerifier&&(h.code_challenge=s||o.codeVerifier,h.code_challenge_method=s?"S256":"plain");const l=r.portalUrl.replace(/^http:/i,"https:")+"/sharing/oauth2/authorize",c=l+"?"+(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.objectToQuery)(h);if(r.popup){const e=window.open(c,"esriJSAPIOAuth",r.popupWindowFeatures);if(e)e.focus(),this._oAuthDfd.oAuthWin_=e,this._oAuthIntervalId=setInterval((()=>{if(e.closed){clearInterval(this._oAuthIntervalId),this._oAuthOnPopupHandle.remove();const e=this._oAuthDfd;if(e){const t=new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:user-aborted","ABORTED");e.reject(t)}}}),500),this._oAuthOnPopupHandle=(0,_core_events_js__WEBPACK_IMPORTED_MODULE_6__.on)(window,["arcgis:auth:hash","arcgis:auth:location:search"],(e=>{"arcgis:auth:hash"===e.type?this.setOAuthResponseHash(e.detail):this._setOAuthResponseQueryString(e.detail)}));else{const e=new _core_Error_js__WEBPACK_IMPORTED_MODULE_4__["default"]("identity-manager:popup-blocked","ABORTED");this._oAuthDfd.reject(e)}}else this._rejectOnPersistedPageShow=!0,this._oAuthRedirectFunc?this._oAuthRedirectFunc({authorizeParams:h,authorizeUrl:l,resourceUrl:e,serverInfo:t,oAuthInfo:r}):window.location.href=c}_getRedirectURI(e,t){const r=window.location.href.replace(/#.*$/,"");if(e.popup)return (0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.makeAbsolute)(e.popupCallbackUrl);if(t){const e=(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.urlToObject)(r);return e.query&&["code","error","error_description","message_code","persist","state"].forEach((t=>{delete e.query[t]})),(0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_11__.addQueryParameters)(e.path,e.query)}return r}}E.prototype.declaredClass="esri.identity.IdentityManagerBase";let L=class extends _core_Evented_js__WEBPACK_IMPORTED_MODULE_5__["default"].EventedAccessor{constructor(e){super(e),this._oAuthCred=null,this.tokenRefreshBuffer=2,e&&e._oAuthCred&&(this._oAuthCred=e._oAuthCred)}initialize(){this.resources=this.resources||[],null==this.creationTime&&(this.creationTime=Date.now())}refreshToken(){const e=_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.findServerInfo(this.server),t=e&&e.owningSystemUrl,s=!!t&&"server"===this.scope,i=s&&D(e,_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id._legacyFed),o=e.webTierAuth,n=o&&_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.normalizeWebTierAuth,a=C[this.server],h=a&&a[this.userId];let l,c=this.resources&&this.resources[0],d=s?_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.findServerInfo(t):null,u={username:this.userId,password:h};if(o&&!n)return;s&&!d&&_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.serverInfos.some((e=>(_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id._isIdProvider(t,e.server)&&(d=e),!!d)));const p=d?_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.findCredential(d.server,this.userId):null;if(!s||p){if(!i){if(s)l={serverUrl:c,token:p&&p.token,ssl:p&&p.ssl};else if(n)u=null,l={ssl:this.ssl};else{if(!h){let t;return c&&(c=_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id._sanitizeUrl(c),this._enqueued=1,t=_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id._enqueue(c,e,null,null,this.isAdmin,this),t.then((()=>{this._enqueued=0,this.refreshServerTokens()})).catch((()=>{this._enqueued=0}))),t}this.isAdmin&&(l={isAdmin:!0})}return _kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.generateToken(s?d:e,s?null:u,l).then((e=>{this.token=e.token,this.expires=null!=e.expires?Number(e.expires):null,this.creationTime=Date.now(),this.validity=e.validity,this.emitTokenChange(),this.refreshServerTokens()})).catch((()=>{}))}p?.refreshToken()}}refreshServerTokens(){"portal"===this.scope&&_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.credentials.forEach((e=>{const t=_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.findServerInfo(e.server),s=t&&t.owningSystemUrl;e!==this&&e.userId===this.userId&&s&&"server"===e.scope&&(_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id._hasSameServerInstance(this.server,s)||_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id._isIdProvider(s,this.server))&&(D(t,_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id._legacyFed)?(e.token=this.token,e.expires=this.expires,e.creationTime=this.creationTime,e.validity=this.validity,e.emitTokenChange()):e.refreshToken())}))}emitTokenChange(e){clearTimeout(this._refreshTimer);const t=this.server&&_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.findServerInfo(this.server),s=t&&t.owningSystemUrl,i=s&&_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.findServerInfo(s);!1===e||s&&"portal"!==this.scope&&(!i||!i.webTierAuth||_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.normalizeWebTierAuth)||null==this.expires&&null==this.validity||this._startRefreshTimer(),this.emit("token-change")}destroy(){this.userId=this.server=this.token=this.expires=this.validity=this.resources=this.creationTime=null,this._oAuthCred&&(this._oAuthCred.destroy(),this._oAuthCred=null);const e=_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.credentials.indexOf(this);e>-1&&_kernel_js__WEBPACK_IMPORTED_MODULE_2__.id.credentials.splice(e,1),this.emitTokenChange(),this.emit("destroy")}toJSON(){const e=(0,_core_lang_js__WEBPACK_IMPORTED_MODULE_7__.fixJson)({userId:this.userId,server:this.server,token:this.token,expires:this.expires,validity:this.validity,ssl:this.ssl,isAdmin:this.isAdmin,creationTime:this.creationTime,scope:this.scope}),t=this.resources;return t&&t.length>0&&(e.resources=t.slice()),e}_startRefreshTimer(){clearTimeout(this._refreshTimer);const e=6e4*this.tokenRefreshBuffer,t=2**31-1;let r=(this.validity?this.creationTime+6e4*this.validity:this.expires)-Date.now();r<0?r=0:r>t&&(r=t),this._refreshTimer=setTimeout(this.refreshToken.bind(this),r>e?r-e:r)}};(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__.property)()],L.prototype,"creationTime",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__.property)()],L.prototype,"expires",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__.property)()],L.prototype,"isAdmin",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__.property)()],L.prototype,"oAuthState",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__.property)()],L.prototype,"resources",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__.property)()],L.prototype,"scope",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__.property)()],L.prototype,"server",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__.property)()],L.prototype,"ssl",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__.property)()],L.prototype,"token",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__.property)()],L.prototype,"tokenRefreshBuffer",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__.property)()],L.prototype,"userId",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_12__.property)()],L.prototype,"validity",void 0),L=(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_14__.subclass)("esri.identity.Credential")],L);


/***/ }),

/***/ "./node_modules/@arcgis/core/identity/IdentityModal.js":
/*!*************************************************************!*\
  !*** ./node_modules/@arcgis/core/identity/IdentityModal.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ h)
/* harmony export */ });
/* harmony import */ var _chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunks/tslib.es6.js */ "./node_modules/@arcgis/core/chunks/tslib.es6.js");
/* harmony import */ var _core_handleUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/handleUtils.js */ "./node_modules/@arcgis/core/core/handleUtils.js");
/* harmony import */ var _core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/reactiveUtils.js */ "./node_modules/@arcgis/core/core/reactiveUtils.js");
/* harmony import */ var _core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/accessorSupport/decorators/property.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/property.js");
/* harmony import */ var _core_accessorSupport_ensureType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/accessorSupport/ensureType.js */ "./node_modules/@arcgis/core/core/accessorSupport/ensureType.js");
/* harmony import */ var _core_arrayUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/arrayUtils.js */ "./node_modules/@arcgis/core/core/arrayUtils.js");
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/accessorSupport/decorators/subclass.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/subclass.js");
/* harmony import */ var _widgets_Widget_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../widgets/Widget.js */ "./node_modules/@arcgis/core/widgets/Widget.js");
/* harmony import */ var _widgets_support_widget_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../widgets/support/widget.js */ "./node_modules/@arcgis/core/widgets/support/widget.js");
/* harmony import */ var focus_trap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! focus-trap */ "./node_modules/focus-trap/dist/focus-trap.esm.js");
/* harmony import */ var _widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../widgets/support/jsxFactory.js */ "./node_modules/@arcgis/core/widgets/support/jsxFactory.js");
/* harmony import */ var _widgets_support_decorators_messageBundle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../widgets/support/decorators/messageBundle.js */ "./node_modules/@arcgis/core/widgets/support/decorators/messageBundle.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const d="esri-identity-modal",p={base:d,open:`${d}--open`,closed:`${d}--closed`,title:`${d}__title`,dialog:`${d}__dialog`,content:`${d}__content`,closeButton:`${d}__close-button`,iconClose:"esri-icon-close"};let u=class extends _widgets_Widget_js__WEBPACK_IMPORTED_MODULE_8__["default"]{constructor(t,e){super(t,e),this.container=document.createElement("div"),this.content=null,this.open=!1,this._focusTrap=null,this._close=()=>{this.open=!1},document.body.appendChild(this.container),this.addHandles((0,_core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_2__.watch)((()=>this.open),(()=>this._toggleFocusTrap())))}destroy(){this._destroyFocusTrap()}get title(){return this.messages?.auth.signIn}render(){const t=this.id,{open:e,content:o,title:s,messages:i}=this,r=e&&!!o,n={[p.open]:r,[p.closed]:!r},a=(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("button",{class:p.closeButton,"aria-label":i.close,title:i.close,bind:this,onclick:this._close,type:"button"},(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("span",{"aria-hidden":"true",class:p.iconClose})),l=`${t}_title`,d=`${t}_content`,u=s?(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("h1",{id:l,class:p.title},s):null,h=r?(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("div",{bind:this,class:p.dialog,role:"dialog","aria-labelledby":l,"aria-describedby":d,afterCreate:this._createFocusTrap},a,u,this._renderContent(d)):null;return (0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("div",{tabIndex:-1,class:this.classes(p.base,n)},h)}_destroyFocusTrap(){this._focusTrap?.deactivate({onDeactivate:()=>{}}),this._focusTrap=null}_toggleFocusTrap(){const{_focusTrap:t,open:e}=this;t&&(e?t.activate():t.deactivate())}_createFocusTrap(t){this._destroyFocusTrap();const o=requestAnimationFrame((()=>{this._focusTrap=(0,focus_trap__WEBPACK_IMPORTED_MODULE_12__.createFocusTrap)(t,{initialFocus:"input",onDeactivate:this._close}),this._toggleFocusTrap()}));this.addHandles((0,_core_handleUtils_js__WEBPACK_IMPORTED_MODULE_1__.makeHandle)((()=>cancelAnimationFrame(o))))}_renderContent(t){const e=this.content;return"string"==typeof e?(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("div",{class:p.content,id:t,innerHTML:e}):(0,_widgets_support_widget_js__WEBPACK_IMPORTED_MODULE_9__.isWidget)(e)?(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("div",{class:p.content,id:t},e.render()):e instanceof HTMLElement?(0,_widgets_support_jsxFactory_js__WEBPACK_IMPORTED_MODULE_10__.tsx)("div",{class:p.content,id:t,bind:e,afterCreate:this._attachToNode}):null}_attachToNode(t){const e=this;t.appendChild(e)}};(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_3__.property)({readOnly:!0})],u.prototype,"container",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_3__.property)()],u.prototype,"content",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_3__.property)()],u.prototype,"open",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_3__.property)(),(0,_widgets_support_decorators_messageBundle_js__WEBPACK_IMPORTED_MODULE_11__.messageBundle)("esri/t9n/common")],u.prototype,"messages",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_3__.property)()],u.prototype,"title",null),u=(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_7__.subclass)("esri.identity.IdentityModal")],u);const h=u;


/***/ }),

/***/ "./node_modules/@arcgis/core/identity/OAuthCredential.js":
/*!***************************************************************!*\
  !*** ./node_modules/@arcgis/core/identity/OAuthCredential.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const t="esriJSAPIOAuth";class e{constructor(t,e){this.oAuthInfo=null,this.storage=null,this.appId=null,this.codeVerifier=null,this.expires=null,this.refreshToken=null,this.ssl=null,this.stateUID=null,this.token=null,this.userId=null,this.oAuthInfo=t,this.storage=e,this._init()}isValid(){let t=!1;if(this.oAuthInfo&&this.userId&&(this.refreshToken||this.token))if(null==this.expires&&this.refreshToken)t=!0;else if(this.expires){const e=Date.now();if(this.expires>e){(this.expires-e)/1e3>60*this.oAuthInfo.minTimeUntilExpiration&&(t=!0)}}return t}save(){if(!this.storage)return!1;const e=this._load(),s=this.oAuthInfo;if(s&&s.authNamespace&&s.portalUrl){let r=e[s.authNamespace];r||(r=e[s.authNamespace]={}),this.appId||(this.appId=s.appId),r[s.portalUrl]={appId:this.appId,codeVerifier:this.codeVerifier,expires:this.expires,refreshToken:this.refreshToken,ssl:this.ssl,stateUID:this.stateUID,token:this.token,userId:this.userId};try{this.storage.setItem(t,JSON.stringify(e))}catch(i){return console.warn(i),!1}return!0}return!1}destroy(){const e=this._load(),s=this.oAuthInfo;if(s&&s.appId&&s.portalUrl&&(null==this.expires||this.expires>Date.now())&&(this.refreshToken||this.token)){const t=s.portalUrl.replace(/^http:/i,"https:")+"/sharing/rest/oauth2/revokeToken",e=new FormData;if(e.append("f","json"),e.append("auth_token",this.refreshToken||this.token),e.append("client_id",s.appId),e.append("token_type_hint",this.refreshToken?"refresh_token":"access_token"),"function"==typeof navigator.sendBeacon)navigator.sendBeacon(t,e);else{const s=new XMLHttpRequest;s.open("POST",t),s.send(e)}}if(s&&s.authNamespace&&s.portalUrl&&this.storage){const r=e[s.authNamespace];if(r){delete r[s.portalUrl];try{this.storage.setItem(t,JSON.stringify(e))}catch(i){console.log(i)}}}s&&(s._oAuthCred=null,this.oAuthInfo=null)}_init(){const t=this._load(),e=this.oAuthInfo;if(e&&e.authNamespace&&e.portalUrl){let s=t[e.authNamespace];s&&(s=s[e.portalUrl],s&&(this.appId=s.appId,this.codeVerifier=s.codeVerifier,this.expires=s.expires,this.refreshToken=s.refreshToken,this.ssl=s.ssl,this.stateUID=s.stateUID,this.token=s.token,this.userId=s.userId))}}_load(){let e={};if(this.storage){const i=this.storage.getItem(t);if(i)try{e=JSON.parse(i)}catch(s){console.warn(s)}}return e}}e.prototype.declaredClass="esri.identity.OAuthCredential";


/***/ }),

/***/ "./node_modules/@arcgis/core/identity/OAuthInfo.js":
/*!*********************************************************!*\
  !*** ./node_modules/@arcgis/core/identity/OAuthInfo.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ i)
/* harmony export */ });
/* harmony import */ var _chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunks/tslib.es6.js */ "./node_modules/@arcgis/core/chunks/tslib.es6.js");
/* harmony import */ var _core_JSONSupport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/JSONSupport.js */ "./node_modules/@arcgis/core/core/JSONSupport.js");
/* harmony import */ var _core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/accessorSupport/decorators/property.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/property.js");
/* harmony import */ var _core_accessorSupport_ensureType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/accessorSupport/ensureType.js */ "./node_modules/@arcgis/core/core/accessorSupport/ensureType.js");
/* harmony import */ var _core_arrayUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/arrayUtils.js */ "./node_modules/@arcgis/core/core/arrayUtils.js");
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/accessorSupport/decorators/subclass.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/subclass.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
var p;let s=p=class extends _core_JSONSupport_js__WEBPACK_IMPORTED_MODULE_1__.JSONSupport{constructor(o){super(o),this._oAuthCred=null,this.appId=null,this.authNamespace="/",this.expiration=20160,this.flowType="auto",this.forceLogin=!1,this.forceUserId=!1,this.locale=null,this.minTimeUntilExpiration=30,this.popup=!1,this.popupCallbackUrl="oauth-callback.html",this.popupWindowFeatures="height=490,width=800,resizable,scrollbars,status",this.portalUrl="https://www.arcgis.com",this.preserveUrlHash=!1,this.userId=null}clone(){return p.fromJSON(this.toJSON())}};(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"appId",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"authNamespace",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"expiration",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"flowType",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"forceLogin",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"forceUserId",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"locale",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"minTimeUntilExpiration",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"popup",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"popupCallbackUrl",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"popupWindowFeatures",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"portalUrl",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"preserveUrlHash",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"userId",void 0),s=p=(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_6__.subclass)("esri.identity.OAuthInfo")],s);const i=s;


/***/ }),

/***/ "./node_modules/@arcgis/core/identity/ServerInfo.js":
/*!**********************************************************!*\
  !*** ./node_modules/@arcgis/core/identity/ServerInfo.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ i)
/* harmony export */ });
/* harmony import */ var _chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunks/tslib.es6.js */ "./node_modules/@arcgis/core/chunks/tslib.es6.js");
/* harmony import */ var _core_JSONSupport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/JSONSupport.js */ "./node_modules/@arcgis/core/core/JSONSupport.js");
/* harmony import */ var _core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/accessorSupport/decorators/property.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/property.js");
/* harmony import */ var _core_accessorSupport_ensureType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/accessorSupport/ensureType.js */ "./node_modules/@arcgis/core/core/accessorSupport/ensureType.js");
/* harmony import */ var _core_arrayUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/arrayUtils.js */ "./node_modules/@arcgis/core/core/arrayUtils.js");
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/accessorSupport/decorators/subclass.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/subclass.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
let s=class extends _core_JSONSupport_js__WEBPACK_IMPORTED_MODULE_1__.JSONSupport{constructor(o){super(o),this.adminTokenServiceUrl=null,this.currentVersion=null,this.hasPortal=null,this.hasServer=null,this.owningSystemUrl=null,this.owningTenant=null,this.server=null,this.shortLivedTokenValidity=null,this.tokenServiceUrl=null,this.webTierAuth=null}};(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"adminTokenServiceUrl",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"currentVersion",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"hasPortal",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"hasServer",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"owningSystemUrl",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"owningTenant",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"server",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"shortLivedTokenValidity",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"tokenServiceUrl",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property)({json:{write:!0}})],s.prototype,"webTierAuth",void 0),s=(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_6__.subclass)("esri.identity.ServerInfo")],s);const i=s;


/***/ }),

/***/ "./node_modules/@arcgis/core/libs/maquette-advanced-projector/advanced-projector-options.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/libs/maquette-advanced-projector/advanced-projector-options.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultAdvancedProjectorOptions": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const e={handleInterceptedEvent:(e,p,t,n)=>(e.scheduleRender(),p.properties[`on${n.type}`].apply(p.properties.bind||t,[n]))};


/***/ }),

/***/ "./node_modules/@arcgis/core/libs/maquette-advanced-projector/projector.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@arcgis/core/libs/maquette-advanced-projector/projector.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAdvancedProjector": () => (/* binding */ s)
/* harmony export */ });
/* harmony import */ var _maquette_dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../maquette/dom.js */ "./node_modules/@arcgis/core/libs/maquette/dom.js");
/* harmony import */ var _maquette_projector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maquette/projector.js */ "./node_modules/@arcgis/core/libs/maquette/projector.js");
/* harmony import */ var _advanced_projector_options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./advanced-projector-options.js */ "./node_modules/@arcgis/core/libs/maquette-advanced-projector/advanced-projector-options.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@arcgis/core/libs/maquette-advanced-projector/utils.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const o=(e,t)=>{const r=[];for(;e&&e!==t;)r.push(e),e=e.parentNode;return r},n=(e,t)=>e.find(t),d=(e,t,r=!1)=>{let o=e;return t.forEach(((e,d)=>{const s=o?.children?n(o.children,(t=>t.domNode===e)):void 0;r&&!s&&d!==t.length-1||(o=s)})),o},s=n=>{let s;const i={..._advanced_projector_options_js__WEBPACK_IMPORTED_MODULE_2__.defaultAdvancedProjectorOptions,...n},c=(0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.applyDefaultProjectionOptions)(i),a=c.performanceLogger;let m,p=!0,l=!1;const f=[],u=[],h=(e,t,r)=>{let n;c.eventHandlerInterceptor=(e,t,r,c)=>function(e){let t;a("domEvent",e);const r=o(e.currentTarget,n.domNode),c=r.some((e=>customElements.get(e?.tagName?.toLowerCase())));if(e.eventPhase===Event.CAPTURING_PHASE||!c)r.reverse(),t=d(n.getLastRender(),r);else{const r=e.composedPath(),o=r.slice(r.indexOf(e.currentTarget),r.indexOf(n.domNode)).filter((e=>e.getRootNode()===e.ownerDocument)).reverse();t=d(n.getLastRender(),o,!0)}let m;return t&&(m=i.handleInterceptedEvent(s,t,this,e)),a("domEventProcessed",e),m},i.postProcessProjectionOptions?.(c);const m=r();n=e(t,m,c),f.push(n),u.push(r),i.afterFirstVNodeRendered&&i.afterFirstVNodeRendered(n,m)};let v=()=>{if(m=void 0,p){p=!1,a("renderStart",void 0);for(let e=0;e<f.length;e++){const t=u[e]();a("rendered",void 0),f[e].update(t),a("patched",void 0)}a("renderDone",void 0),p=!0}};return i.modifyDoRenderImplementation&&(v=i.modifyDoRenderImplementation(v,f,u)),s={renderNow:v,scheduleRender:()=>{m||l||(m=requestAnimationFrame(v))},stop:()=>{m&&(cancelAnimationFrame(m),m=void 0),l=!0},resume:()=>{l=!1,p=!0,s.scheduleRender()},append:(t,r)=>{h(_maquette_dom_js__WEBPACK_IMPORTED_MODULE_0__.dom.append,t,r)},insertBefore:(t,r)=>{h(_maquette_dom_js__WEBPACK_IMPORTED_MODULE_0__.dom.insertBefore,t,r)},merge:(t,r)=>{h(_maquette_dom_js__WEBPACK_IMPORTED_MODULE_0__.dom.merge,t,r)},replace:(t,r)=>{h(_maquette_dom_js__WEBPACK_IMPORTED_MODULE_0__.dom.replace,t,r)},detach:e=>{for(let t=0;t<u.length;t++)if(u[t]===e)return u.splice(t,1),f.splice(t,1)[0];throw new Error("renderFunction was not found")}},s};


/***/ }),

/***/ "./node_modules/@arcgis/core/libs/maquette-advanced-projector/utils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@arcgis/core/libs/maquette-advanced-projector/utils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyDefaultProjectionOptions": () => (/* binding */ r)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const e={namespace:void 0,performanceLogger:()=>{},eventHandlerInterceptor:void 0,styleApplyer:(e,r,o)=>{e.style[r]=o}},r=r=>({...e,...r});


/***/ }),

/***/ "./node_modules/@arcgis/core/libs/maquette/dom.js":
/*!********************************************************!*\
  !*** ./node_modules/@arcgis/core/libs/maquette/dom.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyDefaultProjectionOptions": () => (/* binding */ d),
/* harmony export */   "dom": () => (/* binding */ n)
/* harmony export */ });
/* harmony import */ var _projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./projection.js */ "./node_modules/@arcgis/core/libs/maquette/projection.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const p={namespace:void 0,performanceLogger:()=>{},eventHandlerInterceptor:void 0,styleApplyer:(e,r,o)=>{"-"===r.charAt(0)?e.style.setProperty(r,o):e.style[r]=o}};let d=r=>(0,_projection_js__WEBPACK_IMPORTED_MODULE_0__.extend)(p,r),n={create:(e,t)=>(t=d(t),(0,_projection_js__WEBPACK_IMPORTED_MODULE_0__.createDom)(e,document.createElement("div"),void 0,t),(0,_projection_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(e,t)),append:(e,t,p)=>(p=d(p),(0,_projection_js__WEBPACK_IMPORTED_MODULE_0__.createDom)(t,e,void 0,p),(0,_projection_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(t,p)),insertBefore:(e,t,p)=>(p=d(p),(0,_projection_js__WEBPACK_IMPORTED_MODULE_0__.createDom)(t,e.parentNode,e,p),(0,_projection_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(t,p)),merge:(e,r,p)=>(p=d(p),r.domNode=e,(0,_projection_js__WEBPACK_IMPORTED_MODULE_0__.initPropertiesAndChildren)(e,r,p),(0,_projection_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(r,p)),replace:(e,t,p)=>(p=d(p),(0,_projection_js__WEBPACK_IMPORTED_MODULE_0__.createDom)(t,e.parentNode,e,p),e.parentNode.removeChild(e),(0,_projection_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(t,p))};


/***/ }),

/***/ "./node_modules/@arcgis/core/libs/maquette/projection.js":
/*!***************************************************************!*\
  !*** ./node_modules/@arcgis/core/libs/maquette/projection.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDom": () => (/* binding */ x),
/* harmony export */   "createProjection": () => (/* binding */ C),
/* harmony export */   "extend": () => (/* binding */ n),
/* harmony export */   "initPropertiesAndChildren": () => (/* binding */ w)
/* harmony export */ });
/* harmony import */ var _widgets_support_widgetUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../widgets/support/widgetUtils.js */ "./node_modules/@arcgis/core/widgets/support/widgetUtils.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const t="http://www.w3.org/",r=`${t}2000/svg`,o=`${t}1999/xlink`;let i=[],n=(e,t)=>{let r={};return Object.keys(e).forEach((t=>{r[t]=e[t]})),t&&Object.keys(t).forEach((e=>{r[e]=t[e]})),r},s=(e,t)=>e.vnodeSelector===t.vnodeSelector&&(e.properties&&t.properties?e.properties.key===t.properties.key&&e.properties.bind===t.properties.bind:!e.properties&&!t.properties),l=e=>{if("string"!=typeof e)throw new Error("Style values must be strings")},p=(e,t,r)=>{if(""!==t.vnodeSelector)for(let o=r;o<e.length;o++)if(s(e[o],t))return o;return-1},d=(e,t,r,o)=>{let i=e[t];if(""===i.vnodeSelector)return;let n=i.properties;if(!(n?void 0===n.key?n.bind:n.key:void 0))for(let l=0;l<e.length;l++)if(l!==t){let t=e[l];if(s(t,i))throw new Error(`${r.vnodeSelector} had a ${i.vnodeSelector} child ${"added"===o?o:"removed"}, but there is now more than one. You must add unique key properties to make them distinguishable.`)}},a=e=>{if(e.properties){let t=e.properties.enterAnimation;t&&t(e.domNode,e.properties)}},f=[],c=!1,u=e=>{(e.children||[]).forEach(u),e.properties&&e.properties.afterRemoved&&e.properties.afterRemoved.apply(e.properties.bind||e.properties,[e.domNode])},m=()=>{c=!1,f.forEach(u),f.length=0},h=e=>{f.push(e),c||(c=!0,"undefined"!=typeof window&&"requestIdleCallback"in window?window.requestIdleCallback(m,{timeout:16}):setTimeout(m,16))},v=e=>{let t=e.domNode;if(e.properties){let r=e.properties.exitAnimation;if(r){t.style.pointerEvents="none";let o=()=>{t.parentNode&&(t.parentNode.removeChild(t),h(e))};return void r(t,o,e.properties)}}t.parentNode&&(t.parentNode.removeChild(t),h(e))},y=(t,i,n)=>{if(!i)return;let s=n.eventHandlerInterceptor,p=Object.keys(i),d=p.length;for(let a=0;a<d;a++){let d=p[a],f=i[d];if("className"===d)throw new Error('Property "className" is not supported, use "class".');if("class"===d)k(t,f,!0);else if("classes"===d){let e=Object.keys(f),r=e.length;for(let o=0;o<r;o++){let r=e[o];f[r]&&t.classList.add(r)}}else if("styles"===d){let e=Object.keys(f),r=e.length;for(let o=0;o<r;o++){let r=e[o],i=f[r];i&&(l(i),n.styleApplyer(t,r,i))}}else if("key"!==d&&null!=f){let l=typeof f;"function"===l?(0===d.lastIndexOf("on",0)&&(s&&(f=s(d,f,t,i)),"oninput"===d&&function(){let e=f;f=function(t){e.apply(this,[t]),t.target["oninput-value"]=t.target.value}}()),t[d]=f):n.namespace===r?"href"===d?t.setAttributeNS(o,d,f):t.setAttribute(d,f):"string"===l&&"value"!==d?"innerHTML"===d?t[d]=_widgets_support_widgetUtils_js__WEBPACK_IMPORTED_MODULE_0__.renderingSanitizer.sanitize(f):g(t)&&d in t?t[d]=f:t.setAttribute(d,f):t[d]=f}}};function g(e){if(!(e instanceof Element&&e.tagName.includes("-")))return!1;const t=window.customElements.get(e.tagName.toLowerCase());return!!t&&e instanceof t}let N,b=(e,t,r)=>{if(t)for(let o of t)x(o,e,void 0,r)},w=(e,t,r)=>{b(e,t.children,r),t.text&&(e.textContent=t.text),y(e,t.properties,r),t.properties&&t.properties.afterCreate&&t.properties.afterCreate.apply(t.properties.bind||t.properties,[e,r,t.vnodeSelector,t.properties,t.children])},x=(e,t,o,i)=>{let s,l=0,p=e.vnodeSelector,d=t.ownerDocument;if(""===p)s=e.domNode=d.createTextNode(e.text),void 0!==o?t.insertBefore(s,o):t.appendChild(s);else{for(let a=0;a<=p.length;++a){let f=p.charAt(a);if(a===p.length||"."===f||"#"===f){let f=p.charAt(l-1),c=p.slice(l,a);"."===f?s.classList.add(c):"#"===f?s.id=c:("svg"===c&&(i=n(i,{namespace:r})),void 0!==i.namespace?s=e.domNode=d.createElementNS(i.namespace,c):(s=e.domNode=e.domNode||d.createElement(c),"input"===c&&e.properties&&void 0!==e.properties.type&&s.setAttribute("type",e.properties.type)),void 0!==o?t.insertBefore(s,o):s.parentNode!==t&&t.appendChild(s)),l=a+1}}w(s,e,i)}},k=(e,t,r)=>{t&&t.split(" ").forEach((t=>{t&&e.classList.toggle(t,r)}))},A=(t,i,n,s)=>{if(!n)return;let p=!1,d=Object.keys(n),a=d.length;for(let f=0;f<a;f++){let a=d[f],c=n[a],u=i[a];if("class"===a)u!==c&&(k(t,u,!1),k(t,c,!0));else if("classes"===a){let e=t.classList,r=Object.keys(c),o=r.length;for(let t=0;t<o;t++){let o=r[t],i=!!c[o];i!==!!u[o]&&(p=!0,i?e.add(o):e.remove(o))}}else if("styles"===a){let e=Object.keys(c),r=e.length;for(let o=0;o<r;o++){let r=e[o],i=c[r];i!==u[r]&&(p=!0,i?(l(i),s.styleApplyer(t,r,i)):s.styleApplyer(t,r,""))}}else if(c||"string"!=typeof u||(c=""),"value"===a){let e=t[a];e!==c&&(t["oninput-value"]?e===t["oninput-value"]:c!==u)&&(t[a]=c,t["oninput-value"]=void 0),c!==u&&(p=!0)}else if(c!==u){let i=typeof c;"function"===i&&s.eventHandlerInterceptor||(s.namespace===r?"href"===a?t.setAttributeNS(o,a,c):t.setAttribute(a,c):"string"===i?"innerHTML"===a?t[a]=_widgets_support_widgetUtils_js__WEBPACK_IMPORTED_MODULE_0__.renderingSanitizer.sanitize(c):"role"===a&&""===c?t.removeAttribute(a):g(t)&&a in t?t[a]=c:t.setAttribute(a,c):t[a]!==c&&(t[a]=c),p=!0)}}return p},S=(e,t,r,o,n)=>{if(r===o)return!1;o=o||i;let l,f=(r=r||i).length,c=o.length,u=0,m=0,h=!1;for(;m<c;){let i=u<f?r[u]:void 0,c=o[m];if(void 0!==i&&s(i,c))h=N(i,c,n)||h,u++;else{let i=p(r,c,u+1);if(i>=0){for(l=u;l<i;l++)v(r[l]),d(r,l,e,"removed");h=N(r[i],c,n)||h,u=i+1}else x(c,t,u<f?r[u].domNode:void 0,n),a(c),d(o,m,e,"added")}m++}if(f>u)for(l=u;l<f;l++)v(r[l]),d(r,l,e,"removed");return h};N=(e,t,o)=>{let i=e.domNode,s=!1;if(e===t)return!1;let l=!1;if(""===t.vnodeSelector){if(t.text!==e.text){let e=i.ownerDocument.createTextNode(t.text);return i.parentNode.replaceChild(e,i),t.domNode=e,s=!0,s}t.domNode=i}else 0===t.vnodeSelector.lastIndexOf("svg",0)&&(o=n(o,{namespace:r})),e.text!==t.text&&(l=!0,void 0===t.text?i.removeChild(i.firstChild):i.textContent=t.text),t.domNode=i,l=S(t,i,e.children,t.children,o)||l,l=A(i,e.properties,t.properties,o)||l,t.properties&&t.properties.afterUpdate&&t.properties.afterUpdate.apply(t.properties.bind||t.properties,[i,o,t.vnodeSelector,t.properties,t.children]);return l&&t.properties&&t.properties.updateAnimation&&t.properties.updateAnimation(i,t.properties,e.properties),s};let C=(e,t)=>({getLastRender:()=>e,update:r=>{if(e.vnodeSelector!==r.vnodeSelector)throw new Error("The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)");let o=e;e=r,N(o,r,t)},domNode:e.domNode});


/***/ }),

/***/ "./node_modules/@arcgis/core/libs/maquette/projector.js":
/*!**************************************************************!*\
  !*** ./node_modules/@arcgis/core/libs/maquette/projector.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createProjector": () => (/* binding */ i)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@arcgis/core/libs/maquette/dom.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
let t,n=(e,r)=>{let t=[];for(;e&&e!==r;)t.push(e),e=e.parentNode;return t};t=Array.prototype.find?(e,r)=>e.find(r):(e,r)=>e.filter(r)[0];let o=(e,r)=>{let n=e;return r.forEach((e=>{n=n&&n.children?t(n.children,(r=>r.domNode===e)):void 0})),n},d=(e,r,t)=>{let d=function(d){t("domEvent",d);let i=r(),p=n(d.currentTarget,i.domNode);p.reverse();let l,a=o(i.getLastRender(),p);return e.scheduleRender(),a&&(l=a.properties[`on${d.type}`].apply(a.properties.bind||this,arguments)),t("domEventProcessed",d),l};return(e,r,t,n)=>d},i=t=>{let n,o,i=(0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.applyDefaultProjectionOptions)(t),p=i.performanceLogger,l=!0,a=!1,s=[],c=[],u=(e,r,t)=>{let o,l=()=>o;i.eventHandlerInterceptor=d(n,l,p),o=e(r,t(),i),s.push(o),c.push(t)},f=()=>{if(o=void 0,l){l=!1,p("renderStart",void 0);for(let e=0;e<s.length;e++){let r=c[e]();p("rendered",void 0),s[e].update(r),p("patched",void 0)}p("renderDone",void 0),l=!0}};return n={renderNow:f,scheduleRender:()=>{o||a||(o=requestAnimationFrame(f))},stop:()=>{o&&(cancelAnimationFrame(o),o=void 0),a=!0},resume:()=>{a=!1,l=!0,n.scheduleRender()},append:(e,t)=>{u(_dom_js__WEBPACK_IMPORTED_MODULE_0__.dom.append,e,t)},insertBefore:(e,t)=>{u(_dom_js__WEBPACK_IMPORTED_MODULE_0__.dom.insertBefore,e,t)},merge:(e,t)=>{u(_dom_js__WEBPACK_IMPORTED_MODULE_0__.dom.merge,e,t)},replace:(e,t)=>{u(_dom_js__WEBPACK_IMPORTED_MODULE_0__.dom.replace,e,t)},detach:e=>{for(let r=0;r<c.length;r++)if(c[r]===e)return c.splice(r,1),s.splice(r,1)[0];throw new Error("renderFunction was not found")}},n};


/***/ }),

/***/ "./node_modules/@arcgis/core/support/themeUtils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@arcgis/core/support/themeUtils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCalciteThemeClass": () => (/* binding */ c),
/* harmony export */   "isDarkTheme": () => (/* binding */ r),
/* harmony export */   "setCalciteThemeClass": () => (/* binding */ n)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const t="calcite-mode-";function e(){return getComputedStyle(document.body).getPropertyValue("--esri-calcite-mode-name").replaceAll(/\s|'|"/g,"")}function r(){return e().startsWith("dark")}function c(){return`${t}${r()?"dark":"light"}`}function n(t){o(t),t.classList.add(c())}function o(e){Array.from(e.classList).forEach((r=>{r.startsWith(t)&&e.classList.remove(r)}))}


/***/ }),

/***/ "./node_modules/@arcgis/core/widgets/Widget.js":
/*!*****************************************************!*\
  !*** ./node_modules/@arcgis/core/widgets/Widget.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ W)
/* harmony export */ });
/* harmony import */ var _chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunks/tslib.es6.js */ "./node_modules/@arcgis/core/chunks/tslib.es6.js");
/* harmony import */ var _intl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../intl.js */ "./node_modules/@arcgis/core/intl.js");
/* harmony import */ var _core_domUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/domUtils.js */ "./node_modules/@arcgis/core/core/domUtils.js");
/* harmony import */ var _core_Evented_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Evented.js */ "./node_modules/@arcgis/core/core/Evented.js");
/* harmony import */ var _core_events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/events.js */ "./node_modules/@arcgis/core/core/events.js");
/* harmony import */ var _core_Handles_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Handles.js */ "./node_modules/@arcgis/core/core/Handles.js");
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _core_lang_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/lang.js */ "./node_modules/@arcgis/core/core/lang.js");
/* harmony import */ var _core_Logger_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/Logger.js */ "./node_modules/@arcgis/core/core/Logger.js");
/* harmony import */ var _core_maybe_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/maybe.js */ "./node_modules/@arcgis/core/core/maybe.js");
/* harmony import */ var _core_Promise_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/Promise.js */ "./node_modules/@arcgis/core/core/Promise.js");
/* harmony import */ var _core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../core/promiseUtils.js */ "./node_modules/@arcgis/core/core/promiseUtils.js");
/* harmony import */ var _core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../core/reactiveUtils.js */ "./node_modules/@arcgis/core/core/reactiveUtils.js");
/* harmony import */ var _core_uuid_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../core/uuid.js */ "./node_modules/@arcgis/core/core/uuid.js");
/* harmony import */ var _core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../core/accessorSupport/decorators/property.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/property.js");
/* harmony import */ var _core_accessorSupport_decorators_cast_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../core/accessorSupport/decorators/cast.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/cast.js");
/* harmony import */ var _core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../core/accessorSupport/decorators/subclass.js */ "./node_modules/@arcgis/core/core/accessorSupport/decorators/subclass.js");
/* harmony import */ var _core_accessorSupport_tracking_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../core/accessorSupport/tracking.js */ "./node_modules/@arcgis/core/core/accessorSupport/tracking.js");
/* harmony import */ var _core_accessorSupport_tracking_SimpleTrackingTarget_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../core/accessorSupport/tracking/SimpleTrackingTarget.js */ "./node_modules/@arcgis/core/core/accessorSupport/tracking/SimpleTrackingTarget.js");
/* harmony import */ var _libs_maquette_advanced_projector_projector_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../libs/maquette-advanced-projector/projector.js */ "./node_modules/@arcgis/core/libs/maquette-advanced-projector/projector.js");
/* harmony import */ var _support_componentsUtils_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./support/componentsUtils.js */ "./node_modules/@arcgis/core/widgets/support/componentsUtils.js");
/* harmony import */ var _support_jsxWidgetSupport_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./support/jsxWidgetSupport.js */ "./node_modules/@arcgis/core/widgets/support/jsxWidgetSupport.js");
/* harmony import */ var _support_symbols_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./support/symbols.js */ "./node_modules/@arcgis/core/widgets/support/symbols.js");
/* harmony import */ var _support_tests_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./support/tests.js */ "./node_modules/@arcgis/core/widgets/support/tests.js");
/* harmony import */ var _support_vnodeCache_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./support/vnodeCache.js */ "./node_modules/@arcgis/core/widgets/support/vnodeCache.js");
/* harmony import */ var _support_widgetUtils_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./support/widgetUtils.js */ "./node_modules/@arcgis/core/widgets/support/widgetUtils.js");
/* harmony import */ var _intl_locale_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../intl/locale.js */ "./node_modules/@arcgis/core/intl/locale.js");
/* harmony import */ var _intl_messages_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../intl/messages.js */ "./node_modules/@arcgis/core/intl/messages.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
var $;const z="esri.widgets.Widget";let x=0;const A={widgetIcon:"esri-icon-checkbox-unchecked"};function B(e,t){for(const r in t)null!=e[r]&&("object"==typeof e[r]&&"object"==typeof t[r]?B(e[r],t?.[r]):e[r]=t[r]);return e}const D=(0,_libs_maquette_advanced_projector_projector_js__WEBPACK_IMPORTED_MODULE_19__.createAdvancedProjector)({postProcessProjectionOptions(e){const t=e.eventHandlerInterceptor,r=/capture$/i;e.eventHandlerInterceptor=(e,s,o,i)=>{const n=t?.(e,s,o,i),a=r.test(e);if(!((e=e.replace(r,"")).toLowerCase()in o)||a){const t=e[2].toLowerCase()+e.slice(3),r=e=>n?.call(o,e);o.addEventListener(t,r,a);const s=()=>o.removeEventListener(t,r,a),c=i.afterRemoved;i.afterRemoved=e=>{c?.(e),s()}}return n}},handleInterceptedEvent(e,t,r,s){const{eventPhase:o,type:i}=s,n=o===Event.CAPTURING_PHASE;let a=`on${i}${n?"capture":""}`;const c=t.properties;(c&&a in c||(a=`on${i[0].toUpperCase()}${i.slice(1)}${n?"Capture":""}`,c&&a in c))&&((0,_support_vnodeCache_js__WEBPACK_IMPORTED_MODULE_24__.clearVNodeCache)(),e.scheduleRender(),c[a].call(c.bind||r,s))}});let M=!1,O=class extends((0,_core_Promise_js__WEBPACK_IMPORTED_MODULE_10__.EsriPromiseMixin)(_core_Evented_js__WEBPACK_IMPORTED_MODULE_3__["default"].EventedAccessor)){constructor(e,t){super(e,t),this._attached=!1,this._internalHandles=new _core_Handles_js__WEBPACK_IMPORTED_MODULE_5__["default"],this._projector=D,this._readyForTrueRender=!1,this.iconClass=A.widgetIcon,this.icon=null,this.key=this,this._loadLocale=(0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_11__.debounce)((async()=>{if(this._messageBundleProps&&this._messageBundleProps.length){const e=await (0,_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_11__.eachAlways)(this._messageBundleProps.map((async({bundlePath:e,propertyName:t})=>{if(this.destroyed)return;let r=await (0,_intl_messages_js__WEBPACK_IMPORTED_MODULE_27__.fetchMessageBundle)(e);this.uiStrings&&Object.keys(this.uiStrings)&&(r=B((0,_core_lang_js__WEBPACK_IMPORTED_MODULE_7__.clone)(r),this.uiStrings)),this[t]=r})));if(this.destroyed)return;for(const t of e)t.error&&_core_Logger_js__WEBPACK_IMPORTED_MODULE_8__["default"].getLogger(this).error("widget-intl:locale-error",this.declaredClass,t.error)}await this.loadLocale()})),(0,_support_componentsUtils_js__WEBPACK_IMPORTED_MODULE_20__.commitAssetPath)();const r="esri-widget-uid-"+(0,_core_uuid_js__WEBPACK_IMPORTED_MODULE_13__.generateUUID)(),s=this.render.bind(this);this._trackingTarget=new _core_accessorSupport_tracking_SimpleTrackingTarget_js__WEBPACK_IMPORTED_MODULE_18__.SimpleTrackingTarget((()=>this.scheduleRender()));const o=()=>{if(!this._readyForTrueRender||this.destroyed)return null;const e=s();let{properties:t}=e;t||(e.properties=t={});const{key:o}=t;o||(t.key=r),this.visible?t.styles||(t.styles={}):(t.class="",t.styles={display:"none"}),t.styles.display||(t.styles.display="");let i=0;return e.children?.forEach((e=>{if((0,_support_jsxWidgetSupport_js__WEBPACK_IMPORTED_MODULE_21__.isWidgetConstructor)(e.vnodeSelector))return;let{properties:t}=e;t||(e.properties=t={}),t.key||(t.key=`${this.id}--${i++}`)})),(0,_support_jsxWidgetSupport_js__WEBPACK_IMPORTED_MODULE_21__.processWidgets)(this,e)};this.render=()=>{if(M)return o();let e=(0,_support_vnodeCache_js__WEBPACK_IMPORTED_MODULE_24__.getVNodeCache)(this)??null;if(e)return e;this._trackingTarget.clear(),M=!0;try{e=(0,_core_accessorSupport_tracking_js__WEBPACK_IMPORTED_MODULE_17__.runTracked)(this._trackingTarget,o)}catch(t){throw console.error(t),t}finally{M=!1}return e&&(0,_support_vnodeCache_js__WEBPACK_IMPORTED_MODULE_24__.setVNodeCache)(this,e),e},this.addResolvingPromise(this._resourcesFetch=this.beforeFirstRender().then((()=>{this._readyForTrueRender=!0,this._postInitialize()}))),(0,_support_tests_js__WEBPACK_IMPORTED_MODULE_23__.registerLoading)(this._resourcesFetch)}normalizeCtorArgs(e,t){const r={...e};return t&&(r.container=t),r}postInitialize(){}beforeFirstRender(){return Promise.all([this.loadDependencies(),this._loadLocale()]).then((()=>{})).catch(_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_11__.throwIfNotAbortError)}async loadDependencies(){}async loadLocale(){}destroy(){this.destroyed||((0,_core_maybe_js__WEBPACK_IMPORTED_MODULE_9__.destroyMaybe)(this._trackingTarget),(0,_core_maybe_js__WEBPACK_IMPORTED_MODULE_9__.destroyMaybe)(this.viewModel),this._detach(this.container),this._set("container",null),this._internalHandles.destroy(),this._emitter.clear(),this.render=()=>null,this._projector=null,(0,_support_vnodeCache_js__WEBPACK_IMPORTED_MODULE_24__.deleteVNodeCache)(this))}set container(e){this._get("container")||this._set("container",e)}castContainer(e){return (0,_core_domUtils_js__WEBPACK_IMPORTED_MODULE_2__.byId)(e)}get domNode(){return this.container}set domNode(e){this.container=e}get id(){return this._get("id")||this.get("container.id")||Date.now().toString(16)+"-widget-"+x++}set id(e){e&&this._set("id",e)}get label(){return this.declaredClass.split(".").pop()}set label(e){this._overrideIfSome("label",e)}get renderable(){return this._resourcesFetch}get visible(){return this._get("visible")}set visible(e){this._set("visible",e)}get[($=_support_symbols_js__WEBPACK_IMPORTED_MODULE_22__.WIDGET_SYMBOL,_support_symbols_js__WEBPACK_IMPORTED_MODULE_22__.WIDGET_TEST_DATA_SYMBOL)](){return{projector:this._projector}}render(){throw new Error("not implemented")}scheduleRender(){this.destroyed||((0,_support_vnodeCache_js__WEBPACK_IMPORTED_MODULE_24__.deleteVNodeCache)(this),this._projector.scheduleRender())}classes(...e){return _support_widgetUtils_js__WEBPACK_IMPORTED_MODULE_25__.classes.apply(this,e)}renderNow(){(0,_support_vnodeCache_js__WEBPACK_IMPORTED_MODULE_24__.deleteVNodeCache)(this),this._projector.renderNow()}_postInitialize(){if(this.destroyed)return;this.scheduleRender(),this._delegatedEventNames?.length&&this._internalHandles.add((0,_core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_12__.watch)((()=>this.viewModel),((e,t)=>{t&&this._internalHandles.remove("delegated-events"),e&&(0,_core_events_js__WEBPACK_IMPORTED_MODULE_4__.isEventTarget)(e)&&this._internalHandles.add(this._delegatedEventNames.map((t=>(0,_core_events_js__WEBPACK_IMPORTED_MODULE_4__.on)(e,t,(e=>{this.emit(t,e)})))),"delegated-events")}),_core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_12__.initial)),this.postInitialize();const e=async()=>{await this._loadLocale().catch(_core_promiseUtils_js__WEBPACK_IMPORTED_MODULE_11__.throwIfNotAbortError),this.scheduleRender()};this._internalHandles.add([(0,_intl_locale_js__WEBPACK_IMPORTED_MODULE_26__.onLocaleChange)(e),(0,_core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_12__.watch)((()=>this.uiStrings),e),(0,_core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_12__.when)((()=>this.container),(e=>{this.destroyed||this._attach(e)}),{initial:!0,once:!0})])}_attach(e){e&&(this._projector.merge(e,this.render),this._attached=!0)}_detach(e){this._attached&&(this._projector.detach(this.render),this._attached=!1),e?.parentNode?.removeChild(e)}};O[$]=!0,(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"_readyForTrueRender",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)({value:null})],O.prototype,"container",null),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_cast_js__WEBPACK_IMPORTED_MODULE_15__.cast)("container")],O.prototype,"castContainer",null),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"iconClass",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"icon",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"id",null),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"label",null),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"renderable",null),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"uiStrings",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"viewModel",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)({value:!0})],O.prototype,"visible",null),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"key",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"children",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"afterCreate",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"afterUpdate",void 0),(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_property_js__WEBPACK_IMPORTED_MODULE_14__.property)()],O.prototype,"afterRemoved",void 0),O=(0,_chunks_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__._)([(0,_core_accessorSupport_decorators_subclass_js__WEBPACK_IMPORTED_MODULE_16__.subclass)(z)],O);const W=O;


/***/ }),

/***/ "./node_modules/@arcgis/core/widgets/support/componentsUtils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@arcgis/core/widgets/support/componentsUtils.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "commitAssetPath": () => (/* binding */ r),
/* harmony export */   "loadCalciteComponents": () => (/* binding */ n)
/* harmony export */ });
/* harmony import */ var _esri_calcite_components_dist_components_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @esri/calcite-components/dist/components/index.js */ "./node_modules/@esri/calcite-components/dist/components/index.js");
/* harmony import */ var _assets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../assets.js */ "./node_modules/@arcgis/core/assets.js");
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _core_urlUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/urlUtils.js */ "./node_modules/@arcgis/core/core/urlUtils.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
let c;function r(){try{(0,_esri_calcite_components_dist_components_index_js__WEBPACK_IMPORTED_MODULE_0__.getAssetPath)(".")}catch{(0,_esri_calcite_components_dist_components_index_js__WEBPACK_IMPORTED_MODULE_0__.setAssetPath)((0,_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_3__.makeAbsolute)((0,_assets_js__WEBPACK_IMPORTED_MODULE_1__.getAssetUrl)(c)))}}function n(t){const o=[];for(const s of Object.keys(t))customElements.get(`calcite-${s}`)||o.push(t[s]?.());return Promise.all(o)}c="components/assets";


/***/ }),

/***/ "./node_modules/@arcgis/core/widgets/support/decorators/accessibleHandler.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@arcgis/core/widgets/support/decorators/accessibleHandler.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "accessibleHandler": () => (/* binding */ t)
/* harmony export */ });
/* harmony import */ var _widgetUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../widgetUtils.js */ "./node_modules/@arcgis/core/widgets/support/widgetUtils.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
function t(){return function(n,t){if(!n[t])throw new TypeError(`Cannot auto bind undefined function '${String(t)}'`);return{value:r(n[t])}}}function e(n){const t=n?.type;return n instanceof KeyboardEvent||"keyup"===t||"keydown"===t||"keypress"===t}function r(t){return function(r,...o){e(r)?(0,_widgetUtils_js__WEBPACK_IMPORTED_MODULE_0__.isActivationKey)(r.key)&&(r.preventDefault(),r.stopPropagation(),r.target.click()):t.call(this,r,...o)}}


/***/ }),

/***/ "./node_modules/@arcgis/core/widgets/support/decorators/messageBundle.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@arcgis/core/widgets/support/decorators/messageBundle.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "messageBundle": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
function e(e){return(s,r)=>{s.hasOwnProperty("_messageBundleProps")||(s._messageBundleProps=s._messageBundleProps?s._messageBundleProps.slice():[]);s._messageBundleProps.push({bundlePath:e,propertyName:r})}}


/***/ }),

/***/ "./node_modules/@arcgis/core/widgets/support/decorators/vmEvent.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@arcgis/core/widgets/support/decorators/vmEvent.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "vmEvent": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
function e(e){return a=>{a.hasOwnProperty("_delegatedEventNames")||(a._delegatedEventNames=a._delegatedEventNames?a._delegatedEventNames.slice():[]);const n=a._delegatedEventNames,r=Array.isArray(e)?e:t(e);n.push(...r)}}function t(e){return e.split(",").map((e=>e.trim()))}


/***/ }),

/***/ "./node_modules/@arcgis/core/widgets/support/jsxFactory.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@arcgis/core/widgets/support/jsxFactory.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tsx": () => (/* binding */ n),
/* harmony export */   "tsxFragment": () => (/* binding */ i)
/* harmony export */ });
/* harmony import */ var _jsxWidgetSupport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jsxWidgetSupport.js */ "./node_modules/@arcgis/core/widgets/support/jsxWidgetSupport.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
var e=function(r){return{vnodeSelector:"",properties:void 0,children:void 0,text:r.toString(),domNode:null}},o=function(r,t){for(var n=0,i=r.length;n<i;n++){var d=r[n];Array.isArray(d)?o(d,t):null!=d&&!1!==d&&(d.hasOwnProperty("vnodeSelector")||(d=e(d)),t.push(d))}},t=function(r,e){for(var t=[],n=2;n<arguments.length;n++)t[n-2]=arguments[n];if(1===t.length&&"string"==typeof t[0])return{vnodeSelector:r,properties:e||void 0,children:void 0,text:t[0],domNode:null};var i=[];return o(t,i),{vnodeSelector:r,properties:e||void 0,children:i,text:void 0,domNode:null}};function n(e,o,...n){return"function"!=typeof e||(0,_jsxWidgetSupport_js__WEBPACK_IMPORTED_MODULE_0__.isWidgetConstructor)(e)?t(e,o,...n):e(o,...n)}function i(...r){return r}


/***/ }),

/***/ "./node_modules/@arcgis/core/widgets/support/jsxWidgetSupport.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@arcgis/core/widgets/support/jsxWidgetSupport.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isWidgetConstructor": () => (/* binding */ a),
/* harmony export */   "processWidgets": () => (/* binding */ i)
/* harmony export */ });
/* harmony import */ var _core_handleUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/handleUtils.js */ "./node_modules/@arcgis/core/core/handleUtils.js");
/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbols.js */ "./node_modules/@arcgis/core/widgets/support/symbols.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const r=[],o={},n=new WeakMap;function i(e,t){let n=t.children;if(n&&n.length)for(let r=0;r<n.length;++r)n[r]=i(e,n[r]);else n=r;const f=t.vnodeSelector;if(a(f)){const r=t.properties||o,i=r.key||f;return{vnodeSelector:"div",properties:{key:i,afterCreate:d,afterUpdate:s,afterRemoved:c,parentWidget:e,widgetConstructor:f,widgetProperties:{...r,key:i,children:n}},children:void 0,text:void 0,domNode:null}}return t}function d(t,r,o,{parentWidget:i,widgetConstructor:d,widgetProperties:s}){const a=new d(s);a.container=t,n.set(t,a),a.afterCreate?.(a,t),i._internalHandles.add((0,_core_handleUtils_js__WEBPACK_IMPORTED_MODULE_0__.makeHandle)((()=>c(t))))}function s(e,t,r,{widgetProperties:o}){const i=n.get(e);i&&(i.set(o),i.afterUpdate?.(i,e))}function c(e){const t=n.get(e);t&&(t.afterRemoved?.(t,e),t.destroy(),n.delete(e))}function a(e){return"function"==typeof e&&e[_symbols_js__WEBPACK_IMPORTED_MODULE_1__.WIDGET_SYMBOL]}


/***/ }),

/***/ "./node_modules/@arcgis/core/widgets/support/symbols.js":
/*!**************************************************************!*\
  !*** ./node_modules/@arcgis/core/widgets/support/symbols.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WIDGET_SYMBOL": () => (/* binding */ t),
/* harmony export */   "WIDGET_TEST_DATA_SYMBOL": () => (/* binding */ e)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const t=Symbol("widget"),e=Symbol("widget-test-data");


/***/ }),

/***/ "./node_modules/@arcgis/core/widgets/support/tests.js":
/*!************************************************************!*\
  !*** ./node_modules/@arcgis/core/widgets/support/tests.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasPendingLoading": () => (/* binding */ t),
/* harmony export */   "registerLoading": () => (/* binding */ n)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const e=new Set;function n(n){e.add(n),n.finally((()=>e.delete(n)))}function t(){return e.size>0}


/***/ }),

/***/ "./node_modules/@arcgis/core/widgets/support/vnodeCache.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@arcgis/core/widgets/support/vnodeCache.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clearVNodeCache": () => (/* binding */ t),
/* harmony export */   "deleteVNodeCache": () => (/* binding */ o),
/* harmony export */   "getVNodeCache": () => (/* binding */ e),
/* harmony export */   "setVNodeCache": () => (/* binding */ c)
/* harmony export */ });
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
const n=new Map;function t(){n.clear()}function e(t){return n.get(t)}function c(t,e){n.set(t,e)}function o(t){n.delete(t)}


/***/ }),

/***/ "./node_modules/@arcgis/core/widgets/support/widget.js":
/*!*************************************************************!*\
  !*** ./node_modules/@arcgis/core/widgets/support/widget.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "accessibleHandler": () => (/* reexport safe */ _decorators_accessibleHandler_js__WEBPACK_IMPORTED_MODULE_0__.accessibleHandler),
/* harmony export */   "additionalAllowedTags": () => (/* reexport safe */ _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__.additionalAllowedTags),
/* harmony export */   "classes": () => (/* reexport safe */ _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__.classes),
/* harmony export */   "cssTransition": () => (/* reexport safe */ _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__.cssTransition),
/* harmony export */   "discardNode": () => (/* reexport safe */ _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__.discardNode),
/* harmony export */   "getCalciteThemeClass": () => (/* reexport safe */ _support_themeUtils_js__WEBPACK_IMPORTED_MODULE_5__.getCalciteThemeClass),
/* harmony export */   "getDir": () => (/* reexport safe */ _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__.getDir),
/* harmony export */   "hasDomNode": () => (/* binding */ t),
/* harmony export */   "isActivationKey": () => (/* reexport safe */ _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__.isActivationKey),
/* harmony export */   "isDarkTheme": () => (/* reexport safe */ _support_themeUtils_js__WEBPACK_IMPORTED_MODULE_5__.isDarkTheme),
/* harmony export */   "isRTL": () => (/* reexport safe */ _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__.isRTL),
/* harmony export */   "isWidget": () => (/* binding */ e),
/* harmony export */   "keepMenuItemWithinView": () => (/* reexport safe */ _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__.keepMenuItemWithinView),
/* harmony export */   "messageBundle": () => (/* reexport safe */ _decorators_messageBundle_js__WEBPACK_IMPORTED_MODULE_1__.messageBundle),
/* harmony export */   "onResize": () => (/* reexport safe */ _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__.onResize),
/* harmony export */   "renderingSanitizer": () => (/* reexport safe */ _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__.renderingSanitizer),
/* harmony export */   "safeAttrs": () => (/* reexport safe */ _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__.safeAttrs),
/* harmony export */   "setCalciteThemeClass": () => (/* reexport safe */ _support_themeUtils_js__WEBPACK_IMPORTED_MODULE_5__.setCalciteThemeClass),
/* harmony export */   "storeNode": () => (/* reexport safe */ _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__.storeNode),
/* harmony export */   "tsx": () => (/* reexport safe */ _jsxFactory_js__WEBPACK_IMPORTED_MODULE_3__.tsx),
/* harmony export */   "tsxFragment": () => (/* reexport safe */ _jsxFactory_js__WEBPACK_IMPORTED_MODULE_3__.tsxFragment),
/* harmony export */   "vmEvent": () => (/* reexport safe */ _decorators_vmEvent_js__WEBPACK_IMPORTED_MODULE_2__.vmEvent)
/* harmony export */ });
/* harmony import */ var _decorators_accessibleHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decorators/accessibleHandler.js */ "./node_modules/@arcgis/core/widgets/support/decorators/accessibleHandler.js");
/* harmony import */ var _decorators_messageBundle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decorators/messageBundle.js */ "./node_modules/@arcgis/core/widgets/support/decorators/messageBundle.js");
/* harmony import */ var _decorators_vmEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./decorators/vmEvent.js */ "./node_modules/@arcgis/core/widgets/support/decorators/vmEvent.js");
/* harmony import */ var _jsxFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jsxFactory.js */ "./node_modules/@arcgis/core/widgets/support/jsxFactory.js");
/* harmony import */ var _widgetUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./widgetUtils.js */ "./node_modules/@arcgis/core/widgets/support/widgetUtils.js");
/* harmony import */ var _support_themeUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../support/themeUtils.js */ "./node_modules/@arcgis/core/support/themeUtils.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
function e(e){return e&&"function"==typeof e.render}function t(e){return e&&"function"==typeof e.postMixInProperties&&"function"==typeof e.buildRendering&&"function"==typeof e.postCreate&&"function"==typeof e.startup}


/***/ }),

/***/ "./node_modules/@arcgis/core/widgets/support/widgetUtils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@arcgis/core/widgets/support/widgetUtils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "additionalAllowedTags": () => (/* binding */ y),
/* harmony export */   "classes": () => (/* binding */ m),
/* harmony export */   "cssTransition": () => (/* binding */ b),
/* harmony export */   "discardNode": () => (/* binding */ w),
/* harmony export */   "getDir": () => (/* binding */ v),
/* harmony export */   "isActivationKey": () => (/* binding */ T),
/* harmony export */   "isRTL": () => (/* binding */ h),
/* harmony export */   "keepMenuItemWithinView": () => (/* binding */ k),
/* harmony export */   "onResize": () => (/* binding */ g),
/* harmony export */   "renderingSanitizer": () => (/* binding */ j),
/* harmony export */   "safeAttrs": () => (/* binding */ A),
/* harmony export */   "storeNode": () => (/* binding */ L)
/* harmony export */ });
/* harmony import */ var _esri_arcgis_html_sanitizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @esri/arcgis-html-sanitizer */ "./node_modules/@esri/arcgis-html-sanitizer/dist/esm/index.js");
/* harmony import */ var _core_ArrayPool_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/ArrayPool.js */ "./node_modules/@arcgis/core/core/ArrayPool.js");
/* harmony import */ var _core_handleUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/handleUtils.js */ "./node_modules/@arcgis/core/core/handleUtils.js");
/* harmony import */ var _core_has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/has.js */ "./node_modules/@arcgis/core/core/has.js");
/* harmony import */ var _core_Logger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/Logger.js */ "./node_modules/@arcgis/core/core/Logger.js");
/* harmony import */ var _core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/reactiveUtils.js */ "./node_modules/@arcgis/core/core/reactiveUtils.js");
/* harmony import */ var _vnodeCache_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./vnodeCache.js */ "./node_modules/@arcgis/core/widgets/support/vnodeCache.js");
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
var a,c,l=function(e){if("WebkitTransition"in e.style)a="webkitTransitionEnd",c="webkitAnimationEnd";else{if(!("transition"in e.style))throw new Error("Your browser is not supported!");a="transitionend",c="animationend"}},d=function(e){a||l(e)},u=function(e,t){return void 0===t&&(t=e+"-active"),function(n){d(n);var r=!1,i=function(o){r||(r=!0,n.removeEventListener(a,i),n.removeEventListener(c,i),n.classList.remove(e),n.classList.remove(t))};n.classList.add(e),n.addEventListener(a,i),n.addEventListener(c,i),requestAnimationFrame((function(){n.classList.add(t)}))}},p=function(e,t){return void 0===t&&(t=e+"-active"),function(n,r){d(n);var i=!1,o=function(e){i||(i=!0,n.removeEventListener(a,o),n.removeEventListener(c,o),r())};n.classList.add(e),n.addEventListener(a,o),n.addEventListener(c,o),requestAnimationFrame((function(){n.classList.add(t)}))}};const f=_core_Logger_js__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("esri.widgets.support.widgetUtils");function m(e){const n=_core_ArrayPool_js__WEBPACK_IMPORTED_MODULE_1__["default"].acquire();for(let t=0;t<arguments.length;t++){const e=arguments[t],r=typeof e;if("string"===r)n.push(e);else if(Array.isArray(e))n.push.apply(n,e);else if("object"===r)for(const t in e)e[t]&&n.push(t)}const r=n.join(" ");return _core_ArrayPool_js__WEBPACK_IMPORTED_MODULE_1__["default"].release(n),r}const g=(()=>{const e=new Map,t=new ResizeObserver((t=>{(0,_vnodeCache_js__WEBPACK_IMPORTED_MODULE_6__.clearVNodeCache)();for(const n of t)e.get(n.target)?.(n)})),r=(r,i,o)=>(e.has(r)&&f.error("Already observing element",r),e.set(r,i),t.observe(r,o),(0,_core_handleUtils_js__WEBPACK_IMPORTED_MODULE_2__.makeHandle)((()=>{t.unobserve(r),e.delete(r)})));return(e,t,n)=>{let s=null;return (0,_core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_5__.watch)((()=>"function"==typeof e?e():e),(e=>{s?.remove(),e&&(s=r(e,t,n))}),_core_reactiveUtils_js__WEBPACK_IMPORTED_MODULE_5__.syncAndInitial)}})();function h(e){const t=e?.closest("[dir]");return null!==t&&t instanceof HTMLElement&&"rtl"===t.dir||"rtl"===document.dir}function v(e){return h(e)?"rtl":"ltr"}function w(e){const t="data-node-ref";this[e.getAttribute(t)]=null}function L(e){const t="data-node-ref";this[e.getAttribute(t)]=e}function b(e,t){return("enter"===e?u:p)(t)}const y=["dd","dl","dt","h1","h2","h3","h4","h5","h6","sub","sup",...["animate","animatetransform","circle","clippath","defs","ellipse","g","image","line","lineargradient","marker","mask","path","pattern","polygon","polyline","radialgradient","rect","stop","svg","switch","symbol","text","textpath","tspan","use"]],E=y.reduce(((e,t)=>(e[t]=[],e)),{}),A=["align","alink","alt","bgcolor","border","cellpadding","cellspacing","class","color","cols","colspan","coords","d","dir","face","height","hspace","ismap","lang","marginheight","marginwidth","multiple","nohref","noresize","noshade","nowrap","ref","rel","rev","rows","rowspan","scrolling","shape","span","summary","tabindex","title","usemap","valign","value","vlink","vspace","width"],j=new _esri_arcgis_html_sanitizer__WEBPACK_IMPORTED_MODULE_0__["default"]({whiteList:E,onTagAttr:(e,t,n)=>{const r=`${t}="${n}"`;if(A.includes(t))return r},stripIgnoreTag:!0,stripIgnoreTagBody:["script","style"]},!0);function k(e,t){const n=e.getBoundingClientRect(),r=t.getBoundingClientRect(),i=n.top+n.height,o=r.top+r.height,s=n.top,a=r.top;(i>o||s<a)&&e.scrollIntoView({block:"end"})}function T(e){return"Enter"===e||" "===e}


/***/ }),

/***/ "./node_modules/@esri/arcgis-html-sanitizer/dist/esm/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@esri/arcgis-html-sanitizer/dist/esm/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sanitizer": () => (/* binding */ Sanitizer),
/* harmony export */   "default": () => (/* binding */ Sanitizer)
/* harmony export */ });
/*!
 * @esri/arcgis-html-sanitizer - v3.0.1 - Tue Nov 15 2022 09:46:54 GMT-0800 (Pacific Standard Time)
 * Copyright (c) 2022 - Environmental Systems Research Institute, Inc.
 * Apache-2.0
 * 
 * js-xss
 * Copyright (c) 2012-2018 Zongmin Lei() <leizongmin@gmail.com>
 * http://ucdok.com
 * MIT License, see https://github.com/leizongmin/js-xss/blob/master/LICENSE for details
 */
/**
 * Determine if the value is a plain object.
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 */
var isPlainObject = function (value) {
    if (typeof value !== "object" || value === null) {
        return false;
    }
    if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
    }
    var proto = Object.getPrototypeOf(value);
    if (proto === null) {
        return true;
    }
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
};

var lib$1 = {exports: {}};

var _default$1 = {};

var lib = {exports: {}};

var _default = {};

/**
 * cssfilter
 *
 * @author <leizongmin@gmail.com>
 */

function getDefaultWhiteList$1 () {
  // 
  // true: 
  // Function: function (val) { } true
  // RegExp: regexp.test(val) true
  // 
  var whiteList = {};

  whiteList['align-content'] = false; // default: auto
  whiteList['align-items'] = false; // default: auto
  whiteList['align-self'] = false; // default: auto
  whiteList['alignment-adjust'] = false; // default: auto
  whiteList['alignment-baseline'] = false; // default: baseline
  whiteList['all'] = false; // default: depending on individual properties
  whiteList['anchor-point'] = false; // default: none
  whiteList['animation'] = false; // default: depending on individual properties
  whiteList['animation-delay'] = false; // default: 0
  whiteList['animation-direction'] = false; // default: normal
  whiteList['animation-duration'] = false; // default: 0
  whiteList['animation-fill-mode'] = false; // default: none
  whiteList['animation-iteration-count'] = false; // default: 1
  whiteList['animation-name'] = false; // default: none
  whiteList['animation-play-state'] = false; // default: running
  whiteList['animation-timing-function'] = false; // default: ease
  whiteList['azimuth'] = false; // default: center
  whiteList['backface-visibility'] = false; // default: visible
  whiteList['background'] = true; // default: depending on individual properties
  whiteList['background-attachment'] = true; // default: scroll
  whiteList['background-clip'] = true; // default: border-box
  whiteList['background-color'] = true; // default: transparent
  whiteList['background-image'] = true; // default: none
  whiteList['background-origin'] = true; // default: padding-box
  whiteList['background-position'] = true; // default: 0% 0%
  whiteList['background-repeat'] = true; // default: repeat
  whiteList['background-size'] = true; // default: auto
  whiteList['baseline-shift'] = false; // default: baseline
  whiteList['binding'] = false; // default: none
  whiteList['bleed'] = false; // default: 6pt
  whiteList['bookmark-label'] = false; // default: content()
  whiteList['bookmark-level'] = false; // default: none
  whiteList['bookmark-state'] = false; // default: open
  whiteList['border'] = true; // default: depending on individual properties
  whiteList['border-bottom'] = true; // default: depending on individual properties
  whiteList['border-bottom-color'] = true; // default: current color
  whiteList['border-bottom-left-radius'] = true; // default: 0
  whiteList['border-bottom-right-radius'] = true; // default: 0
  whiteList['border-bottom-style'] = true; // default: none
  whiteList['border-bottom-width'] = true; // default: medium
  whiteList['border-collapse'] = true; // default: separate
  whiteList['border-color'] = true; // default: depending on individual properties
  whiteList['border-image'] = true; // default: none
  whiteList['border-image-outset'] = true; // default: 0
  whiteList['border-image-repeat'] = true; // default: stretch
  whiteList['border-image-slice'] = true; // default: 100%
  whiteList['border-image-source'] = true; // default: none
  whiteList['border-image-width'] = true; // default: 1
  whiteList['border-left'] = true; // default: depending on individual properties
  whiteList['border-left-color'] = true; // default: current color
  whiteList['border-left-style'] = true; // default: none
  whiteList['border-left-width'] = true; // default: medium
  whiteList['border-radius'] = true; // default: 0
  whiteList['border-right'] = true; // default: depending on individual properties
  whiteList['border-right-color'] = true; // default: current color
  whiteList['border-right-style'] = true; // default: none
  whiteList['border-right-width'] = true; // default: medium
  whiteList['border-spacing'] = true; // default: 0
  whiteList['border-style'] = true; // default: depending on individual properties
  whiteList['border-top'] = true; // default: depending on individual properties
  whiteList['border-top-color'] = true; // default: current color
  whiteList['border-top-left-radius'] = true; // default: 0
  whiteList['border-top-right-radius'] = true; // default: 0
  whiteList['border-top-style'] = true; // default: none
  whiteList['border-top-width'] = true; // default: medium
  whiteList['border-width'] = true; // default: depending on individual properties
  whiteList['bottom'] = false; // default: auto
  whiteList['box-decoration-break'] = true; // default: slice
  whiteList['box-shadow'] = true; // default: none
  whiteList['box-sizing'] = true; // default: content-box
  whiteList['box-snap'] = true; // default: none
  whiteList['box-suppress'] = true; // default: show
  whiteList['break-after'] = true; // default: auto
  whiteList['break-before'] = true; // default: auto
  whiteList['break-inside'] = true; // default: auto
  whiteList['caption-side'] = false; // default: top
  whiteList['chains'] = false; // default: none
  whiteList['clear'] = true; // default: none
  whiteList['clip'] = false; // default: auto
  whiteList['clip-path'] = false; // default: none
  whiteList['clip-rule'] = false; // default: nonzero
  whiteList['color'] = true; // default: implementation dependent
  whiteList['color-interpolation-filters'] = true; // default: auto
  whiteList['column-count'] = false; // default: auto
  whiteList['column-fill'] = false; // default: balance
  whiteList['column-gap'] = false; // default: normal
  whiteList['column-rule'] = false; // default: depending on individual properties
  whiteList['column-rule-color'] = false; // default: current color
  whiteList['column-rule-style'] = false; // default: medium
  whiteList['column-rule-width'] = false; // default: medium
  whiteList['column-span'] = false; // default: none
  whiteList['column-width'] = false; // default: auto
  whiteList['columns'] = false; // default: depending on individual properties
  whiteList['contain'] = false; // default: none
  whiteList['content'] = false; // default: normal
  whiteList['counter-increment'] = false; // default: none
  whiteList['counter-reset'] = false; // default: none
  whiteList['counter-set'] = false; // default: none
  whiteList['crop'] = false; // default: auto
  whiteList['cue'] = false; // default: depending on individual properties
  whiteList['cue-after'] = false; // default: none
  whiteList['cue-before'] = false; // default: none
  whiteList['cursor'] = false; // default: auto
  whiteList['direction'] = false; // default: ltr
  whiteList['display'] = true; // default: depending on individual properties
  whiteList['display-inside'] = true; // default: auto
  whiteList['display-list'] = true; // default: none
  whiteList['display-outside'] = true; // default: inline-level
  whiteList['dominant-baseline'] = false; // default: auto
  whiteList['elevation'] = false; // default: level
  whiteList['empty-cells'] = false; // default: show
  whiteList['filter'] = false; // default: none
  whiteList['flex'] = false; // default: depending on individual properties
  whiteList['flex-basis'] = false; // default: auto
  whiteList['flex-direction'] = false; // default: row
  whiteList['flex-flow'] = false; // default: depending on individual properties
  whiteList['flex-grow'] = false; // default: 0
  whiteList['flex-shrink'] = false; // default: 1
  whiteList['flex-wrap'] = false; // default: nowrap
  whiteList['float'] = false; // default: none
  whiteList['float-offset'] = false; // default: 0 0
  whiteList['flood-color'] = false; // default: black
  whiteList['flood-opacity'] = false; // default: 1
  whiteList['flow-from'] = false; // default: none
  whiteList['flow-into'] = false; // default: none
  whiteList['font'] = true; // default: depending on individual properties
  whiteList['font-family'] = true; // default: implementation dependent
  whiteList['font-feature-settings'] = true; // default: normal
  whiteList['font-kerning'] = true; // default: auto
  whiteList['font-language-override'] = true; // default: normal
  whiteList['font-size'] = true; // default: medium
  whiteList['font-size-adjust'] = true; // default: none
  whiteList['font-stretch'] = true; // default: normal
  whiteList['font-style'] = true; // default: normal
  whiteList['font-synthesis'] = true; // default: weight style
  whiteList['font-variant'] = true; // default: normal
  whiteList['font-variant-alternates'] = true; // default: normal
  whiteList['font-variant-caps'] = true; // default: normal
  whiteList['font-variant-east-asian'] = true; // default: normal
  whiteList['font-variant-ligatures'] = true; // default: normal
  whiteList['font-variant-numeric'] = true; // default: normal
  whiteList['font-variant-position'] = true; // default: normal
  whiteList['font-weight'] = true; // default: normal
  whiteList['grid'] = false; // default: depending on individual properties
  whiteList['grid-area'] = false; // default: depending on individual properties
  whiteList['grid-auto-columns'] = false; // default: auto
  whiteList['grid-auto-flow'] = false; // default: none
  whiteList['grid-auto-rows'] = false; // default: auto
  whiteList['grid-column'] = false; // default: depending on individual properties
  whiteList['grid-column-end'] = false; // default: auto
  whiteList['grid-column-start'] = false; // default: auto
  whiteList['grid-row'] = false; // default: depending on individual properties
  whiteList['grid-row-end'] = false; // default: auto
  whiteList['grid-row-start'] = false; // default: auto
  whiteList['grid-template'] = false; // default: depending on individual properties
  whiteList['grid-template-areas'] = false; // default: none
  whiteList['grid-template-columns'] = false; // default: none
  whiteList['grid-template-rows'] = false; // default: none
  whiteList['hanging-punctuation'] = false; // default: none
  whiteList['height'] = true; // default: auto
  whiteList['hyphens'] = false; // default: manual
  whiteList['icon'] = false; // default: auto
  whiteList['image-orientation'] = false; // default: auto
  whiteList['image-resolution'] = false; // default: normal
  whiteList['ime-mode'] = false; // default: auto
  whiteList['initial-letters'] = false; // default: normal
  whiteList['inline-box-align'] = false; // default: last
  whiteList['justify-content'] = false; // default: auto
  whiteList['justify-items'] = false; // default: auto
  whiteList['justify-self'] = false; // default: auto
  whiteList['left'] = false; // default: auto
  whiteList['letter-spacing'] = true; // default: normal
  whiteList['lighting-color'] = true; // default: white
  whiteList['line-box-contain'] = false; // default: block inline replaced
  whiteList['line-break'] = false; // default: auto
  whiteList['line-grid'] = false; // default: match-parent
  whiteList['line-height'] = false; // default: normal
  whiteList['line-snap'] = false; // default: none
  whiteList['line-stacking'] = false; // default: depending on individual properties
  whiteList['line-stacking-ruby'] = false; // default: exclude-ruby
  whiteList['line-stacking-shift'] = false; // default: consider-shifts
  whiteList['line-stacking-strategy'] = false; // default: inline-line-height
  whiteList['list-style'] = true; // default: depending on individual properties
  whiteList['list-style-image'] = true; // default: none
  whiteList['list-style-position'] = true; // default: outside
  whiteList['list-style-type'] = true; // default: disc
  whiteList['margin'] = true; // default: depending on individual properties
  whiteList['margin-bottom'] = true; // default: 0
  whiteList['margin-left'] = true; // default: 0
  whiteList['margin-right'] = true; // default: 0
  whiteList['margin-top'] = true; // default: 0
  whiteList['marker-offset'] = false; // default: auto
  whiteList['marker-side'] = false; // default: list-item
  whiteList['marks'] = false; // default: none
  whiteList['mask'] = false; // default: border-box
  whiteList['mask-box'] = false; // default: see individual properties
  whiteList['mask-box-outset'] = false; // default: 0
  whiteList['mask-box-repeat'] = false; // default: stretch
  whiteList['mask-box-slice'] = false; // default: 0 fill
  whiteList['mask-box-source'] = false; // default: none
  whiteList['mask-box-width'] = false; // default: auto
  whiteList['mask-clip'] = false; // default: border-box
  whiteList['mask-image'] = false; // default: none
  whiteList['mask-origin'] = false; // default: border-box
  whiteList['mask-position'] = false; // default: center
  whiteList['mask-repeat'] = false; // default: no-repeat
  whiteList['mask-size'] = false; // default: border-box
  whiteList['mask-source-type'] = false; // default: auto
  whiteList['mask-type'] = false; // default: luminance
  whiteList['max-height'] = true; // default: none
  whiteList['max-lines'] = false; // default: none
  whiteList['max-width'] = true; // default: none
  whiteList['min-height'] = true; // default: 0
  whiteList['min-width'] = true; // default: 0
  whiteList['move-to'] = false; // default: normal
  whiteList['nav-down'] = false; // default: auto
  whiteList['nav-index'] = false; // default: auto
  whiteList['nav-left'] = false; // default: auto
  whiteList['nav-right'] = false; // default: auto
  whiteList['nav-up'] = false; // default: auto
  whiteList['object-fit'] = false; // default: fill
  whiteList['object-position'] = false; // default: 50% 50%
  whiteList['opacity'] = false; // default: 1
  whiteList['order'] = false; // default: 0
  whiteList['orphans'] = false; // default: 2
  whiteList['outline'] = false; // default: depending on individual properties
  whiteList['outline-color'] = false; // default: invert
  whiteList['outline-offset'] = false; // default: 0
  whiteList['outline-style'] = false; // default: none
  whiteList['outline-width'] = false; // default: medium
  whiteList['overflow'] = false; // default: depending on individual properties
  whiteList['overflow-wrap'] = false; // default: normal
  whiteList['overflow-x'] = false; // default: visible
  whiteList['overflow-y'] = false; // default: visible
  whiteList['padding'] = true; // default: depending on individual properties
  whiteList['padding-bottom'] = true; // default: 0
  whiteList['padding-left'] = true; // default: 0
  whiteList['padding-right'] = true; // default: 0
  whiteList['padding-top'] = true; // default: 0
  whiteList['page'] = false; // default: auto
  whiteList['page-break-after'] = false; // default: auto
  whiteList['page-break-before'] = false; // default: auto
  whiteList['page-break-inside'] = false; // default: auto
  whiteList['page-policy'] = false; // default: start
  whiteList['pause'] = false; // default: implementation dependent
  whiteList['pause-after'] = false; // default: implementation dependent
  whiteList['pause-before'] = false; // default: implementation dependent
  whiteList['perspective'] = false; // default: none
  whiteList['perspective-origin'] = false; // default: 50% 50%
  whiteList['pitch'] = false; // default: medium
  whiteList['pitch-range'] = false; // default: 50
  whiteList['play-during'] = false; // default: auto
  whiteList['position'] = false; // default: static
  whiteList['presentation-level'] = false; // default: 0
  whiteList['quotes'] = false; // default: text
  whiteList['region-fragment'] = false; // default: auto
  whiteList['resize'] = false; // default: none
  whiteList['rest'] = false; // default: depending on individual properties
  whiteList['rest-after'] = false; // default: none
  whiteList['rest-before'] = false; // default: none
  whiteList['richness'] = false; // default: 50
  whiteList['right'] = false; // default: auto
  whiteList['rotation'] = false; // default: 0
  whiteList['rotation-point'] = false; // default: 50% 50%
  whiteList['ruby-align'] = false; // default: auto
  whiteList['ruby-merge'] = false; // default: separate
  whiteList['ruby-position'] = false; // default: before
  whiteList['shape-image-threshold'] = false; // default: 0.0
  whiteList['shape-outside'] = false; // default: none
  whiteList['shape-margin'] = false; // default: 0
  whiteList['size'] = false; // default: auto
  whiteList['speak'] = false; // default: auto
  whiteList['speak-as'] = false; // default: normal
  whiteList['speak-header'] = false; // default: once
  whiteList['speak-numeral'] = false; // default: continuous
  whiteList['speak-punctuation'] = false; // default: none
  whiteList['speech-rate'] = false; // default: medium
  whiteList['stress'] = false; // default: 50
  whiteList['string-set'] = false; // default: none
  whiteList['tab-size'] = false; // default: 8
  whiteList['table-layout'] = false; // default: auto
  whiteList['text-align'] = true; // default: start
  whiteList['text-align-last'] = true; // default: auto
  whiteList['text-combine-upright'] = true; // default: none
  whiteList['text-decoration'] = true; // default: none
  whiteList['text-decoration-color'] = true; // default: currentColor
  whiteList['text-decoration-line'] = true; // default: none
  whiteList['text-decoration-skip'] = true; // default: objects
  whiteList['text-decoration-style'] = true; // default: solid
  whiteList['text-emphasis'] = true; // default: depending on individual properties
  whiteList['text-emphasis-color'] = true; // default: currentColor
  whiteList['text-emphasis-position'] = true; // default: over right
  whiteList['text-emphasis-style'] = true; // default: none
  whiteList['text-height'] = true; // default: auto
  whiteList['text-indent'] = true; // default: 0
  whiteList['text-justify'] = true; // default: auto
  whiteList['text-orientation'] = true; // default: mixed
  whiteList['text-overflow'] = true; // default: clip
  whiteList['text-shadow'] = true; // default: none
  whiteList['text-space-collapse'] = true; // default: collapse
  whiteList['text-transform'] = true; // default: none
  whiteList['text-underline-position'] = true; // default: auto
  whiteList['text-wrap'] = true; // default: normal
  whiteList['top'] = false; // default: auto
  whiteList['transform'] = false; // default: none
  whiteList['transform-origin'] = false; // default: 50% 50% 0
  whiteList['transform-style'] = false; // default: flat
  whiteList['transition'] = false; // default: depending on individual properties
  whiteList['transition-delay'] = false; // default: 0s
  whiteList['transition-duration'] = false; // default: 0s
  whiteList['transition-property'] = false; // default: all
  whiteList['transition-timing-function'] = false; // default: ease
  whiteList['unicode-bidi'] = false; // default: normal
  whiteList['vertical-align'] = false; // default: baseline
  whiteList['visibility'] = false; // default: visible
  whiteList['voice-balance'] = false; // default: center
  whiteList['voice-duration'] = false; // default: auto
  whiteList['voice-family'] = false; // default: implementation dependent
  whiteList['voice-pitch'] = false; // default: medium
  whiteList['voice-range'] = false; // default: medium
  whiteList['voice-rate'] = false; // default: normal
  whiteList['voice-stress'] = false; // default: normal
  whiteList['voice-volume'] = false; // default: medium
  whiteList['volume'] = false; // default: medium
  whiteList['white-space'] = false; // default: normal
  whiteList['widows'] = false; // default: 2
  whiteList['width'] = true; // default: auto
  whiteList['will-change'] = false; // default: auto
  whiteList['word-break'] = true; // default: normal
  whiteList['word-spacing'] = true; // default: normal
  whiteList['word-wrap'] = true; // default: normal
  whiteList['wrap-flow'] = false; // default: auto
  whiteList['wrap-through'] = false; // default: wrap
  whiteList['writing-mode'] = false; // default: horizontal-tb
  whiteList['z-index'] = false; // default: auto

  return whiteList;
}


/**
 * 
 *
 * @param {String} name
 * @param {String} value
 * @param {Object} options
 * @return {String}
 */
function onAttr (name, value, options) {
  // do nothing
}

/**
 * 
 *
 * @param {String} name
 * @param {String} value
 * @param {Object} options
 * @return {String}
 */
function onIgnoreAttr (name, value, options) {
  // do nothing
}

var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/img;

/**
 * 
 *
 * @param {String} name
 * @param {String} value
 * @return {String}
 */
function safeAttrValue$1(name, value) {
  if (REGEXP_URL_JAVASCRIPT.test(value)) return '';
  return value;
}


_default.whiteList = getDefaultWhiteList$1();
_default.getDefaultWhiteList = getDefaultWhiteList$1;
_default.onAttr = onAttr;
_default.onIgnoreAttr = onIgnoreAttr;
_default.safeAttrValue = safeAttrValue$1;

var util$1 = {
  indexOf: function (arr, item) {
    var i, j;
    if (Array.prototype.indexOf) {
      return arr.indexOf(item);
    }
    for (i = 0, j = arr.length; i < j; i++) {
      if (arr[i] === item) {
        return i;
      }
    }
    return -1;
  },
  forEach: function (arr, fn, scope) {
    var i, j;
    if (Array.prototype.forEach) {
      return arr.forEach(fn, scope);
    }
    for (i = 0, j = arr.length; i < j; i++) {
      fn.call(scope, arr[i], i, arr);
    }
  },
  trim: function (str) {
    if (String.prototype.trim) {
      return str.trim();
    }
    return str.replace(/(^\s*)|(\s*$)/g, '');
  },
  trimRight: function (str) {
    if (String.prototype.trimRight) {
      return str.trimRight();
    }
    return str.replace(/(\s*$)/g, '');
  }
};

/**
 * cssfilter
 *
 * @author <leizongmin@gmail.com>
 */

var _$3 = util$1;


/**
 * style
 *
 * @param {String} css
 * @param {Function} onAttr 
 *    function (sourcePosition, position, name, value, source)
 * @return {String}
 */
function parseStyle$1 (css, onAttr) {
  css = _$3.trimRight(css);
  if (css[css.length - 1] !== ';') css += ';';
  var cssLength = css.length;
  var isParenthesisOpen = false;
  var lastPos = 0;
  var i = 0;
  var retCSS = '';

  function addNewAttr () {
    // 
    if (!isParenthesisOpen) {
      var source = _$3.trim(css.slice(lastPos, i));
      var j = source.indexOf(':');
      if (j !== -1) {
        var name = _$3.trim(source.slice(0, j));
        var value = _$3.trim(source.slice(j + 1));
        // 
        if (name) {
          var ret = onAttr(lastPos, retCSS.length, name, value, source);
          if (ret) retCSS += ret + '; ';
        }
      }
    }
    lastPos = i + 1;
  }

  for (; i < cssLength; i++) {
    var c = css[i];
    if (c === '/' && css[i + 1] === '*') {
      // 
      var j = css.indexOf('*/', i + 2);
      // 
      if (j === -1) break;
      // 
      i = j + 1;
      lastPos = i + 1;
      isParenthesisOpen = false;
    } else if (c === '(') {
      isParenthesisOpen = true;
    } else if (c === ')') {
      isParenthesisOpen = false;
    } else if (c === ';') {
      if (isParenthesisOpen) ; else {
        addNewAttr();
      }
    } else if (c === '\n') {
      addNewAttr();
    }
  }

  return _$3.trim(retCSS);
}

var parser$2 = parseStyle$1;

/**
 * cssfilter
 *
 * @author <leizongmin@gmail.com>
 */

var DEFAULT$1 = _default;
var parseStyle = parser$2;


/**
 * 
 *
 * @param {Object} obj
 * @return {Boolean}
 */
function isNull$1 (obj) {
  return (obj === undefined || obj === null);
}

/**
 * 
 *
 * @param {Object} obj
 * @return {Object}
 */
function shallowCopyObject$1 (obj) {
  var ret = {};
  for (var i in obj) {
    ret[i] = obj[i];
  }
  return ret;
}

/**
 * CSS
 *
 * @param {Object} options
 *   - {Object} whiteList
 *   - {Function} onAttr
 *   - {Function} onIgnoreAttr
 *   - {Function} safeAttrValue
 */
function FilterCSS$2 (options) {
  options = shallowCopyObject$1(options || {});
  options.whiteList = options.whiteList || DEFAULT$1.whiteList;
  options.onAttr = options.onAttr || DEFAULT$1.onAttr;
  options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT$1.onIgnoreAttr;
  options.safeAttrValue = options.safeAttrValue || DEFAULT$1.safeAttrValue;
  this.options = options;
}

FilterCSS$2.prototype.process = function (css) {
  // 
  css = css || '';
  css = css.toString();
  if (!css) return '';

  var me = this;
  var options = me.options;
  var whiteList = options.whiteList;
  var onAttr = options.onAttr;
  var onIgnoreAttr = options.onIgnoreAttr;
  var safeAttrValue = options.safeAttrValue;

  var retCSS = parseStyle(css, function (sourcePosition, position, name, value, source) {

    var check = whiteList[name];
    var isWhite = false;
    if (check === true) isWhite = check;
    else if (typeof check === 'function') isWhite = check(value);
    else if (check instanceof RegExp) isWhite = check.test(value);
    if (isWhite !== true) isWhite = false;

    //  value 
    value = safeAttrValue(name, value);
    if (!value) return;

    var opts = {
      position: position,
      sourcePosition: sourcePosition,
      source: source,
      isWhite: isWhite
    };

    if (isWhite) {

      var ret = onAttr(name, value, opts);
      if (isNull$1(ret)) {
        return name + ':' + value;
      } else {
        return ret;
      }

    } else {

      var ret = onIgnoreAttr(name, value, opts);
      if (!isNull$1(ret)) {
        return ret;
      }

    }
  });

  return retCSS;
};


var css = FilterCSS$2;

/**
 * cssfilter
 *
 * @author <leizongmin@gmail.com>
 */

(function (module, exports) {
	var DEFAULT = _default;
	var FilterCSS = css;


	/**
	 * XSS
	 *
	 * @param {String} css CSS
	 * @param {Object} options whiteList, onAttr, onIgnoreAttr
	 * @return {String}
	 */
	function filterCSS (html, options) {
	  var xss = new FilterCSS(options);
	  return xss.process(html);
	}


	// 
	exports = module.exports = filterCSS;
	exports.FilterCSS = FilterCSS;
	for (var i in DEFAULT) exports[i] = DEFAULT[i];
} (lib, lib.exports));

var util = {
  indexOf: function (arr, item) {
    var i, j;
    if (Array.prototype.indexOf) {
      return arr.indexOf(item);
    }
    for (i = 0, j = arr.length; i < j; i++) {
      if (arr[i] === item) {
        return i;
      }
    }
    return -1;
  },
  forEach: function (arr, fn, scope) {
    var i, j;
    if (Array.prototype.forEach) {
      return arr.forEach(fn, scope);
    }
    for (i = 0, j = arr.length; i < j; i++) {
      fn.call(scope, arr[i], i, arr);
    }
  },
  trim: function (str) {
    if (String.prototype.trim) {
      return str.trim();
    }
    return str.replace(/(^\s*)|(\s*$)/g, "");
  },
  spaceIndex: function (str) {
    var reg = /\s|\n|\t/;
    var match = reg.exec(str);
    return match ? match.index : -1;
  },
};

/**
 * default settings
 *
 * @author Zongmin Lei<leizongmin@gmail.com>
 */

var FilterCSS$1 = lib.exports.FilterCSS;
var getDefaultCSSWhiteList = lib.exports.getDefaultWhiteList;
var _$2 = util;

function getDefaultWhiteList() {
  return {
    a: ["target", "href", "title"],
    abbr: ["title"],
    address: [],
    area: ["shape", "coords", "href", "alt"],
    article: [],
    aside: [],
    audio: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "preload",
      "src",
    ],
    b: [],
    bdi: ["dir"],
    bdo: ["dir"],
    big: [],
    blockquote: ["cite"],
    br: [],
    caption: [],
    center: [],
    cite: [],
    code: [],
    col: ["align", "valign", "span", "width"],
    colgroup: ["align", "valign", "span", "width"],
    dd: [],
    del: ["datetime"],
    details: ["open"],
    div: [],
    dl: [],
    dt: [],
    em: [],
    figcaption: [],
    figure: [],
    font: ["color", "size", "face"],
    footer: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    header: [],
    hr: [],
    i: [],
    img: ["src", "alt", "title", "width", "height"],
    ins: ["datetime"],
    li: [],
    mark: [],
    nav: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    section: [],
    small: [],
    span: [],
    sub: [],
    summary: [],
    sup: [],
    strong: [],
    strike: [],
    table: ["width", "border", "align", "valign"],
    tbody: ["align", "valign"],
    td: ["width", "rowspan", "colspan", "align", "valign"],
    tfoot: ["align", "valign"],
    th: ["width", "rowspan", "colspan", "align", "valign"],
    thead: ["align", "valign"],
    tr: ["rowspan", "align", "valign"],
    tt: [],
    u: [],
    ul: [],
    video: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "playsinline",
      "poster",
      "preload",
      "src",
      "height",
      "width",
    ],
  };
}

var defaultCSSFilter = new FilterCSS$1();

/**
 * default onTag function
 *
 * @param {String} tag
 * @param {String} html
 * @param {Object} options
 * @return {String}
 */
function onTag(tag, html, options) {
  // do nothing
}

/**
 * default onIgnoreTag function
 *
 * @param {String} tag
 * @param {String} html
 * @param {Object} options
 * @return {String}
 */
function onIgnoreTag(tag, html, options) {
  // do nothing
}

/**
 * default onTagAttr function
 *
 * @param {String} tag
 * @param {String} name
 * @param {String} value
 * @return {String}
 */
function onTagAttr(tag, name, value) {
  // do nothing
}

/**
 * default onIgnoreTagAttr function
 *
 * @param {String} tag
 * @param {String} name
 * @param {String} value
 * @return {String}
 */
function onIgnoreTagAttr(tag, name, value) {
  // do nothing
}

/**
 * default escapeHtml function
 *
 * @param {String} html
 */
function escapeHtml(html) {
  return html.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
}

/**
 * default safeAttrValue function
 *
 * @param {String} tag
 * @param {String} name
 * @param {String} value
 * @param {Object} cssFilter
 * @return {String}
 */
function safeAttrValue(tag, name, value, cssFilter) {
  // unescape attribute value firstly
  value = friendlyAttrValue(value);

  if (name === "href" || name === "src") {
    // filter `href` and `src` attribute
    // only allow the value that starts with `http://` | `https://` | `mailto:` | `/` | `#`
    value = _$2.trim(value);
    if (value === "#") return "#";
    if (
      !(
        value.substr(0, 7) === "http://" ||
        value.substr(0, 8) === "https://" ||
        value.substr(0, 7) === "mailto:" ||
        value.substr(0, 4) === "tel:" ||
        value.substr(0, 11) === "data:image/" ||
        value.substr(0, 6) === "ftp://" ||
        value.substr(0, 2) === "./" ||
        value.substr(0, 3) === "../" ||
        value[0] === "#" ||
        value[0] === "/"
      )
    ) {
      return "";
    }
  } else if (name === "background") {
    // filter `background` attribute (maybe no use)
    // `javascript:`
    REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
      return "";
    }
  } else if (name === "style") {
    // `expression()`
    REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
      return "";
    }
    // `url()`
    REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
      REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
        return "";
      }
    }
    if (cssFilter !== false) {
      cssFilter = cssFilter || defaultCSSFilter;
      value = cssFilter.process(value);
    }
  }

  // escape `<>"` before returns
  value = escapeAttrValue(value);
  return value;
}

// RegExp list
var REGEXP_LT = /</g;
var REGEXP_GT = />/g;
var REGEXP_QUOTE = /"/g;
var REGEXP_QUOTE_2 = /&quot;/g;
var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
// var REGEXP_DEFAULT_ON_TAG_ATTR_3 = /\/\*|\*\//gm;
var REGEXP_DEFAULT_ON_TAG_ATTR_4 =
  /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi;
// var REGEXP_DEFAULT_ON_TAG_ATTR_5 = /^[\s"'`]*(d\s*a\s*t\s*a\s*)\:/gi;
// var REGEXP_DEFAULT_ON_TAG_ATTR_6 = /^[\s"'`]*(d\s*a\s*t\s*a\s*)\:\s*image\//gi;
var REGEXP_DEFAULT_ON_TAG_ATTR_7 =
  /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;

/**
 * escape double quote
 *
 * @param {String} str
 * @return {String} str
 */
function escapeQuote(str) {
  return str.replace(REGEXP_QUOTE, "&quot;");
}

/**
 * unescape double quote
 *
 * @param {String} str
 * @return {String} str
 */
function unescapeQuote(str) {
  return str.replace(REGEXP_QUOTE_2, '"');
}

/**
 * escape html entities
 *
 * @param {String} str
 * @return {String}
 */
function escapeHtmlEntities(str) {
  return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str, code) {
    return code[0] === "x" || code[0] === "X"
      ? String.fromCharCode(parseInt(code.substr(1), 16))
      : String.fromCharCode(parseInt(code, 10));
  });
}

/**
 * escape html5 new danger entities
 *
 * @param {String} str
 * @return {String}
 */
function escapeDangerHtml5Entities(str) {
  return str
    .replace(REGEXP_ATTR_VALUE_COLON, ":")
    .replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
}

/**
 * clear nonprintable characters
 *
 * @param {String} str
 * @return {String}
 */
function clearNonPrintableCharacter(str) {
  var str2 = "";
  for (var i = 0, len = str.length; i < len; i++) {
    str2 += str.charCodeAt(i) < 32 ? " " : str.charAt(i);
  }
  return _$2.trim(str2);
}

/**
 * get friendly attribute value
 *
 * @param {String} str
 * @return {String}
 */
function friendlyAttrValue(str) {
  str = unescapeQuote(str);
  str = escapeHtmlEntities(str);
  str = escapeDangerHtml5Entities(str);
  str = clearNonPrintableCharacter(str);
  return str;
}

/**
 * unescape attribute value
 *
 * @param {String} str
 * @return {String}
 */
function escapeAttrValue(str) {
  str = escapeQuote(str);
  str = escapeHtml(str);
  return str;
}

/**
 * `onIgnoreTag` function for removing all the tags that are not in whitelist
 */
function onIgnoreTagStripAll() {
  return "";
}

/**
 * remove tag body
 * specify a `tags` list, if the tag is not in the `tags` list then process by the specify function (optional)
 *
 * @param {array} tags
 * @param {function} next
 */
function StripTagBody(tags, next) {
  if (typeof next !== "function") {
    next = function () {};
  }

  var isRemoveAllTag = !Array.isArray(tags);
  function isRemoveTag(tag) {
    if (isRemoveAllTag) return true;
    return _$2.indexOf(tags, tag) !== -1;
  }

  var removeList = [];
  var posStart = false;

  return {
    onIgnoreTag: function (tag, html, options) {
      if (isRemoveTag(tag)) {
        if (options.isClosing) {
          var ret = "[/removed]";
          var end = options.position + ret.length;
          removeList.push([
            posStart !== false ? posStart : options.position,
            end,
          ]);
          posStart = false;
          return ret;
        } else {
          if (!posStart) {
            posStart = options.position;
          }
          return "[removed]";
        }
      } else {
        return next(tag, html, options);
      }
    },
    remove: function (html) {
      var rethtml = "";
      var lastPos = 0;
      _$2.forEach(removeList, function (pos) {
        rethtml += html.slice(lastPos, pos[0]);
        lastPos = pos[1];
      });
      rethtml += html.slice(lastPos);
      return rethtml;
    },
  };
}

/**
 * remove html comments
 *
 * @param {String} html
 * @return {String}
 */
function stripCommentTag(html) {
  var retHtml = "";
  var lastPos = 0;
  while (lastPos < html.length) {
    var i = html.indexOf("<!--", lastPos);
    if (i === -1) {
      retHtml += html.slice(lastPos);
      break;
    }
    retHtml += html.slice(lastPos, i);
    var j = html.indexOf("-->", i);
    if (j === -1) {
      break;
    }
    lastPos = j + 3;
  }
  return retHtml;
}

/**
 * remove invisible characters
 *
 * @param {String} html
 * @return {String}
 */
function stripBlankChar(html) {
  var chars = html.split("");
  chars = chars.filter(function (char) {
    var c = char.charCodeAt(0);
    if (c === 127) return false;
    if (c <= 31) {
      if (c === 10 || c === 13) return true;
      return false;
    }
    return true;
  });
  return chars.join("");
}

_default$1.whiteList = getDefaultWhiteList();
_default$1.getDefaultWhiteList = getDefaultWhiteList;
_default$1.onTag = onTag;
_default$1.onIgnoreTag = onIgnoreTag;
_default$1.onTagAttr = onTagAttr;
_default$1.onIgnoreTagAttr = onIgnoreTagAttr;
_default$1.safeAttrValue = safeAttrValue;
_default$1.escapeHtml = escapeHtml;
_default$1.escapeQuote = escapeQuote;
_default$1.unescapeQuote = unescapeQuote;
_default$1.escapeHtmlEntities = escapeHtmlEntities;
_default$1.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
_default$1.clearNonPrintableCharacter = clearNonPrintableCharacter;
_default$1.friendlyAttrValue = friendlyAttrValue;
_default$1.escapeAttrValue = escapeAttrValue;
_default$1.onIgnoreTagStripAll = onIgnoreTagStripAll;
_default$1.StripTagBody = StripTagBody;
_default$1.stripCommentTag = stripCommentTag;
_default$1.stripBlankChar = stripBlankChar;
_default$1.cssFilter = defaultCSSFilter;
_default$1.getDefaultCSSWhiteList = getDefaultCSSWhiteList;

var parser$1 = {};

/**
 * Simple HTML Parser
 *
 * @author Zongmin Lei<leizongmin@gmail.com>
 */

var _$1 = util;

/**
 * get tag name
 *
 * @param {String} html e.g. '<a hef="#">'
 * @return {String}
 */
function getTagName(html) {
  var i = _$1.spaceIndex(html);
  var tagName;
  if (i === -1) {
    tagName = html.slice(1, -1);
  } else {
    tagName = html.slice(1, i + 1);
  }
  tagName = _$1.trim(tagName).toLowerCase();
  if (tagName.slice(0, 1) === "/") tagName = tagName.slice(1);
  if (tagName.slice(-1) === "/") tagName = tagName.slice(0, -1);
  return tagName;
}

/**
 * is close tag?
 *
 * @param {String} html '<a hef="#">'
 * @return {Boolean}
 */
function isClosing(html) {
  return html.slice(0, 2) === "</";
}

/**
 * parse input html and returns processed html
 *
 * @param {String} html
 * @param {Function} onTag e.g. function (sourcePosition, position, tag, html, isClosing)
 * @param {Function} escapeHtml
 * @return {String}
 */
function parseTag$1(html, onTag, escapeHtml) {

  var rethtml = "";
  var lastPos = 0;
  var tagStart = false;
  var quoteStart = false;
  var currentPos = 0;
  var len = html.length;
  var currentTagName = "";
  var currentHtml = "";

  chariterator: for (currentPos = 0; currentPos < len; currentPos++) {
    var c = html.charAt(currentPos);
    if (tagStart === false) {
      if (c === "<") {
        tagStart = currentPos;
        continue;
      }
    } else {
      if (quoteStart === false) {
        if (c === "<") {
          rethtml += escapeHtml(html.slice(lastPos, currentPos));
          tagStart = currentPos;
          lastPos = currentPos;
          continue;
        }
        if (c === ">") {
          rethtml += escapeHtml(html.slice(lastPos, tagStart));
          currentHtml = html.slice(tagStart, currentPos + 1);
          currentTagName = getTagName(currentHtml);
          rethtml += onTag(
            tagStart,
            rethtml.length,
            currentTagName,
            currentHtml,
            isClosing(currentHtml)
          );
          lastPos = currentPos + 1;
          tagStart = false;
          continue;
        }
        if (c === '"' || c === "'") {
          var i = 1;
          var ic = html.charAt(currentPos - i);

          while (ic.trim() === "" || ic === "=") {
            if (ic === "=") {
              quoteStart = c;
              continue chariterator;
            }
            ic = html.charAt(currentPos - ++i);
          }
        }
      } else {
        if (c === quoteStart) {
          quoteStart = false;
          continue;
        }
      }
    }
  }
  if (lastPos < html.length) {
    rethtml += escapeHtml(html.substr(lastPos));
  }

  return rethtml;
}

var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9\\_:.-]/gim;

/**
 * parse input attributes and returns processed attributes
 *
 * @param {String} html e.g. `href="#" target="_blank"`
 * @param {Function} onAttr e.g. `function (name, value)`
 * @return {String}
 */
function parseAttr$1(html, onAttr) {

  var lastPos = 0;
  var lastMarkPos = 0;
  var retAttrs = [];
  var tmpName = false;
  var len = html.length;

  function addAttr(name, value) {
    name = _$1.trim(name);
    name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, "").toLowerCase();
    if (name.length < 1) return;
    var ret = onAttr(name, value || "");
    if (ret) retAttrs.push(ret);
  }

  // 
  for (var i = 0; i < len; i++) {
    var c = html.charAt(i);
    var v, j;
    if (tmpName === false && c === "=") {
      tmpName = html.slice(lastPos, i);
      lastPos = i + 1;
      lastMarkPos = html.charAt(lastPos) === '"' || html.charAt(lastPos) === "'" ? lastPos : findNextQuotationMark(html, i + 1);
      continue;
    }
    if (tmpName !== false) {
      if (
        i === lastMarkPos
      ) {
        j = html.indexOf(c, i + 1);
        if (j === -1) {
          break;
        } else {
          v = _$1.trim(html.slice(lastMarkPos + 1, j));
          addAttr(tmpName, v);
          tmpName = false;
          i = j;
          lastPos = i + 1;
          continue;
        }
      }
    }
    if (/\s|\n|\t/.test(c)) {
      html = html.replace(/\s|\n|\t/g, " ");
      if (tmpName === false) {
        j = findNextEqual(html, i);
        if (j === -1) {
          v = _$1.trim(html.slice(lastPos, i));
          addAttr(v);
          tmpName = false;
          lastPos = i + 1;
          continue;
        } else {
          i = j - 1;
          continue;
        }
      } else {
        j = findBeforeEqual(html, i - 1);
        if (j === -1) {
          v = _$1.trim(html.slice(lastPos, i));
          v = stripQuoteWrap(v);
          addAttr(tmpName, v);
          tmpName = false;
          lastPos = i + 1;
          continue;
        } else {
          continue;
        }
      }
    }
  }

  if (lastPos < html.length) {
    if (tmpName === false) {
      addAttr(html.slice(lastPos));
    } else {
      addAttr(tmpName, stripQuoteWrap(_$1.trim(html.slice(lastPos))));
    }
  }

  return _$1.trim(retAttrs.join(" "));
}

function findNextEqual(str, i) {
  for (; i < str.length; i++) {
    var c = str[i];
    if (c === " ") continue;
    if (c === "=") return i;
    return -1;
  }
}

function findNextQuotationMark(str, i) {
  for (; i < str.length; i++) {
    var c = str[i];
    if (c === " ") continue;
    if (c === "'" || c === '"') return i;
    return -1;
  }
}

function findBeforeEqual(str, i) {
  for (; i > 0; i--) {
    var c = str[i];
    if (c === " ") continue;
    if (c === "=") return i;
    return -1;
  }
}

function isQuoteWrapString(text) {
  if (
    (text[0] === '"' && text[text.length - 1] === '"') ||
    (text[0] === "'" && text[text.length - 1] === "'")
  ) {
    return true;
  } else {
    return false;
  }
}

function stripQuoteWrap(text) {
  if (isQuoteWrapString(text)) {
    return text.substr(1, text.length - 2);
  } else {
    return text;
  }
}

parser$1.parseTag = parseTag$1;
parser$1.parseAttr = parseAttr$1;

/**
 * filter xss
 *
 * @author Zongmin Lei<leizongmin@gmail.com>
 */

var FilterCSS = lib.exports.FilterCSS;
var DEFAULT = _default$1;
var parser = parser$1;
var parseTag = parser.parseTag;
var parseAttr = parser.parseAttr;
var _ = util;

/**
 * returns `true` if the input value is `undefined` or `null`
 *
 * @param {Object} obj
 * @return {Boolean}
 */
function isNull(obj) {
  return obj === undefined || obj === null;
}

/**
 * get attributes for a tag
 *
 * @param {String} html
 * @return {Object}
 *   - {String} html
 *   - {Boolean} closing
 */
function getAttrs(html) {
  var i = _.spaceIndex(html);
  if (i === -1) {
    return {
      html: "",
      closing: html[html.length - 2] === "/",
    };
  }
  html = _.trim(html.slice(i + 1, -1));
  var isClosing = html[html.length - 1] === "/";
  if (isClosing) html = _.trim(html.slice(0, -1));
  return {
    html: html,
    closing: isClosing,
  };
}

/**
 * shallow copy
 *
 * @param {Object} obj
 * @return {Object}
 */
function shallowCopyObject(obj) {
  var ret = {};
  for (var i in obj) {
    ret[i] = obj[i];
  }
  return ret;
}

function keysToLowerCase(obj) {
  var ret = {};
  for (var i in obj) {
    if (Array.isArray(obj[i])) {
      ret[i.toLowerCase()] = obj[i].map(function (item) {
        return item.toLowerCase();
      });
    } else {
      ret[i.toLowerCase()] = obj[i];
    }
  }
  return ret;
}

/**
 * FilterXSS class
 *
 * @param {Object} options
 *        whiteList (or allowList), onTag, onTagAttr, onIgnoreTag,
 *        onIgnoreTagAttr, safeAttrValue, escapeHtml
 *        stripIgnoreTagBody, allowCommentTag, stripBlankChar
 *        css{whiteList, onAttr, onIgnoreAttr} `css=false` means don't use `cssfilter`
 */
function FilterXSS(options) {
  options = shallowCopyObject(options || {});

  if (options.stripIgnoreTag) {
    if (options.onIgnoreTag) {
      console.error(
        'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
      );
    }
    options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
  }
  if (options.whiteList || options.allowList) {
    options.whiteList = keysToLowerCase(options.whiteList || options.allowList);
  } else {
    options.whiteList = DEFAULT.whiteList;
  }

  options.onTag = options.onTag || DEFAULT.onTag;
  options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
  options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
  options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
  options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
  options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
  this.options = options;

  if (options.css === false) {
    this.cssFilter = false;
  } else {
    options.css = options.css || {};
    this.cssFilter = new FilterCSS(options.css);
  }
}

/**
 * start process and returns result
 *
 * @param {String} html
 * @return {String}
 */
FilterXSS.prototype.process = function (html) {
  // compatible with the input
  html = html || "";
  html = html.toString();
  if (!html) return "";

  var me = this;
  var options = me.options;
  var whiteList = options.whiteList;
  var onTag = options.onTag;
  var onIgnoreTag = options.onIgnoreTag;
  var onTagAttr = options.onTagAttr;
  var onIgnoreTagAttr = options.onIgnoreTagAttr;
  var safeAttrValue = options.safeAttrValue;
  var escapeHtml = options.escapeHtml;
  var cssFilter = me.cssFilter;

  // remove invisible characters
  if (options.stripBlankChar) {
    html = DEFAULT.stripBlankChar(html);
  }

  // remove html comments
  if (!options.allowCommentTag) {
    html = DEFAULT.stripCommentTag(html);
  }

  // if enable stripIgnoreTagBody
  var stripIgnoreTagBody = false;
  if (options.stripIgnoreTagBody) {
    stripIgnoreTagBody = DEFAULT.StripTagBody(
      options.stripIgnoreTagBody,
      onIgnoreTag
    );
    onIgnoreTag = stripIgnoreTagBody.onIgnoreTag;
  }

  var retHtml = parseTag(
    html,
    function (sourcePosition, position, tag, html, isClosing) {
      var info = {
        sourcePosition: sourcePosition,
        position: position,
        isClosing: isClosing,
        isWhite: Object.prototype.hasOwnProperty.call(whiteList, tag),
      };

      // call `onTag()`
      var ret = onTag(tag, html, info);
      if (!isNull(ret)) return ret;

      if (info.isWhite) {
        if (info.isClosing) {
          return "</" + tag + ">";
        }

        var attrs = getAttrs(html);
        var whiteAttrList = whiteList[tag];
        var attrsHtml = parseAttr(attrs.html, function (name, value) {
          // call `onTagAttr()`
          var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;
          var ret = onTagAttr(tag, name, value, isWhiteAttr);
          if (!isNull(ret)) return ret;

          if (isWhiteAttr) {
            // call `safeAttrValue()`
            value = safeAttrValue(tag, name, value, cssFilter);
            if (value) {
              return name + '="' + value + '"';
            } else {
              return name;
            }
          } else {
            // call `onIgnoreTagAttr()`
            ret = onIgnoreTagAttr(tag, name, value, isWhiteAttr);
            if (!isNull(ret)) return ret;
            return;
          }
        });

        // build new tag html
        html = "<" + tag;
        if (attrsHtml) html += " " + attrsHtml;
        if (attrs.closing) html += " /";
        html += ">";
        return html;
      } else {
        // call `onIgnoreTag()`
        ret = onIgnoreTag(tag, html, info);
        if (!isNull(ret)) return ret;
        return escapeHtml(html);
      }
    },
    escapeHtml
  );

  // if enable stripIgnoreTagBody
  if (stripIgnoreTagBody) {
    retHtml = stripIgnoreTagBody.remove(retHtml);
  }

  return retHtml;
};

var xss = FilterXSS;

/**
 * xss
 *
 * @author Zongmin Lei<leizongmin@gmail.com>
 */

(function (module, exports) {
	var DEFAULT = _default$1;
	var parser = parser$1;
	var FilterXSS = xss;

	/**
	 * filter xss function
	 *
	 * @param {String} html
	 * @param {Object} options { whiteList, onTag, onTagAttr, onIgnoreTag, onIgnoreTagAttr, safeAttrValue, escapeHtml }
	 * @return {String}
	 */
	function filterXSS(html, options) {
	  var xss = new FilterXSS(options);
	  return xss.process(html);
	}

	exports = module.exports = filterXSS;
	exports.filterXSS = filterXSS;
	exports.FilterXSS = FilterXSS;

	(function () {
	  for (var i in DEFAULT) {
	    exports[i] = DEFAULT[i];
	  }
	  for (var j in parser) {
	    exports[j] = parser[j];
	  }
	})();

	// using `xss` on the WebWorker, output `filterXSS` to the globals
	function isWorkerEnv() {
	  return (
	    typeof self !== "undefined" &&
	    typeof DedicatedWorkerGlobalScope !== "undefined" &&
	    self instanceof DedicatedWorkerGlobalScope
	  );
	}
	if (isWorkerEnv()) {
	  self.filterXSS = module.exports;
	}
} (lib$1, lib$1.exports));

/* Copyright (c) 2020 Environmental Systems Research Institute, Inc.
 * Apache-2.0
 *
 * js-xss
 * Copyright (c) 2012-2018 Zongmin Lei() <leizongmin@gmail.com>
 * http://ucdok.com
 * The MIT License, see
 * https://github.com/leizongmin/js-xss/blob/master/LICENSE for details
 * */
/**
 * The Sanitizer Class
 *
 * @export
 * @class Sanitizer
 */
var Sanitizer = /** @class */ (function () {
    function Sanitizer(filterOptions, extendDefaults) {
        var _this = this;
        // Supported HTML Spec: https://doc.arcgis.com/en/arcgis-online/reference/supported-html.htm
        this.arcgisWhiteList = {
            a: ["href", "style", "target"],
            abbr: ["title"],
            audio: ["autoplay", "controls", "loop", "muted", "preload"],
            b: [],
            br: [],
            dd: ["style"],
            div: ["align", "style"],
            dl: ["style"],
            dt: ["style"],
            em: [],
            figcaption: ["style"],
            figure: ["style"],
            font: ["color", "face", "size", "style"],
            h1: ["style"],
            h2: ["style"],
            h3: ["style"],
            h4: ["style"],
            h5: ["style"],
            h6: ["style"],
            hr: [],
            i: [],
            img: ["alt", "border", "height", "src", "style", "width"],
            li: [],
            ol: [],
            p: ["style"],
            source: ["media", "src", "type"],
            span: ["style"],
            strong: [],
            sub: ["style"],
            sup: ["style"],
            table: ["border", "cellpadding", "cellspacing", "height", "style", "width"],
            tbody: [],
            tr: ["align", "height", "style", "valign"],
            td: [
                "align",
                "colspan",
                "height",
                "nowrap",
                "rowspan",
                "style",
                "valign",
                "width",
            ],
            th: [
                "align",
                "colspan",
                "height",
                "nowrap",
                "rowspan",
                "style",
                "valign",
                "width",
            ],
            u: [],
            ul: [],
            video: [
                "autoplay",
                "controls",
                "height",
                "loop",
                "muted",
                "poster",
                "preload",
                "width",
            ],
        };
        this.allowedProtocols = [
            "http",
            "https",
            "mailto",
            "iform",
            "tel",
            "flow",
            "lfmobile",
            "arcgis-navigator",
            "arcgis-appstudio-player",
            "arcgis-survey123",
            "arcgis-collector",
            "arcgis-workforce",
            "arcgis-explorer",
            "arcgis-trek2there",
            "arcgis-quickcapture",
            "mspbi",
            "comgooglemaps",
            "pdfefile",
            "pdfehttp",
            "pdfehttps",
            "boxapp",
            "boxemm",
            "awb",
            "awbs",
            "gropen",
            "radarscope",
        ];
        this.arcgisFilterOptions = {
            allowCommentTag: true,
            safeAttrValue: function (tag, name, value, cssFilter) {
                // Take over safe attribute filtering for `a` `href`, `img` `src`,
                // and `source` `src` attributes, otherwise pass onto the
                // default `XSS.safeAttrValue` method.
                if ((tag === "a" && name === "href") ||
                    ((tag === "img" || tag === "source") && name === "src")) {
                    return _this.sanitizeUrl(value);
                }
                return lib$1.exports.safeAttrValue(tag, name, value, cssFilter);
            },
        };
        this._entityMap = {
            "&": "&#x38;",
            "<": "&#x3C;",
            ">": "&#x3E;",
            '"': "&#x22;",
            "'": "&#x27;",
            "/": "&#x2F;",
        };
        var xssFilterOptions;
        if (filterOptions && !extendDefaults) {
            // Override the defaults
            xssFilterOptions = filterOptions;
        }
        else if (filterOptions && extendDefaults) {
            // Extend the defaults
            xssFilterOptions = Object.create(this.arcgisFilterOptions);
            Object.keys(filterOptions).forEach(function (key) {
                if (key === "whiteList") {
                    // Extend the whitelist by concatenating arrays
                    xssFilterOptions.whiteList = _this._extendObjectOfArrays([
                        _this.arcgisWhiteList,
                        filterOptions.whiteList || {},
                    ]);
                }
                else {
                    xssFilterOptions[key] = filterOptions[key];
                }
            });
        }
        else {
            // Only use the defaults
            xssFilterOptions = Object.create(this.arcgisFilterOptions);
            xssFilterOptions.whiteList = this.arcgisWhiteList;
        }
        this.xssFilterOptions = xssFilterOptions;
        // Make this readable to tests
        this._xssFilter = new lib$1.exports.FilterXSS(xssFilterOptions);
    }
    /**
     * Sanitizes value to remove invalid HTML tags.
     *
     * Note: If the value passed does not contain a valid JSON data type (String,
     * Number, JSON Object, Array, Boolean, or null), the value will be nullified.
     *
     * @param {any} value The value to sanitize.
     * @returns {any} The sanitized value.
     * @memberof Sanitizer
     */
    Sanitizer.prototype.sanitize = function (value, options) {
        if (options === void 0) { options = {}; }
        switch (typeof value) {
            case "number":
                if (isNaN(value) || !isFinite(value)) {
                    return null;
                }
                return value;
            case "boolean":
                return value;
            case "string":
                return this._xssFilter.process(value);
            case "object":
                return this._iterateOverObject(value, options);
            default:
                if (options.allowUndefined && typeof value === "undefined") {
                    return;
                }
                return null;
        }
    };
    /**
     * Sanitizes a URL string following the allowed protocols and sanitization rules.
     *
     * @param {string} value The URL to sanitize.
     * @param {{ isProtocolRequired: boolean }} options Configuration options for URL checking.
     * @returns {string} The sanitized URL if it's valid, or an empty string if the URL is invalid.
     */
    Sanitizer.prototype.sanitizeUrl = function (value, options) {
        var _a = (options !== null && options !== void 0 ? options : {}).isProtocolRequired, isProtocolRequired = _a === void 0 ? true : _a;
        var protocol = this._trim(value.substring(0, value.indexOf(":")));
        var isRootUrl = value === '/';
        var isUrlFragment = /^#/.test(value);
        var isValidProtocol = protocol && this.allowedProtocols.indexOf(protocol.toLowerCase()) > -1;
        if (isRootUrl || isUrlFragment || isValidProtocol) {
            return lib$1.exports.escapeAttrValue(value);
        }
        if (!protocol && !isProtocolRequired) {
            return lib$1.exports.escapeAttrValue("https://".concat(value));
        }
        return "";
    };
    /**
     * Sanitizes an HTML attribute value.
     *
     * @param {string} tag The tagname of the HTML element.
     * @param {string} attribute The attribute name of the HTML element.
     * @param {string} value The raw value to be used for the HTML attribute value.
     * @param {XSS.ICSSFilter} [cssFilter] The CSS filter to be used.
     * @returns {string} The sanitized attribute value.
     * @memberof Sanitizer
     */
    Sanitizer.prototype.sanitizeHTMLAttribute = function (tag, attribute, value, cssFilter) {
        // use the custom safeAttrValue function if provided
        if (typeof this.xssFilterOptions.safeAttrValue === "function") {
            return this.xssFilterOptions.safeAttrValue(tag, attribute, value, 
            // @ts-expect-error safeAttrValue does handle undefined cssFilter
            cssFilter);
        }
        // otherwise use the default
        // @ts-ignore safeAttrValue does handle undefined cssFilter
        return lib$1.exports.safeAttrValue(tag, attribute, value, cssFilter);
    };
    /**
     * Checks if a value only contains valid HTML.
     *
     * @param {any} value The value to validate.
     * @returns {boolean}
     * @memberof Sanitizer
     */
    Sanitizer.prototype.validate = function (value, options) {
        if (options === void 0) { options = {}; }
        var sanitized = this.sanitize(value, options);
        return {
            isValid: value === sanitized,
            sanitized: sanitized,
        };
    };
    /**
     * Encodes the following characters, `& < > \" ' /` to their hexadecimal HTML entity code.
     * Example: "&middot;" => "&#x38;middot;"
     *
     * @param {string} value The value to encode.
     * @returns {string} The encoded string value.
     * @memberof Sanitizer
     */
    Sanitizer.prototype.encodeHTML = function (value) {
        var _this = this;
        return String(value).replace(/[&<>"'\/]/g, function (s) {
            return _this._entityMap[s];
        });
    };
    /**
     * Encodes all non-alphanumeric ASCII characters to their hexadecimal HTML entity codes.
     * Example: "alert(document.cookie)" => "alert&#x28;document&#x2e;cookie&#x29;"
     *
     * @param {string} value The value to encode.
     * @returns {string} The encoded string value.
     * @memberof Sanitizer
     */
    Sanitizer.prototype.encodeAttrValue = function (value) {
        var alphanumericRE = /^[a-zA-Z0-9]$/;
        return String(value).replace(/[\x00-\xFF]/g, function (c, idx) {
            return !alphanumericRE.test(c)
                ? "&#x".concat(Number(value.charCodeAt(idx)).toString(16), ";")
                : c;
        });
    };
    /**
     * Extends an object of arrays by by concatenating arrays of the same object
     * keys. If the if the previous key's value is not an array, the next key's
     * value will replace the previous key. This method is used for extending the
     * whiteList in the XSS filter options.
     *
     * @private
     * @param {Array<{}>} objects An array of objects.
     * @returns {{}} The extended object.
     * @memberof Sanitizer
     */
    Sanitizer.prototype._extendObjectOfArrays = function (objects) {
        var finalObj = {};
        objects.forEach(function (obj) {
            Object.keys(obj).forEach(function (key) {
                if (Array.isArray(obj[key]) && Array.isArray(finalObj[key])) {
                    finalObj[key] = finalObj[key].concat(obj[key]);
                }
                else {
                    finalObj[key] = obj[key];
                }
            });
        });
        return finalObj;
    };
    /**
     * Iterate over a plain object or array to deeply sanitize each value.
     *
     * @private
     * @param {object} obj The object to iterate over.
     * @returns {(object | null)} The sanitized object.
     * @memberof Sanitizer
     */
    Sanitizer.prototype._iterateOverObject = function (obj, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        try {
            var hasChanged_1 = false;
            var changedObj = void 0;
            if (Array.isArray(obj)) {
                changedObj = obj.reduce(function (prev, value) {
                    var validation = _this.validate(value, options);
                    if (validation.isValid) {
                        return prev.concat([value]);
                    }
                    else {
                        hasChanged_1 = true;
                        return prev.concat([validation.sanitized]);
                    }
                }, []);
            }
            else if (!isPlainObject(obj)) {
                if (options.allowUndefined && typeof obj === "undefined") {
                    return;
                }
                return null;
            }
            else {
                var keys = Object.keys(obj);
                changedObj = keys.reduce(function (prev, key) {
                    var value = obj[key];
                    var validation = _this.validate(value, options);
                    if (validation.isValid) {
                        prev[key] = value;
                    }
                    else {
                        hasChanged_1 = true;
                        prev[key] = validation.sanitized;
                    }
                    return prev;
                }, {});
            }
            if (hasChanged_1) {
                return changedObj;
            }
            return obj;
        }
        catch (err) {
            return null;
        }
    };
    /**
     * Trim whitespace from the start and ends of a string.
     * @param {string} val The string to trim.
     * @returns {string} The trimmed string.
     */
    Sanitizer.prototype._trim = function (val) {
        // @ts-ignore This is used by Jest,
        // but TypeScript errors since it assumes `trim` is always available.
        return String.prototype.trim
            ? val.trim()
            : val.replace(/(^\s*)|(\s*$)/g, "");
    };
    return Sanitizer;
}());




/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/components/dom.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/components/dom.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": () => (/* binding */ isFocusable),
/* harmony export */   "B": () => (/* binding */ tabbableOptions),
/* harmony export */   "C": () => (/* binding */ CSS_UTILITY),
/* harmony export */   "a": () => (/* binding */ autoMode),
/* harmony export */   "b": () => (/* binding */ getSlotted),
/* harmony export */   "c": () => (/* binding */ getElementDir),
/* harmony export */   "d": () => (/* binding */ darkMode),
/* harmony export */   "e": () => (/* binding */ slotChangeHasAssignedElement),
/* harmony export */   "f": () => (/* binding */ setRequestedIcon),
/* harmony export */   "g": () => (/* binding */ getElementProp),
/* harmony export */   "h": () => (/* binding */ focusElementInGroup),
/* harmony export */   "i": () => (/* binding */ isPrimaryPointerButton),
/* harmony export */   "j": () => (/* binding */ focusElement),
/* harmony export */   "k": () => (/* binding */ focusFirstTabbable),
/* harmony export */   "l": () => (/* binding */ ensureId),
/* harmony export */   "m": () => (/* binding */ intersects),
/* harmony export */   "n": () => (/* binding */ nodeListToArray),
/* harmony export */   "o": () => (/* binding */ getRootNode),
/* harmony export */   "p": () => (/* binding */ filterDirectChildren),
/* harmony export */   "q": () => (/* binding */ getModeName),
/* harmony export */   "r": () => (/* binding */ closestElementCrossShadowBoundary),
/* harmony export */   "s": () => (/* binding */ slotChangeGetAssignedElements),
/* harmony export */   "t": () => (/* binding */ toAriaBoolean),
/* harmony export */   "u": () => (/* binding */ queryElementRoots),
/* harmony export */   "v": () => (/* binding */ getShadowRootNode),
/* harmony export */   "w": () => (/* binding */ containsCrossShadowBoundary),
/* harmony export */   "x": () => (/* binding */ tabbable),
/* harmony export */   "y": () => (/* binding */ focusable),
/* harmony export */   "z": () => (/* binding */ isTabbable)
/* harmony export */ });
/* harmony import */ var _guid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./guid.js */ "./node_modules/@esri/calcite-components/dist/components/guid.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.4.2
 */


const autoMode = "calcite-mode-auto";
const darkMode = "calcite-mode-dark";
const lightMode = "calcite-mode-light";
const CSS_UTILITY = {
  autoMode,
  darkMode,
  lightMode,
  rtl: "calcite--rtl",
  calciteAnimate: "calcite-animate",
  calciteAnimateIn: "calcite-animate__in",
  calciteAnimateInUp: "calcite-animate__in-up",
  calciteAnimateInDown: "calcite-animate__in-down",
  calciteAnimateInRight: "calcite-animate__in-right",
  calciteAnimateInLeft: "calcite-animate__in-left",
  calciteAnimateInScale: "calcite-animate__in-scale"
};

/*!
* tabbable 6.1.2
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
// NOTE: separate `:not()` selectors has broader browser support than the newer
//  `:not([inert], [inert] *)` (Feb 2023)
// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes
//  the entire query to fail, resulting in no nodes found, which will break a lot
//  of things... so we have to rely on JS to identify nodes inside an inert container
var candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable="false"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];
var candidateSelector = /* #__PURE__ */candidateSelectors.join(',');
var NoElement = typeof Element === 'undefined';
var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode$1 = !NoElement && Element.prototype.getRootNode ? function (element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function (element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};

/**
 * Determines if a node is inert or in an inert ancestor.
 * @param {Element} [node]
 * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to
 *  see if any of them are inert. If false, only `node` itself is considered.
 * @returns {boolean} True if inert itself or by way of being in an inert ancestor.
 *  False if `node` is falsy.
 */
var isInert = function isInert(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`
  //  JS API property; we have to check the attribute, which can either be empty or 'true';
  //  if it's `null` (not specified) or 'false', it's an active element
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');
  var inert = inertAtt === '' || inertAtt === 'true';

  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`
  //  if it weren't for `matches()` not being a function on shadow roots; the following
  //  code works for any kind of node
  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`
  //  so it likely would not support `:is([inert] *)` either...
  var result = inert || lookUp && node && isInert(node.parentNode); // recursive

  return result;
};

/**
 * Determines if a node's content is editable.
 * @param {Element} [node]
 * @returns True if it's content-editable; false if it's not or `node` is falsy.
 */
var isContentEditable = function isContentEditable(node) {
  var _node$getAttribute2;
  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have
  //  to use the attribute directly to check for this, which can either be empty or 'true';
  //  if it's `null` (not specified) or 'false', it's a non-editable element
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');
  return attValue === '' || attValue === 'true';
};

/**
 * @param {Element} el container to check in
 * @param {boolean} includeContainer add container to check
 * @param {(node: Element) => boolean} filter filter candidates
 * @returns {Element[]}
 */
var getCandidates = function getCandidates(el, includeContainer, filter) {
  // even if `includeContainer=false`, we still have to check it for inertness because
  //  if it's inert, all its children are inert
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};

/**
 * @callback GetShadowRoot
 * @param {Element} element to check for shadow root
 * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.
 */

/**
 * @callback ShadowRootFilter
 * @param {Element} shadowHostNode the element which contains shadow content
 * @returns {boolean} true if a shadow root could potentially contain valid candidates.
 */

/**
 * @typedef {Object} CandidateScope
 * @property {Element} scopeParent contains inner candidates
 * @property {Element[]} candidates list of candidates found in the scope parent
 */

/**
 * @typedef {Object} IterativeOptions
 * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;
 *  if a function, implies shadow support is enabled and either returns the shadow root of an element
 *  or a boolean stating if it has an undisclosed shadow root
 * @property {(node: Element) => boolean} filter filter candidates
 * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list
 * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;
 */

/**
 * @param {Element[]} elements list of element containers to match candidates from
 * @param {boolean} includeContainer add container list to check
 * @param {IterativeOptions} options
 * @returns {Array.<Element|CandidateScope>}
 */
var getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      // no need to look up since we're drilling down
      // anything inside this container will also be inert
      continue;
    }
    if (element.tagName === 'SLOT') {
      // add shadow dom slot scope (slot itself cannot be focusable)
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      // check candidate element
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }

      // iterate over shadow content if possible
      var shadowRoot = element.shadowRoot ||
      // check for an undisclosed shadow
      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);

      // no inert look up because we're already drilling down and checking for inertness
      //  on the way down, so all containers to this root node should have already been
      //  vetted as non-inert
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed
        //  shadow exists, so look at light dom children as fallback BUT create a scope for any
        //  child candidates found because they're likely slotted elements (elements that are
        //  children of the web component element (which has the shadow), in the light dom, but
        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,
        //  _after_ we return from this recursive call
        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        // there's not shadow so just dig into the element's (light dom) children
        //  __without__ giving the element special scope treatment
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex(node, isScope) {
  if (node.tabIndex < 0) {
    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
    // yet they are still part of the regular tab order; in FF, they get a default
    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab
    // order, consider their tab index to be 0.
    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.
    //
    // isScope is positive for custom element with shadow root or slot that by default
    // have tabIndex -1, but need to be sorted by document order in order for their
    // content to be inserted in the correct position
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput(node) {
  return node.tagName === 'INPUT';
};
var isHiddenInput = function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
};
var isDetailsWithSummary = function isDetailsWithSummary(node) {
  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
    return child.tagName === 'SUMMARY';
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode$1(node);
  var queryRadios = function queryRadios(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio(node) {
  return isInput(node) && node.type === 'radio';
};
var isNonTabbableRadio = function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
};

// determines if a node is ultimately attached to the window's document
var isNodeAttached = function isNodeAttached(node) {
  var _nodeRoot;
  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
  //  (but NOT _the_ document; see second 'If' comment below for more).
  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
  //  is attached, and the one we need to check if it's in the document or not (because the
  //  shadow, and all nodes it contains, is never considered in the document since shadows
  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
  //  visibility, including all the nodes it contains). The host could be any normal node,
  //  or a custom element (i.e. web component). Either way, that's the one that is considered
  //  part of the document, not the shadow root, nor any of its children (i.e. the node being
  //  tested).
  // To further complicate things, we have to look all the way up until we find a shadow HOST
  //  that is attached (or find none) because the node might be in nested shadows...
  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
  //  document (per the docs) and while it's a Document-type object, that document does not
  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
  //  node is actually detached.
  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible
  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed
  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then
  //  `ownerDocument` will be `null`, hence the optional chaining on it.
  var nodeRoot = node && getRootNode$1(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;

  // in some cases, a detached node will return itself as the root instead of a document or
  //  shadow root object, in which case, we shouldn't try to look further up the host chain
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
      //  which means we need to get the host's host and check if that parent host is contained
      //  in (i.e. attached to) the document
      nodeRoot = getRootNode$1(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(),
    width = _node$getBoundingClie.width,
    height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden(node, _ref) {
  var displayCheck = _ref.displayCheck,
    getShadowRoot = _ref.getShadowRoot;
  // NOTE: visibility will be `undefined` if node is detached from the document
  //  (see notes about this further down), which means we will consider it visible
  //  (this is legacy behavior from a very long way back)
  // NOTE: we check this regardless of `displayCheck="none"` because this is a
  //  _visibility_ check, not a _display_ check
  if (getComputedStyle(node).visibility === 'hidden') {
    return true;
  }
  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
    return true;
  }
  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
    if (typeof getShadowRoot === 'function') {
      // figure out if we should consider the node to be in an undisclosed shadow and use the
      //  'non-zero-area' fallback
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode$1(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
        ) {
          // node has an undisclosed shadow which means we can only treat it as a black box, so we
          //  fall back to a non-zero-area test
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          // iterate up slot
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          // cross shadow boundary
          node = rootNode.host;
        } else {
          // iterate up normal dom
          node = parentElement;
        }
      }
      node = originalNode;
    }
    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
    //  it might be a falsy value, which means shadow DOM support is disabled

    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
    //  now we can just test to see if it would normally be visible or not, provided it's
    //  attached to the main document.
    // NOTE: We must consider case where node is inside a shadow DOM and given directly to
    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.

    if (isNodeAttached(node)) {
      // this works wherever the node is: if there's at least one client rect, it's
      //  somehow displayed; it also covers the CSS 'display: contents' case where the
      //  node itself is hidden in place of its contents; and there's no need to search
      //  up the hierarchy either
      return !node.getClientRects().length;
    }

    // Else, the node isn't attached to the document, which means the `getClientRects()`
    //  API will __always__ return zero rects (this can happen, for example, if React
    //  is used to render nodes onto a detached tree, as confirmed in this thread:
    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
    //
    // It also means that even window.getComputedStyle(node).display will return `undefined`
    //  because styles are only computed for nodes that are in the document.
    //
    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
    //  somehow. Though it was never stated officially, anyone who has ever used tabbable
    //  APIs on nodes in detached containers has actually implicitly used tabbable in what
    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
    //  considering __everything__ to be visible because of the innability to determine styles.
    //
    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
    //  nodes as visible with the 'none' fallback.__
    if (displayCheck !== 'legacy-full') {
      return true; // hidden
    }
    // else, fallback to 'none' mode and consider the node visible
  } else if (displayCheck === 'non-zero-area') {
    // NOTE: Even though this tests that the node's client rect is non-zero to determine
    //  whether it's displayed, and that a detached node will __always__ have a zero-area
    //  client rect, we don't special-case for whether the node is attached or not. In
    //  this mode, we do want to consider nodes that have a zero area to be hidden at all
    //  times, and that includes attached or not.
    return isZeroArea(node);
  }

  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
  //  it's visible
  return false;
};

// form fields (nested) inside a disabled fieldset are not focusable/tabbable
//  unless they are in the _first_ <legend> element of the top-most disabled
//  fieldset
var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    // check if `node` is contained in a disabled <fieldset>
    while (parentNode) {
      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
        // look for the first <legend> among the children of the disabled <fieldset>
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          // when the first <legend> (in document order) is found
          if (child.tagName === 'LEGEND') {
            // if its parent <fieldset> is not nested in another disabled <fieldset>,
            // return whether `node` is a descendant of its first <legend>
            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
          }
        }
        // the disabled <fieldset> containing `node` has no <legend>
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }

  // else, node's tabbable/focusable state should not be affected by a fieldset's
  //  enabled/disabled state
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
  if (node.disabled ||
  // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||
  // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  // If a custom element has an explicit negative tabindex,
  // browsers will not allow tab targeting said element's children.
  return false;
};

/**
 * @param {Array.<Element|CandidateScope>} candidates
 * @returns Element[]
 */
var sortByOrder = function sortByOrder(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function (item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item: item,
        isScope: isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');
var isFocusable = function isFocusable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

/**
 * The default `focus-trap/tabbable` options.
 *
 * See https://github.com/focus-trap/tabbable#tabbable
 */
const tabbableOptions = {
  getShadowRoot: true
};
/**
 * This helper will guarantee an ID on the provided element.
 *
 * If it already has an ID, it will be preserved, otherwise a unique one will be generated and assigned.
 *
 * @param {Element} el An element.
 * @returns {string} The element's ID.
 */
function ensureId(el) {
  if (!el) {
    return "";
  }
  return (el.id = el.id || `${el.tagName.toLowerCase()}-${(0,_guid_js__WEBPACK_IMPORTED_MODULE_0__.g)()}`);
}
/**
 * This helper returns an array from a NodeList.
 *
 * @param {NodeList} nodeList A NodeList.
 * @returns {Element[]} An array of elements.
 */
function nodeListToArray(nodeList) {
  return Array.isArray(nodeList) ? nodeList : Array.from(nodeList);
}
/**
 * This helper returns the Calcite "mode" of an element.
 *
 * @param {HTMLElement} el An element.
 * @returns {"light"|"dark"} The Calcite mode.
 */
function getModeName(el) {
  const closestElWithMode = closestElementCrossShadowBoundary(el, `.${CSS_UTILITY.darkMode}, .${CSS_UTILITY.lightMode}`);
  return closestElWithMode?.classList.contains("calcite-mode-dark") ? "dark" : "light";
}
/**
 * This helper returns the direction of a HTML element.
 *
 * @param {HTMLElement} el An element.
 * @returns {Direction} The direction.
 */
function getElementDir(el) {
  const prop = "dir";
  const selector = `[${prop}]`;
  const closest = closestElementCrossShadowBoundary(el, selector);
  return closest ? closest.getAttribute(prop) : "ltr";
}
/**
 * This helper returns the value of an attribute on an element.
 *
 * @param {HTMLElement} el An element.
 * @param {string} attribute An attribute name.
 * @param {any} fallbackValue A fallback value.
 * @returns {any} The value.
 * @deprecated
 */
function getElementProp(el, attribute, fallbackValue) {
  const selector = `[${attribute}]`;
  const closest = el.closest(selector);
  return closest ? closest.getAttribute(attribute) : fallbackValue;
}
/**
 * This helper returns the rootNode of an element.
 *
 * @param {Element} el An element.
 * @returns {Document|ShadowRoot} The element's root node.
 */
function getRootNode(el) {
  return el.getRootNode();
}
/**
 * This helper returns the node's shadowRoot root node if it exists.
 *
 * @param {Element} el The element.
 * @returns {ShadowRoot|null} The element's root node ShadowRoot.
 */
function getShadowRootNode(el) {
  const rootNode = getRootNode(el);
  return "host" in rootNode ? rootNode : null;
}
/**
 * This helper returns the host of a ShadowRoot.
 *
 * @param {Document | ShadowRoot} root A root element.
 * @returns {Element | null} The host element.
 */
function getHost(root) {
  return root.host || null;
}
/**
 * This helper queries an element's rootNode and any ancestor rootNodes.
 *
 * If both an 'id' and 'selector' are supplied, 'id' will take precedence over 'selector'.
 *
 * @param {Element} element An element.
 * @param root0
 * @param root0.selector
 * @param root0.id
 * @returns {Element} An element.
 */
function queryElementRoots(element, { selector, id }) {
  // Gets the rootNode and any ancestor rootNodes (shadowRoot or document) of an element and queries them for a selector.
  // Based on: https://stackoverflow.com/q/54520554/194216
  function queryFrom(el) {
    if (!el) {
      return null;
    }
    if (el.assignedSlot) {
      el = el.assignedSlot;
    }
    const rootNode = getRootNode(el);
    const found = id
      ? "getElementById" in rootNode
        ? /*
          Check to make sure 'getElementById' exists in cases where element is no longer connected to the DOM and getRootNode() returns the element.
          https://github.com/Esri/calcite-components/pull/4280
           */
          rootNode.getElementById(id)
        : null
      : selector
        ? rootNode.querySelector(selector)
        : null;
    const host = getHost(rootNode);
    return found ? found : host ? queryFrom(host) : null;
  }
  return queryFrom(element);
}
/**
 * This helper returns the closest element matching the selector by crossing he shadow boundary if necessary.
 *
 * @param {Element} element The starting element.
 * @param {string} selector The selector.
 * @returns {Element} The targeted element.
 */
function closestElementCrossShadowBoundary(element, selector) {
  // based on https://stackoverflow.com/q/54520554/194216
  function closestFrom(el) {
    return el ? el.closest(selector) || closestFrom(getHost(getRootNode(el))) : null;
  }
  return closestFrom(element);
}
/**
 * This utility helps invoke a callback as it traverses a node and its ancestors until reaching the root document.
 *
 * Returning early or undefined in `onVisit` will continue traversing up the DOM tree. Otherwise, traversal will halt with the returned value as the result of the function
 *
 * @param {Element} element An element.
 * @param {(node: Node) => Element} onVisit The callback.
 * @returns {Element} The result.
 */
function walkUpAncestry(element, onVisit) {
  return visit(element, onVisit);
}
function visit(node, onVisit) {
  if (!node) {
    return;
  }
  const result = onVisit(node);
  if (result !== undefined) {
    return result;
  }
  const { parentNode } = node;
  return visit(parentNode instanceof ShadowRoot ? parentNode.host : parentNode, onVisit);
}
/**
 * This helper returns true when an element has the descendant in question.
 *
 * @param {Element} element The starting element.
 * @param {Element} maybeDescendant The descendant.
 * @returns {boolean} The result.
 */
function containsCrossShadowBoundary(element, maybeDescendant) {
  return !!walkUpAncestry(maybeDescendant, (node) => (node === element ? true : undefined));
}
/**
 * This helper returns true when an element has a setFocus method.
 *
 * @param {Element} el An element.
 * @returns {boolean} The result.
 */
function isCalciteFocusable(el) {
  return typeof el?.setFocus === "function";
}
/**
 * This helper focuses an element using the `setFocus` method if available and falls back to using the `focus` method if not available.
 *
 * @param {Element} el An element.
 */
async function focusElement(el) {
  if (!el) {
    return;
  }
  return isCalciteFocusable(el) ? el.setFocus() : el.focus();
}
/**
 * Helper to focus the first tabbable element.
 *
 * @param {HTMLElement} element The html element containing tabbable elements.
 */
function focusFirstTabbable(element) {
  if (!element) {
    return;
  }
  (tabbable(element, tabbableOptions)[0] || element).focus();
}
const defaultSlotSelector = ":not([slot])";
function getSlotted(element, slotName, options) {
  if (slotName && !Array.isArray(slotName) && typeof slotName !== "string") {
    options = slotName;
    slotName = null;
  }
  const slotSelector = slotName
    ? Array.isArray(slotName)
      ? slotName.map((name) => `[slot="${name}"]`).join(",")
      : `[slot="${slotName}"]`
    : defaultSlotSelector;
  if (options?.all) {
    return queryMultiple(element, slotSelector, options);
  }
  return querySingle(element, slotSelector, options);
}
function getDirectChildren(el, selector) {
  return el ? Array.from(el.children || []).filter((child) => child?.matches(selector)) : [];
}
function queryMultiple(element, slotSelector, options) {
  let matches = slotSelector === defaultSlotSelector
    ? getDirectChildren(element, defaultSlotSelector)
    : Array.from(element.querySelectorAll(slotSelector));
  matches = options && options.direct === false ? matches : matches.filter((el) => el.parentElement === element);
  matches = options?.matches ? matches.filter((el) => el?.matches(options.matches)) : matches;
  const selector = options?.selector;
  return selector
    ? matches
      .map((item) => Array.from(item.querySelectorAll(selector)))
      .reduce((previousValue, currentValue) => [...previousValue, ...currentValue], [])
      .filter((match) => !!match)
    : matches;
}
function querySingle(element, slotSelector, options) {
  let match = slotSelector === defaultSlotSelector
    ? getDirectChildren(element, defaultSlotSelector)[0] || null
    : element.querySelector(slotSelector);
  match = options && options.direct === false ? match : match?.parentElement === element ? match : null;
  match = options?.matches ? (match?.matches(options.matches) ? match : null) : match;
  const selector = options?.selector;
  return selector ? match?.querySelector(selector) : match;
}
/**
 * Filters direct children.
 *
 * @param {Element} el An element.
 * @param {string} selector The selector.
 * @returns {Element[]} An array of elements.
 */
function filterDirectChildren(el, selector) {
  return Array.from(el.children).filter((child) => child.matches(selector));
}
/**
 * Set a default icon from a defined set or allow an override with an icon name string
 *
 * @param {Record<string, string>} iconObject The icon object.
 * @param {string | boolean} iconValue The icon value.
 * @param {string} matchedValue The matched value.
 * @returns {string|undefined} The resulting icon value.
 */
function setRequestedIcon(iconObject, iconValue, matchedValue) {
  if (typeof iconValue === "string" && iconValue !== "") {
    return iconValue;
  }
  else if (iconValue === "") {
    return iconObject[matchedValue];
  }
}
/**
 * This helper returns true when two rectangles intersect.
 *
 * @param {DOMRect} rect1 The first rectangle.
 * @param {DOMRect} rect2 The second rectangle.
 * @returns {boolean} The result.
 */
function intersects(rect1, rect2) {
  return !(rect2.left > rect1.right ||
    rect2.right < rect1.left ||
    rect2.top > rect1.bottom ||
    rect2.bottom < rect1.top);
}
/**
 * This helper makes sure that boolean aria attributes are properly converted to a string.
 *
 * It should only be used for aria attributes that require a string value of "true" or "false".
 *
 * @param {boolean} value The value.
 * @returns {string} The string conversion of a boolean value ("true" | "false").
 */
function toAriaBoolean(value) {
  return Boolean(value).toString();
}
/**
 * This helper returns `true` if the target `slot` element from the `onSlotchange` event has an assigned element.
 *
 * ```
 * <slot onSlotchange={(event) => this.mySlotHasElement = slotChangeHasAssignedElement(event)} />}
 * ```
 *
 * @param {Event} event The event.
 * @returns {boolean} Whether the slot has any assigned elements.
 */
function slotChangeHasAssignedElement(event) {
  return !!slotChangeGetAssignedElements(event).length;
}
/**
 * This helper returns the assigned elements on a `slot` element from the `onSlotchange` event.
 *
 * ```
 * <slot onSlotchange={(event) => this.mySlotElements = slotChangeGetAssignedElements(event)} />}
 * ```
 *
 * @param {Event} event The event.
 * @returns {boolean} Whether the slot has any assigned elements.
 */
function slotChangeGetAssignedElements(event) {
  return event.target.assignedElements({
    flatten: true
  });
}
/**
 * This helper returns true if the pointer event fired from the primary button of the device.
 *
 * See https://www.w3.org/TR/pointerevents/#the-button-property.
 *
 * @param {PointerEvent} event The pointer event.
 * @returns {boolean} The value.
 */
function isPrimaryPointerButton(event) {
  return !!(event.isPrimary && event.button === 0);
}
/**
 * This helper sets focus on and returns a destination element from within a group of provided elements.
 *
 * @param {Element[]} elements An array of elements.
 * @param {Element} currentElement The current element.
 * @param {FocusElementInGroupDestination} destination The target destination element to focus.
 * @param {boolean} cycle Should navigation cycle through elements or stop at extent - defaults to true.
 * @returns {Element} The focused element
 */
const focusElementInGroup = (elements, currentElement, destination, cycle = true) => {
  const currentIndex = elements.indexOf(currentElement);
  const isFirstItem = currentIndex === 0;
  const isLastItem = currentIndex === elements.length - 1;
  if (cycle) {
    destination =
      destination === "previous" && isFirstItem ? "last" : destination === "next" && isLastItem ? "first" : destination;
  }
  let focusTarget;
  if (destination === "previous") {
    focusTarget = elements[currentIndex - 1] || elements[cycle ? elements.length - 1 : currentIndex];
  }
  else if (destination === "next") {
    focusTarget = elements[currentIndex + 1] || elements[cycle ? 0 : currentIndex];
  }
  else if (destination === "last") {
    focusTarget = elements[elements.length - 1];
  }
  else {
    focusTarget = elements[0];
  }
  focusElement(focusTarget);
  return focusTarget;
};




/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/components/guid.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/components/guid.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "g": () => (/* binding */ guid)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.4.2
 */
function gen(counts) {
  return counts
    .map((count) => {
    let out = "";
    for (let i = 0; i < count; i++) {
      out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    }
    return out;
  })
    .join("-");
}
const guid = () => gen([2, 1, 1, 1, 3]);




/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/components/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/components/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAssetPath": () => (/* reexport safe */ _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_0__.getAssetPath),
/* harmony export */   "setAssetPath": () => (/* reexport safe */ _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_0__.setAssetPath),
/* harmony export */   "setNonce": () => (/* reexport safe */ _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_0__.setNonce),
/* harmony export */   "setPlatformOptions": () => (/* reexport safe */ _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_0__.setPlatformOptions)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/client/index.js */ "./node_modules/@stencil/core/internal/client/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@esri/calcite-components/dist/components/dom.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.4.2
 */



/**
 * Emits when the mode is dynamically toggled between light and dark on <body> or in OS preferences.
 */
function initModeChangeEvent() {
  const { classList } = document.body;
  const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
  const getMode = () => classList.contains(_dom_js__WEBPACK_IMPORTED_MODULE_1__.d) || (classList.contains(_dom_js__WEBPACK_IMPORTED_MODULE_1__.a) && prefersDark) ? "dark" : "light";
  const emitModeChange = (mode) => document.body.dispatchEvent(new CustomEvent("calciteModeChange", { bubbles: true, detail: { mode } }));
  const modeChangeHandler = (newMode) => {
    currentMode !== newMode && emitModeChange(newMode);
    currentMode = newMode;
  };
  let currentMode = getMode();
  // emits event on page load
  emitModeChange(currentMode);
  // emits event when changing OS mode preferences
  window
    .matchMedia("(prefers-color-scheme: dark)")
    .addEventListener("change", (event) => modeChangeHandler(event.matches ? "dark" : "light"));
  // emits event when toggling between mode classes on <body>
  new MutationObserver(() => modeChangeHandler(getMode())).observe(document.body, {
    attributes: true,
    attributeFilter: ["class"]
  });
}

/**
 * This file is imported in Stencil's `globalScript` config option.
 *
 * @see {@link https://stenciljs.com/docs/config#globalscript}
 */
function appGlobalScript () {
  const isBrowser = typeof window !== "undefined" &&
    typeof location !== "undefined" &&
    typeof document !== "undefined" &&
    window.location === location &&
    window.document === document;
  if (isBrowser) {
    if (document.readyState === "interactive") {
      initModeChangeEvent();
    }
    else {
      document.addEventListener("DOMContentLoaded", () => initModeChangeEvent(), { once: true });
    }
  }
}

const globalScripts = appGlobalScript;

globalScripts();


/***/ }),

/***/ "./node_modules/@stencil/core/internal/app-data/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/app-data/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BUILD": () => (/* binding */ BUILD),
/* harmony export */   "Env": () => (/* binding */ Env),
/* harmony export */   "NAMESPACE": () => (/* binding */ NAMESPACE)
/* harmony export */ });
const BUILD = {
    allRenderFn: false,
    cmpDidLoad: true,
    cmpDidUnload: false,
    cmpDidUpdate: true,
    cmpDidRender: true,
    cmpWillLoad: true,
    cmpWillUpdate: true,
    cmpWillRender: true,
    connectedCallback: true,
    disconnectedCallback: true,
    element: true,
    event: true,
    hasRenderFn: true,
    lifecycle: true,
    hostListener: true,
    hostListenerTargetWindow: true,
    hostListenerTargetDocument: true,
    hostListenerTargetBody: true,
    hostListenerTargetParent: false,
    hostListenerTarget: true,
    member: true,
    method: true,
    mode: true,
    observeAttribute: true,
    prop: true,
    propMutable: true,
    reflect: true,
    scoped: true,
    shadowDom: true,
    slot: true,
    cssAnnotations: true,
    state: true,
    style: true,
    svg: true,
    updatable: true,
    vdomAttribute: true,
    vdomXlink: true,
    vdomClass: true,
    vdomFunctional: true,
    vdomKey: true,
    vdomListener: true,
    vdomRef: true,
    vdomPropOrAttr: true,
    vdomRender: true,
    vdomStyle: true,
    vdomText: true,
    watchCallback: true,
    taskQueue: true,
    hotModuleReplacement: false,
    isDebug: false,
    isDev: false,
    isTesting: false,
    hydrateServerSide: false,
    hydrateClientSide: false,
    lifecycleDOMEvents: false,
    lazyLoad: false,
    profile: false,
    slotRelocation: true,
    appendChildSlotFix: false,
    cloneNodeFix: false,
    hydratedAttribute: false,
    hydratedClass: true,
    safari10: false,
    scriptDataOpts: false,
    scopedSlotTextContentFix: false,
    shadowDomShim: false,
    slotChildNodesFix: false,
    invisiblePrehydration: true,
    propBoolean: true,
    propNumber: true,
    propString: true,
    cssVarShim: false,
    constructableCSS: true,
    cmpShouldUpdate: true,
    devTools: false,
    dynamicImportShim: false,
    shadowDelegatesFocus: true,
    initializeNextTick: false,
    asyncLoading: false,
    asyncQueue: false,
    transformTagName: false,
    attachStyles: true,
};
const Env = {};
const NAMESPACE = /* default */ 'app';




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYjJlYTExOTM1ZTY1YTRiZjMzNjdkZjU4MGNkMmYyODguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRTtBQUNuRTtBQUNBLFdBQVcsd0VBQVc7QUFDdEI7QUFDQTtBQUNBLGVBQWUsNEVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEVBQWE7QUFDckIsMEJBQTBCLE9BQU8sR0FBRyxRQUFRLEdBQUcsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTyxNQUFNLFFBQVE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEVBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkVBQWM7QUFDdEIsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUZBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlGQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2RUFBNkUscURBQVcscUNBQXFDLG9EQUFVO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0RUFBNEUscURBQVcscUNBQXFDLG9EQUFVO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRTJCO0FBQzNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtB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VTtBQUNsQixRQUFRLFVBQVU7QUFDbEI7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaLFFBQVEsUUFBUTtBQUNoQixRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlDQUFpQztBQUMvQztBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVEsVUFBVTtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLCtCQUErQjtBQUNoRCxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZLE9BQU87QUFDNUM7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxjQUFjLFlBQVk7QUFDbEY7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsR0FBRztBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRTBDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25qRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsNEJBQTRCO0FBQ3ZDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxvQkFBb0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsV0FBVztBQUN6Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLHVCQUF1QixpREFBaUQ7QUFDdEY7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsU0FBUztBQUN2QixjQUFjLGtCQUFrQjtBQUNoQzs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxrQkFBa0I7QUFDN0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseUJBQXlCLEdBQUcsMkNBQUksR0FBRztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBLHNFQUFzRSxxQkFBcUIsS0FBSyxzQkFBc0I7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLHlCQUF5QjtBQUNwQyxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUMsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3RUFBd0U7QUFDL0Y7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1RUFBdUU7QUFDOUY7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ3BCOzs7Ozs7Ozs7Ozs7Ozs7QUN6NkJocEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFcUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEJyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tIO0FBQzFEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBLDJDQUEyQyxzQ0FBUSx5QkFBeUIsc0NBQVE7QUFDcEYsc0dBQXNHLHlCQUF5QixRQUFRO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFlBQVk7QUFDL0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9mb2N1cy10cmFwL2Rpc3QvZm9jdXMtdHJhcC5lc20uanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy90YWJiYWJsZS9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS9jb3JlL2RvbVV0aWxzLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL2NvcmUvdXVpZC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS9pZGVudGl0eS9JZGVudGl0eUZvcm0uanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvaWRlbnRpdHkvSWRlbnRpdHlNYW5hZ2VyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL2lkZW50aXR5L0lkZW50aXR5TWFuYWdlckJhc2UuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvaWRlbnRpdHkvSWRlbnRpdHlNb2RhbC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS9pZGVudGl0eS9PQXV0aENyZWRlbnRpYWwuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvaWRlbnRpdHkvT0F1dGhJbmZvLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL2lkZW50aXR5L1NlcnZlckluZm8uanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvbGlicy9tYXF1ZXR0ZS1hZHZhbmNlZC1wcm9qZWN0b3IvYWR2YW5jZWQtcHJvamVjdG9yLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvbGlicy9tYXF1ZXR0ZS1hZHZhbmNlZC1wcm9qZWN0b3IvcHJvamVjdG9yLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL2xpYnMvbWFxdWV0dGUtYWR2YW5jZWQtcHJvamVjdG9yL3V0aWxzLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL2xpYnMvbWFxdWV0dGUvZG9tLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL2xpYnMvbWFxdWV0dGUvcHJvamVjdGlvbi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS9saWJzL21hcXVldHRlL3Byb2plY3Rvci5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS9zdXBwb3J0L3RoZW1lVXRpbHMuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvd2lkZ2V0cy9XaWRnZXQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvd2lkZ2V0cy9zdXBwb3J0L2NvbXBvbmVudHNVdGlscy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS93aWRnZXRzL3N1cHBvcnQvZGVjb3JhdG9ycy9hY2Nlc3NpYmxlSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS93aWRnZXRzL3N1cHBvcnQvZGVjb3JhdG9ycy9tZXNzYWdlQnVuZGxlLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3dpZGdldHMvc3VwcG9ydC9kZWNvcmF0b3JzL3ZtRXZlbnQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvd2lkZ2V0cy9zdXBwb3J0L2pzeEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvd2lkZ2V0cy9zdXBwb3J0L2pzeFdpZGdldFN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvd2lkZ2V0cy9zdXBwb3J0L3N5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvd2lkZ2V0cy9zdXBwb3J0L3Rlc3RzLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3dpZGdldHMvc3VwcG9ydC92bm9kZUNhY2hlLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFyY2dpcy9jb3JlL3dpZGdldHMvc3VwcG9ydC93aWRnZXQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvd2lkZ2V0cy9zdXBwb3J0L3dpZGdldFV0aWxzLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvYXJjZ2lzLWh0bWwtc2FuaXRpemVyL2Rpc3QvZXNtL2luZGV4LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Rpc3QvY29tcG9uZW50cy9kb20uanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jb21wb25lbnRzL2d1aWQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jb21wb25lbnRzL2luZGV4LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc25hYmJkb20vc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIE1vZGlmaWVkIGZvciBTdGVuY2lsJ3MgcmVuZGVyZXIgYW5kIHNsb3QgcHJvamVjdGlvblxuICovXG5sZXQgc2NvcGVJZDtcbmxldCBjb250ZW50UmVmO1xubGV0IGhvc3RUYWdOYW1lO1xubGV0IGN1c3RvbUVycm9yO1xubGV0IGkgPSAwO1xubGV0IHVzZU5hdGl2ZVNoYWRvd0RvbSA9IGZhbHNlO1xubGV0IGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IGZhbHNlO1xubGV0IGNoZWNrU2xvdFJlbG9jYXRlID0gZmFsc2U7XG5sZXQgaXNTdmdNb2RlID0gZmFsc2U7XG5sZXQgcmVuZGVyaW5nUmVmID0gbnVsbDtcbmxldCBxdWV1ZUNvbmdlc3Rpb24gPSAwO1xubGV0IHF1ZXVlUGVuZGluZyA9IGZhbHNlO1xuLypcbiBTdGVuY2lsIENsaWVudCBQbGF0Zm9ybSB2Mi4yMi4zIHwgTUlUIExpY2Vuc2VkIHwgaHR0cHM6Ly9zdGVuY2lsanMuY29tXG4gKi9cbmltcG9ydCB7IEJVSUxELCBOQU1FU1BBQ0UgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhJztcbmNvbnN0IEJ1aWxkID0ge1xuICAgIGlzRGV2OiBCVUlMRC5pc0RldiA/IHRydWUgOiBmYWxzZSxcbiAgICBpc0Jyb3dzZXI6IHRydWUsXG4gICAgaXNTZXJ2ZXI6IGZhbHNlLFxuICAgIGlzVGVzdGluZzogQlVJTEQuaXNUZXN0aW5nID8gdHJ1ZSA6IGZhbHNlLFxufTtcbmNvbnN0IENvbnRleHQgPSB7fTtcbmNvbnN0IGdldEFzc2V0UGF0aCA9IChwYXRoKSA9PiB7XG4gICAgY29uc3QgYXNzZXRVcmwgPSBuZXcgVVJMKHBhdGgsIHBsdC4kcmVzb3VyY2VzVXJsJCk7XG4gICAgcmV0dXJuIGFzc2V0VXJsLm9yaWdpbiAhPT0gd2luLmxvY2F0aW9uLm9yaWdpbiA/IGFzc2V0VXJsLmhyZWYgOiBhc3NldFVybC5wYXRobmFtZTtcbn07XG5jb25zdCBzZXRBc3NldFBhdGggPSAocGF0aCkgPT4gKHBsdC4kcmVzb3VyY2VzVXJsJCA9IHBhdGgpO1xuY29uc3QgY3JlYXRlVGltZSA9IChmbk5hbWUsIHRhZ05hbWUgPSAnJykgPT4ge1xuICAgIGlmIChCVUlMRC5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1hcmspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYHN0OiR7Zm5OYW1lfToke3RhZ05hbWV9OiR7aSsrfWA7XG4gICAgICAgIC8vIFN0YXJ0XG4gICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoa2V5KTtcbiAgICAgICAgLy8gRW5kXG4gICAgICAgIHJldHVybiAoKSA9PiBwZXJmb3JtYW5jZS5tZWFzdXJlKGBbU3RlbmNpbF0gJHtmbk5hbWV9KCkgPCR7dGFnTmFtZX0+YCwga2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IHVuaXF1ZVRpbWUgPSAoa2V5LCBtZWFzdXJlVGV4dCkgPT4ge1xuICAgIGlmIChCVUlMRC5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1hcmspIHtcbiAgICAgICAgaWYgKHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoa2V5LCAnbWFyaycpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyayhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShtZWFzdXJlVGV4dCwgJ21lYXN1cmUnKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKG1lYXN1cmVUZXh0LCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgaW5zcGVjdCA9IChyZWYpID0+IHtcbiAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihyZWYpO1xuICAgIGlmICghaG9zdFJlZikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBmbGFncyA9IGhvc3RSZWYuJGZsYWdzJDtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXJDb3VudDogaG9zdFJlZi4kcmVuZGVyQ291bnQkLFxuICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgaGFzUmVuZGVyZWQ6ICEhKGZsYWdzICYgMiAvKiBIT1NUX0ZMQUdTLmhhc1JlbmRlcmVkICovKSxcbiAgICAgICAgICAgIGhhc0Nvbm5lY3RlZDogISEoZmxhZ3MgJiAxIC8qIEhPU1RfRkxBR1MuaGFzQ29ubmVjdGVkICovKSxcbiAgICAgICAgICAgIGlzV2FpdGluZ0ZvckNoaWxkcmVuOiAhIShmbGFncyAmIDQgLyogSE9TVF9GTEFHUy5pc1dhaXRpbmdGb3JDaGlsZHJlbiAqLyksXG4gICAgICAgICAgICBpc0NvbnN0cnVjdGluZ0luc3RhbmNlOiAhIShmbGFncyAmIDggLyogSE9TVF9GTEFHUy5pc0NvbnN0cnVjdGluZ0luc3RhbmNlICovKSxcbiAgICAgICAgICAgIGlzUXVldWVkRm9yVXBkYXRlOiAhIShmbGFncyAmIDE2IC8qIEhPU1RfRkxBR1MuaXNRdWV1ZWRGb3JVcGRhdGUgKi8pLFxuICAgICAgICAgICAgaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQ6ICEhKGZsYWdzICYgMzIgLyogSE9TVF9GTEFHUy5oYXNJbml0aWFsaXplZENvbXBvbmVudCAqLyksXG4gICAgICAgICAgICBoYXNMb2FkZWRDb21wb25lbnQ6ICEhKGZsYWdzICYgNjQgLyogSE9TVF9GTEFHUy5oYXNMb2FkZWRDb21wb25lbnQgKi8pLFxuICAgICAgICAgICAgaXNXYXRjaFJlYWR5OiAhIShmbGFncyAmIDEyOCAvKiBIT1NUX0ZMQUdTLmlzV2F0Y2hSZWFkeSAqLyksXG4gICAgICAgICAgICBpc0xpc3RlblJlYWR5OiAhIShmbGFncyAmIDI1NiAvKiBIT1NUX0ZMQUdTLmlzTGlzdGVuUmVhZHkgKi8pLFxuICAgICAgICAgICAgbmVlZHNSZXJlbmRlcjogISEoZmxhZ3MgJiA1MTIgLyogSE9TVF9GTEFHUy5uZWVkc1JlcmVuZGVyICovKSxcbiAgICAgICAgfSxcbiAgICAgICAgaW5zdGFuY2VWYWx1ZXM6IGhvc3RSZWYuJGluc3RhbmNlVmFsdWVzJCxcbiAgICAgICAgYW5jZXN0b3JDb21wb25lbnQ6IGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JCxcbiAgICAgICAgaG9zdEVsZW1lbnQsXG4gICAgICAgIGxhenlJbnN0YW5jZTogaG9zdFJlZi4kbGF6eUluc3RhbmNlJCxcbiAgICAgICAgdm5vZGU6IGhvc3RSZWYuJHZub2RlJCxcbiAgICAgICAgbW9kZU5hbWU6IGhvc3RSZWYuJG1vZGVOYW1lJCxcbiAgICAgICAgb25SZWFkeVByb21pc2U6IGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJCxcbiAgICAgICAgb25SZWFkeVJlc29sdmU6IGhvc3RSZWYuJG9uUmVhZHlSZXNvbHZlJCxcbiAgICAgICAgb25JbnN0YW5jZVByb21pc2U6IGhvc3RSZWYuJG9uSW5zdGFuY2VQcm9taXNlJCxcbiAgICAgICAgb25JbnN0YW5jZVJlc29sdmU6IGhvc3RSZWYuJG9uSW5zdGFuY2VSZXNvbHZlJCxcbiAgICAgICAgb25SZW5kZXJSZXNvbHZlOiBob3N0UmVmLiRvblJlbmRlclJlc29sdmUkLFxuICAgICAgICBxdWV1ZWRMaXN0ZW5lcnM6IGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQsXG4gICAgICAgIHJtTGlzdGVuZXJzOiBob3N0UmVmLiRybUxpc3RlbmVycyQsXG4gICAgICAgIFsncy1pZCddOiBob3N0RWxlbWVudFsncy1pZCddLFxuICAgICAgICBbJ3MtY3InXTogaG9zdEVsZW1lbnRbJ3MtY3InXSxcbiAgICAgICAgWydzLWxyJ106IGhvc3RFbGVtZW50WydzLWxyJ10sXG4gICAgICAgIFsncy1wJ106IGhvc3RFbGVtZW50WydzLXAnXSxcbiAgICAgICAgWydzLXJjJ106IGhvc3RFbGVtZW50WydzLXJjJ10sXG4gICAgICAgIFsncy1zYyddOiBob3N0RWxlbWVudFsncy1zYyddLFxuICAgIH07XG59O1xuY29uc3QgaW5zdGFsbERldlRvb2xzID0gKCkgPT4ge1xuICAgIGlmIChCVUlMRC5kZXZUb29scykge1xuICAgICAgICBjb25zdCBzdGVuY2lsID0gKHdpbi5zdGVuY2lsID0gd2luLnN0ZW5jaWwgfHwge30pO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluc3BlY3QgPSBzdGVuY2lsLmluc3BlY3Q7XG4gICAgICAgIHN0ZW5jaWwuaW5zcGVjdCA9IChyZWYpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBpbnNwZWN0KHJlZik7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCAmJiB0eXBlb2Ygb3JpZ2luYWxJbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gb3JpZ2luYWxJbnNwZWN0KHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCBDT05URU5UX1JFRl9JRCA9ICdyJztcbmNvbnN0IE9SR19MT0NBVElPTl9JRCA9ICdvJztcbmNvbnN0IFNMT1RfTk9ERV9JRCA9ICdzJztcbmNvbnN0IFRFWFRfTk9ERV9JRCA9ICd0JztcbmNvbnN0IEhZRFJBVEVfSUQgPSAncy1pZCc7XG5jb25zdCBIWURSQVRFRF9TVFlMRV9JRCA9ICdzdHktaWQnO1xuY29uc3QgSFlEUkFURV9DSElMRF9JRCA9ICdjLWlkJztcbmNvbnN0IEhZRFJBVEVEX0NTUyA9ICd7dmlzaWJpbGl0eTpoaWRkZW59Lmh5ZHJhdGVke3Zpc2liaWxpdHk6aW5oZXJpdH0nO1xuY29uc3QgWExJTktfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG4vKipcbiAqIERlZmF1bHQgc3R5bGUgbW9kZSBpZFxuICovXG4vKipcbiAqIFJldXNhYmxlIGVtcHR5IG9iai9hcnJheVxuICogRG9uJ3QgYWRkIHZhbHVlcyB0byB0aGVzZSEhXG4gKi9cbmNvbnN0IEVNUFRZX09CSiA9IHt9O1xuLyoqXG4gKiBOYW1lc3BhY2VzXG4gKi9cbmNvbnN0IFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5jb25zdCBIVE1MX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuY29uc3QgaXNEZWYgPSAodikgPT4gdiAhPSBudWxsO1xuY29uc3QgaXNDb21wbGV4VHlwZSA9IChvKSA9PiB7XG4gICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3R5cGVvZi1mbi1vYmplY3QvNVxuICAgIG8gPSB0eXBlb2YgbztcbiAgICByZXR1cm4gbyA9PT0gJ29iamVjdCcgfHwgbyA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vKipcbiAqIEhlbHBlciBtZXRob2QgZm9yIHF1ZXJ5aW5nIGEgYG1ldGFgIHRhZyB0aGF0IGNvbnRhaW5zIGEgbm9uY2UgdmFsdWVcbiAqIG91dCBvZiBhIERPTSdzIGhlYWQuXG4gKlxuICogQHBhcmFtIGRvYyBUaGUgRE9NIGNvbnRhaW5pbmcgdGhlIGBoZWFkYCB0byBxdWVyeSBhZ2FpbnN0XG4gKiBAcmV0dXJucyBUaGUgY29udGVudCBvZiB0aGUgbWV0YSB0YWcgcmVwcmVzZW50aW5nIHRoZSBub25jZSB2YWx1ZSwgb3IgYHVuZGVmaW5lZGAgaWYgbm8gdGFnXG4gKiBleGlzdHMgb3IgdGhlIHRhZyBoYXMgbm8gY29udGVudC5cbiAqL1xuZnVuY3Rpb24gcXVlcnlOb25jZU1ldGFUYWdDb250ZW50KGRvYykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBkb2MuaGVhZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cImNzcC1ub25jZVwiXScpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0QXR0cmlidXRlKCdjb250ZW50JykpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogUHJvZHVjdGlvbiBoKCkgZnVuY3Rpb24gYmFzZWQgb24gUHJlYWN0IGJ5XG4gKiBKYXNvbiBNaWxsZXIgKEBkZXZlbG9waXQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvcHJlYWN0L2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBNb2RpZmllZCBmb3IgU3RlbmNpbCdzIGNvbXBpbGVyIGFuZCB2ZG9tXG4gKi9cbi8vIGV4cG9ydCBmdW5jdGlvbiBoKG5vZGVOYW1lOiBzdHJpbmcgfCBkLkZ1bmN0aW9uYWxDb21wb25lbnQsIHZub2RlRGF0YTogZC5Qcm9wc1R5cGUsIGNoaWxkPzogZC5DaGlsZFR5cGUpOiBkLlZOb2RlO1xuLy8gZXhwb3J0IGZ1bmN0aW9uIGgobm9kZU5hbWU6IHN0cmluZyB8IGQuRnVuY3Rpb25hbENvbXBvbmVudCwgdm5vZGVEYXRhOiBkLlByb3BzVHlwZSwgLi4uY2hpbGRyZW46IGQuQ2hpbGRUeXBlW10pOiBkLlZOb2RlO1xuY29uc3QgaCA9IChub2RlTmFtZSwgdm5vZGVEYXRhLCAuLi5jaGlsZHJlbikgPT4ge1xuICAgIGxldCBjaGlsZCA9IG51bGw7XG4gICAgbGV0IGtleSA9IG51bGw7XG4gICAgbGV0IHNsb3ROYW1lID0gbnVsbDtcbiAgICBsZXQgc2ltcGxlID0gZmFsc2U7XG4gICAgbGV0IGxhc3RTaW1wbGUgPSBmYWxzZTtcbiAgICBjb25zdCB2Tm9kZUNoaWxkcmVuID0gW107XG4gICAgY29uc3Qgd2FsayA9IChjKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBjW2ldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgd2FsayhjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZCAhPSBudWxsICYmIHR5cGVvZiBjaGlsZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaW1wbGUgPSB0eXBlb2Ygbm9kZU5hbWUgIT09ICdmdW5jdGlvbicgJiYgIWlzQ29tcGxleFR5cGUoY2hpbGQpKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IFN0cmluZyhjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJVSUxELmlzRGV2ICYmIHR5cGVvZiBub2RlTmFtZSAhPT0gJ2Z1bmN0aW9uJyAmJiBjaGlsZC4kZmxhZ3MkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZURldkVycm9yKGB2Tm9kZSBwYXNzZWQgYXMgY2hpbGRyZW4gaGFzIHVuZXhwZWN0ZWQgdHlwZS5cbk1ha2Ugc3VyZSBpdCdzIHVzaW5nIHRoZSBjb3JyZWN0IGgoKSBmdW5jdGlvbi5cbkVtcHR5IG9iamVjdHMgY2FuIGFsc28gYmUgdGhlIGNhdXNlLCBsb29rIGZvciBKU1ggY29tbWVudHMgdGhhdCBiZWNhbWUgb2JqZWN0cy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpbXBsZSAmJiBsYXN0U2ltcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBjaGlsZCB3YXMgc2ltcGxlIChzdHJpbmcpLCB3ZSBtZXJnZSBib3RoXG4gICAgICAgICAgICAgICAgICAgIHZOb2RlQ2hpbGRyZW5bdk5vZGVDaGlsZHJlbi5sZW5ndGggLSAxXS4kdGV4dCQgKz0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgYSBuZXcgdk5vZGUsIGlmIGl0J3MgdGV4dCwgd2UgY3JlYXRlIGEgdGV4dCB2Tm9kZVxuICAgICAgICAgICAgICAgICAgICB2Tm9kZUNoaWxkcmVuLnB1c2goc2ltcGxlID8gbmV3Vk5vZGUobnVsbCwgY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0U2ltcGxlID0gc2ltcGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB3YWxrKGNoaWxkcmVuKTtcbiAgICBpZiAodm5vZGVEYXRhKSB7XG4gICAgICAgIGlmIChCVUlMRC5pc0RldiAmJiBub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgdmFsaWRhdGVJbnB1dFByb3BlcnRpZXModm5vZGVEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3JtYWxpemUgY2xhc3MgLyBjbGFzc25hbWUgYXR0cmlidXRlc1xuICAgICAgICBpZiAoQlVJTEQudmRvbUtleSAmJiB2bm9kZURhdGEua2V5KSB7XG4gICAgICAgICAgICBrZXkgPSB2bm9kZURhdGEua2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiB2bm9kZURhdGEubmFtZSkge1xuICAgICAgICAgICAgc2xvdE5hbWUgPSB2bm9kZURhdGEubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudmRvbUNsYXNzKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc0RhdGEgPSB2bm9kZURhdGEuY2xhc3NOYW1lIHx8IHZub2RlRGF0YS5jbGFzcztcbiAgICAgICAgICAgIGlmIChjbGFzc0RhdGEpIHtcbiAgICAgICAgICAgICAgICB2bm9kZURhdGEuY2xhc3MgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY2xhc3NEYXRhICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBjbGFzc0RhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LmtleXMoY2xhc3NEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGspID0+IGNsYXNzRGF0YVtrXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5pc0RldiAmJiB2Tm9kZUNoaWxkcmVuLnNvbWUoaXNIb3N0KSkge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRoZSA8SG9zdD4gbXVzdCBiZSB0aGUgc2luZ2xlIHJvb3QgY29tcG9uZW50LiBNYWtlIHN1cmU6XG4tIFlvdSBhcmUgTk9UIHVzaW5nIGhvc3REYXRhKCkgYW5kIDxIb3N0PiBpbiB0aGUgc2FtZSBjb21wb25lbnQuXG4tIDxIb3N0PiBpcyB1c2VkIG9uY2UsIGFuZCBpdCdzIHRoZSBzaW5nbGUgcm9vdCBjb21wb25lbnQgb2YgdGhlIHJlbmRlcigpIGZ1bmN0aW9uLmApO1xuICAgIH1cbiAgICBpZiAoQlVJTEQudmRvbUZ1bmN0aW9uYWwgJiYgdHlwZW9mIG5vZGVOYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vZGVOYW1lIGlzIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgICAgcmV0dXJuIG5vZGVOYW1lKHZub2RlRGF0YSA9PT0gbnVsbCA/IHt9IDogdm5vZGVEYXRhLCB2Tm9kZUNoaWxkcmVuLCB2ZG9tRm5VdGlscyk7XG4gICAgfVxuICAgIGNvbnN0IHZub2RlID0gbmV3Vk5vZGUobm9kZU5hbWUsIG51bGwpO1xuICAgIHZub2RlLiRhdHRycyQgPSB2bm9kZURhdGE7XG4gICAgaWYgKHZOb2RlQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICB2bm9kZS4kY2hpbGRyZW4kID0gdk5vZGVDaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21LZXkpIHtcbiAgICAgICAgdm5vZGUuJGtleSQgPSBrZXk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICB2bm9kZS4kbmFtZSQgPSBzbG90TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xufTtcbi8qKlxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHZpcnR1YWwgRE9NIG5vZGUgZnJvbSBhIHRhZyBhbmQgc29tZVxuICogcG9zc2libGUgdGV4dCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB0YWcgdGhlIHRhZyBmb3IgdGhpcyBlbGVtZW50XG4gKiBAcGFyYW0gdGV4dCBwb3NzaWJsZSB0ZXh0IGNvbnRlbnQgZm9yIHRoZSBub2RlXG4gKiBAcmV0dXJucyBhIG5ld2x5LW1pbnRlZCB2aXJ0dWFsIERPTSBub2RlXG4gKi9cbmNvbnN0IG5ld1ZOb2RlID0gKHRhZywgdGV4dCkgPT4ge1xuICAgIGNvbnN0IHZub2RlID0ge1xuICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAkdGFnJDogdGFnLFxuICAgICAgICAkdGV4dCQ6IHRleHQsXG4gICAgICAgICRlbG0kOiBudWxsLFxuICAgICAgICAkY2hpbGRyZW4kOiBudWxsLFxuICAgIH07XG4gICAgaWYgKEJVSUxELnZkb21BdHRyaWJ1dGUpIHtcbiAgICAgICAgdm5vZGUuJGF0dHJzJCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgIHZub2RlLiRrZXkkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgIHZub2RlLiRuYW1lJCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbn07XG5jb25zdCBIb3N0ID0ge307XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBnaXZlbiBub2RlIGlzIGEgSG9zdCBub2RlIG9yIG5vdFxuICpcbiAqIEBwYXJhbSBub2RlIHRoZSB2aXJ0dWFsIERPTSBub2RlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB3aGV0aGVyIGl0J3MgYSBIb3N0IG5vZGUgb3Igbm90XG4gKi9cbmNvbnN0IGlzSG9zdCA9IChub2RlKSA9PiBub2RlICYmIG5vZGUuJHRhZyQgPT09IEhvc3Q7XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBkLkZ1bmN0aW9uYWxVdGlsaXRpZXN9IGZvciBTdGVuY2lsJ3MgVkRvbS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlc2UgZnVuY3Rpb25zIGNvbnZlcnQgZnJvbSB7QGxpbmsgZC5WTm9kZX0gdG9cbiAqIHtAbGluayBkLkNoaWxkTm9kZX0gdG8gZ2l2ZSBmdW5jdGlvbmFsIGNvbXBvbmVudCBkZXZlbG9wZXJzIGEgZnJpZW5kbHlcbiAqIGludGVyZmFjZS5cbiAqL1xuY29uc3QgdmRvbUZuVXRpbHMgPSB7XG4gICAgZm9yRWFjaDogKGNoaWxkcmVuLCBjYikgPT4gY2hpbGRyZW4ubWFwKGNvbnZlcnRUb1B1YmxpYykuZm9yRWFjaChjYiksXG4gICAgbWFwOiAoY2hpbGRyZW4sIGNiKSA9PiBjaGlsZHJlbi5tYXAoY29udmVydFRvUHVibGljKS5tYXAoY2IpLm1hcChjb252ZXJ0VG9Qcml2YXRlKSxcbn07XG4vKipcbiAqIENvbnZlcnQgYSB7QGxpbmsgZC5WTm9kZX0gdG8gYSB7QGxpbmsgZC5DaGlsZE5vZGV9IGluIG9yZGVyIHRvIHByZXNlbnQgYVxuICogZnJpZW5kbGllciBwdWJsaWMgaW50ZXJmYWNlIChoZW5jZSwgJ2NvbnZlcnRUb1B1YmxpYycpLlxuICpcbiAqIEBwYXJhbSBub2RlIHRoZSB2aXJ0dWFsIERPTSBub2RlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIGEgY29udmVydGVkIGNoaWxkIG5vZGVcbiAqL1xuY29uc3QgY29udmVydFRvUHVibGljID0gKG5vZGUpID0+ICh7XG4gICAgdmF0dHJzOiBub2RlLiRhdHRycyQsXG4gICAgdmNoaWxkcmVuOiBub2RlLiRjaGlsZHJlbiQsXG4gICAgdmtleTogbm9kZS4ka2V5JCxcbiAgICB2bmFtZTogbm9kZS4kbmFtZSQsXG4gICAgdnRhZzogbm9kZS4kdGFnJCxcbiAgICB2dGV4dDogbm9kZS4kdGV4dCQsXG59KTtcbi8qKlxuICogQ29udmVydCBhIHtAbGluayBkLkNoaWxkTm9kZX0gYmFjayB0byBhbiBlcXVpdmFsZW50IHtAbGluayBkLlZOb2RlfSBpblxuICogb3JkZXIgdG8gdXNlIHRoZSByZXN1bHRpbmcgb2JqZWN0IGluIHRoZSB2aXJ0dWFsIERPTS4gVGhlIGluaXRpYWwgb2JqZWN0IHdhc1xuICogbGlrZWx5IGNyZWF0ZWQgYXMgcGFydCBvZiBwcmVzZW50aW5nIGEgcHVibGljIEFQSSwgc28gY29udmVydGluZyBpdCBiYWNrXG4gKiBpbnZvbHZlZCBtYWtpbmcgaXQgJ3ByaXZhdGUnIGFnYWluIChoZW5jZSwgYGNvbnZlcnRUb1ByaXZhdGVgKS5cbiAqXG4gKiBAcGFyYW0gbm9kZSB0aGUgY2hpbGQgbm9kZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyBhIGNvbnZlcnRlZCB2aXJ0dWFsIERPTSBub2RlXG4gKi9cbmNvbnN0IGNvbnZlcnRUb1ByaXZhdGUgPSAobm9kZSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygbm9kZS52dGFnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHZub2RlRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUudmF0dHJzKTtcbiAgICAgICAgaWYgKG5vZGUudmtleSkge1xuICAgICAgICAgICAgdm5vZGVEYXRhLmtleSA9IG5vZGUudmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS52bmFtZSkge1xuICAgICAgICAgICAgdm5vZGVEYXRhLm5hbWUgPSBub2RlLnZuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoKG5vZGUudnRhZywgdm5vZGVEYXRhLCAuLi4obm9kZS52Y2hpbGRyZW4gfHwgW10pKTtcbiAgICB9XG4gICAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShub2RlLnZ0YWcsIG5vZGUudnRleHQpO1xuICAgIHZub2RlLiRhdHRycyQgPSBub2RlLnZhdHRycztcbiAgICB2bm9kZS4kY2hpbGRyZW4kID0gbm9kZS52Y2hpbGRyZW47XG4gICAgdm5vZGUuJGtleSQgPSBub2RlLnZrZXk7XG4gICAgdm5vZGUuJG5hbWUkID0gbm9kZS52bmFtZTtcbiAgICByZXR1cm4gdm5vZGU7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIG9yZGVyaW5nIG9mIGF0dHJpYnV0ZXMgb24gYW4gaW5wdXQgZWxlbWVudFxuICpcbiAqIEBwYXJhbSBpbnB1dEVsbSB0aGUgZWxlbWVudCB0byB2YWxpZGF0ZVxuICovXG5jb25zdCB2YWxpZGF0ZUlucHV0UHJvcGVydGllcyA9IChpbnB1dEVsbSkgPT4ge1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMoaW5wdXRFbG0pO1xuICAgIGNvbnN0IHZhbHVlID0gcHJvcHMuaW5kZXhPZigndmFsdWUnKTtcbiAgICBpZiAodmFsdWUgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHlwZUluZGV4ID0gcHJvcHMuaW5kZXhPZigndHlwZScpO1xuICAgIGNvbnN0IG1pbkluZGV4ID0gcHJvcHMuaW5kZXhPZignbWluJyk7XG4gICAgY29uc3QgbWF4SW5kZXggPSBwcm9wcy5pbmRleE9mKCdtYXgnKTtcbiAgICBjb25zdCBzdGVwSW5kZXggPSBwcm9wcy5pbmRleE9mKCdzdGVwJyk7XG4gICAgaWYgKHZhbHVlIDwgdHlwZUluZGV4IHx8IHZhbHVlIDwgbWluSW5kZXggfHwgdmFsdWUgPCBtYXhJbmRleCB8fCB2YWx1ZSA8IHN0ZXBJbmRleCkge1xuICAgICAgICBjb25zb2xlRGV2V2FybihgVGhlIFwidmFsdWVcIiBwcm9wIG9mIDxpbnB1dD4gc2hvdWxkIGJlIHNldCBhZnRlciBcIm1pblwiLCBcIm1heFwiLCBcInR5cGVcIiBhbmQgXCJzdGVwXCJgKTtcbiAgICB9XG59O1xuY29uc3QgaW5pdGlhbGl6ZUNsaWVudEh5ZHJhdGUgPSAoaG9zdEVsbSwgdGFnTmFtZSwgaG9zdElkLCBob3N0UmVmKSA9PiB7XG4gICAgY29uc3QgZW5kSHlkcmF0ZSA9IGNyZWF0ZVRpbWUoJ2h5ZHJhdGVDbGllbnQnLCB0YWdOYW1lKTtcbiAgICBjb25zdCBzaGFkb3dSb290ID0gaG9zdEVsbS5zaGFkb3dSb290O1xuICAgIGNvbnN0IGNoaWxkUmVuZGVyTm9kZXMgPSBbXTtcbiAgICBjb25zdCBzbG90Tm9kZXMgPSBbXTtcbiAgICBjb25zdCBzaGFkb3dSb290Tm9kZXMgPSBCVUlMRC5zaGFkb3dEb20gJiYgc2hhZG93Um9vdCA/IFtdIDogbnVsbDtcbiAgICBjb25zdCB2bm9kZSA9IChob3N0UmVmLiR2bm9kZSQgPSBuZXdWTm9kZSh0YWdOYW1lLCBudWxsKSk7XG4gICAgaWYgKCFwbHQuJG9yZ0xvY05vZGVzJCkge1xuICAgICAgICBpbml0aWFsaXplRG9jdW1lbnRIeWRyYXRlKGRvYy5ib2R5LCAocGx0LiRvcmdMb2NOb2RlcyQgPSBuZXcgTWFwKCkpKTtcbiAgICB9XG4gICAgaG9zdEVsbVtIWURSQVRFX0lEXSA9IGhvc3RJZDtcbiAgICBob3N0RWxtLnJlbW92ZUF0dHJpYnV0ZShIWURSQVRFX0lEKTtcbiAgICBjbGllbnRIeWRyYXRlKHZub2RlLCBjaGlsZFJlbmRlck5vZGVzLCBzbG90Tm9kZXMsIHNoYWRvd1Jvb3ROb2RlcywgaG9zdEVsbSwgaG9zdEVsbSwgaG9zdElkKTtcbiAgICBjaGlsZFJlbmRlck5vZGVzLm1hcCgoYykgPT4ge1xuICAgICAgICBjb25zdCBvcmdMb2NhdGlvbklkID0gYy4kaG9zdElkJCArICcuJyArIGMuJG5vZGVJZCQ7XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uTm9kZSA9IHBsdC4kb3JnTG9jTm9kZXMkLmdldChvcmdMb2NhdGlvbklkKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGMuJGVsbSQ7XG4gICAgICAgIGlmIChvcmdMb2NhdGlvbk5vZGUgJiYgc3VwcG9ydHNTaGFkb3cgJiYgb3JnTG9jYXRpb25Ob2RlWydzLWVuJ10gPT09ICcnKSB7XG4gICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgb3JnTG9jYXRpb25Ob2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIG5vZGVbJ3MtaG4nXSA9IHRhZ05hbWU7XG4gICAgICAgICAgICBpZiAob3JnTG9jYXRpb25Ob2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZVsncy1vbCddID0gb3JnTG9jYXRpb25Ob2RlO1xuICAgICAgICAgICAgICAgIG5vZGVbJ3Mtb2wnXVsncy1uciddID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwbHQuJG9yZ0xvY05vZGVzJC5kZWxldGUob3JnTG9jYXRpb25JZCk7XG4gICAgfSk7XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290KSB7XG4gICAgICAgIHNoYWRvd1Jvb3ROb2Rlcy5tYXAoKHNoYWRvd1Jvb3ROb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hhZG93Um9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBzaGFkb3dSb290LmFwcGVuZENoaWxkKHNoYWRvd1Jvb3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuZEh5ZHJhdGUoKTtcbn07XG5jb25zdCBjbGllbnRIeWRyYXRlID0gKHBhcmVudFZOb2RlLCBjaGlsZFJlbmRlck5vZGVzLCBzbG90Tm9kZXMsIHNoYWRvd1Jvb3ROb2RlcywgaG9zdEVsbSwgbm9kZSwgaG9zdElkKSA9PiB7XG4gICAgbGV0IGNoaWxkTm9kZVR5cGU7XG4gICAgbGV0IGNoaWxkSWRTcGx0O1xuICAgIGxldCBjaGlsZFZOb2RlO1xuICAgIGxldCBpO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxIC8qIE5PREVfVFlQRS5FbGVtZW50Tm9kZSAqLykge1xuICAgICAgICBjaGlsZE5vZGVUeXBlID0gbm9kZS5nZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCk7XG4gICAgICAgIGlmIChjaGlsZE5vZGVUeXBlKSB7XG4gICAgICAgICAgICAvLyBnb3QgdGhlIG5vZGUgZGF0YSBmcm9tIHRoZSBlbGVtZW50J3MgYXR0cmlidXRlXG4gICAgICAgICAgICAvLyBgJHtob3N0SWR9LiR7bm9kZUlkfS4ke2RlcHRofS4ke2luZGV4fWBcbiAgICAgICAgICAgIGNoaWxkSWRTcGx0ID0gY2hpbGROb2RlVHlwZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzBdID09PSBob3N0SWQgfHwgY2hpbGRJZFNwbHRbMF0gPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICRmbGFncyQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICRob3N0SWQkOiBjaGlsZElkU3BsdFswXSxcbiAgICAgICAgICAgICAgICAgICAgJG5vZGVJZCQ6IGNoaWxkSWRTcGx0WzFdLFxuICAgICAgICAgICAgICAgICAgICAkZGVwdGgkOiBjaGlsZElkU3BsdFsyXSxcbiAgICAgICAgICAgICAgICAgICAgJGluZGV4JDogY2hpbGRJZFNwbHRbM10sXG4gICAgICAgICAgICAgICAgICAgICR0YWckOiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgJGVsbSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICRhdHRycyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICRjaGlsZHJlbiQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICRrZXkkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkbmFtZSQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICR0ZXh0JDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNoaWxkUmVuZGVyTm9kZXMucHVzaChjaGlsZFZOb2RlKTtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lEKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgbmV3IGNoaWxkIHZub2RlXG4gICAgICAgICAgICAgICAgLy8gc28gZW5zdXJlIGl0cyBwYXJlbnQgdm5vZGUgaGFzIHRoZSB2Y2hpbGRyZW4gYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhZGQgb3VyIGNoaWxkIHZub2RlIHRvIGEgc3BlY2lmaWMgaW5kZXggb2YgdGhlIHZub2RlJ3MgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm93IHRoZSBuZXcgcGFyZW50IHZub2RlIGZvciBhbGwgdGhlIG5leHQgY2hpbGQgY2hlY2tzXG4gICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUgPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChzaGFkb3dSb290Tm9kZXMgJiYgY2hpbGRWTm9kZS4kZGVwdGgkID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZWN1cnNpdmVseSBkcmlsbCBkb3duLCBlbmQgdG8gc3RhcnQgc28gd2UgY2FuIHJlbW92ZSBub2Rlc1xuICAgICAgICBmb3IgKGkgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNsaWVudEh5ZHJhdGUocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLmNoaWxkTm9kZXNbaV0sIGhvc3RJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgLy8ga2VlcCBkcmlsbGluZyBkb3duIHRocm91Z2ggdGhlIHNoYWRvdyByb290IG5vZGVzXG4gICAgICAgICAgICBmb3IgKGkgPSBub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGNsaWVudEh5ZHJhdGUocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tpXSwgaG9zdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIE5PREVfVFlQRS5Db21tZW50Tm9kZSAqLykge1xuICAgICAgICAvLyBgJHtDT01NRU5UX1RZUEV9LiR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gXG4gICAgICAgIGNoaWxkSWRTcGx0ID0gbm9kZS5ub2RlVmFsdWUuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzFdID09PSBob3N0SWQgfHwgY2hpbGRJZFNwbHRbMV0gPT09ICcwJykge1xuICAgICAgICAgICAgLy8gY29tbWVudCBub2RlIGZvciBlaXRoZXIgdGhlIGhvc3QgaWQgb3IgYSAwIGhvc3QgaWRcbiAgICAgICAgICAgIGNoaWxkTm9kZVR5cGUgPSBjaGlsZElkU3BsdFswXTtcbiAgICAgICAgICAgIGNoaWxkVk5vZGUgPSB7XG4gICAgICAgICAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgICAgICAgICAkaG9zdElkJDogY2hpbGRJZFNwbHRbMV0sXG4gICAgICAgICAgICAgICAgJG5vZGVJZCQ6IGNoaWxkSWRTcGx0WzJdLFxuICAgICAgICAgICAgICAgICRkZXB0aCQ6IGNoaWxkSWRTcGx0WzNdLFxuICAgICAgICAgICAgICAgICRpbmRleCQ6IGNoaWxkSWRTcGx0WzRdLFxuICAgICAgICAgICAgICAgICRlbG0kOiBub2RlLFxuICAgICAgICAgICAgICAgICRhdHRycyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJGNoaWxkcmVuJDogbnVsbCxcbiAgICAgICAgICAgICAgICAka2V5JDogbnVsbCxcbiAgICAgICAgICAgICAgICAkbmFtZSQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJHRhZyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJHRleHQkOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVUeXBlID09PSBURVhUX05PREVfSUQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kZWxtJCAmJiBjaGlsZFZOb2RlLiRlbG0kLm5vZGVUeXBlID09PSAzIC8qIE5PREVfVFlQRS5UZXh0Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiR0ZXh0JCA9IGNoaWxkVk5vZGUuJGVsbSQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUmVuZGVyTm9kZXMucHVzaChjaGlsZFZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB0ZXh0IGNvbW1lbnQgc2luY2UgaXQncyBubyBsb25nZXIgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiRbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFkb3dSb290Tm9kZXMgJiYgY2hpbGRWTm9kZS4kZGVwdGgkID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3ROb2Rlc1tjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZS4kZWxtJDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkVk5vZGUuJGhvc3RJZCQgPT09IGhvc3RJZCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29tbWVudCBub2RlIGlzIHNwZWNpZmNhbGx5IGZvciB0aGlzIGhvc3QgaWRcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlVHlwZSA9PT0gU0xPVF9OT0RFX0lEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGAke1NMT1RfTk9ERV9JRH0uJHtob3N0SWR9LiR7bm9kZUlkfS4ke2RlcHRofS4ke2luZGV4fS4ke3Nsb3ROYW1lfWA7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJHRhZyQgPSAnc2xvdCc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZElkU3BsdFs1XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zbiddID0gY2hpbGRWTm9kZS4kbmFtZSQgPSBjaGlsZElkU3BsdFs1XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3Mtc24nXSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGVbJ3Mtc3InXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgc2hhZG93Um9vdE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBicm93c2VyIHN1cHBvcnQgc2hhZG93Um9vdCBhbmQgdGhpcyBpcyBhIHNoYWRvdyBkb20gY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gYWN0dWFsIHNsb3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kZWxtJCA9IGRvYy5jcmVhdGVFbGVtZW50KGNoaWxkVk5vZGUuJHRhZyQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVk5vZGUuJG5hbWUkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBzbG90IG5hbWUgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kZWxtJC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBjaGlsZFZOb2RlLiRuYW1lJCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgdGhlIG5ldyBzbG90IGVsZW1lbnQgYmVmb3JlIHRoZSBzbG90IGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGRWTm9kZS4kZWxtJCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHNsb3QgY29tbWVudCBzaW5jZSBpdCdzIG5vdCBuZWVkZWQgZm9yIHNoYWRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFZOb2RlLiRkZXB0aCQgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3ROb2Rlc1tjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZS4kZWxtJDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzbG90Tm9kZXMucHVzaChjaGlsZFZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGROb2RlVHlwZSA9PT0gQ09OVEVOVF9SRUZfSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYCR7Q09OVEVOVF9SRUZfSUR9LiR7aG9zdElkfWA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgc2hhZG93Um9vdE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGNvbnRlbnQgcmVmIGNvbW1lbnQgc2luY2UgaXQncyBub3QgbmVlZGVkIGZvciBzaGFkb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbG1bJ3MtY3InXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWydzLWNuJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudFZOb2RlICYmIHBhcmVudFZOb2RlLiR0YWckID09PSAnc3R5bGUnKSB7XG4gICAgICAgIGNvbnN0IHZub2RlID0gbmV3Vk5vZGUobnVsbCwgbm9kZS50ZXh0Q29udGVudCk7XG4gICAgICAgIHZub2RlLiRlbG0kID0gbm9kZTtcbiAgICAgICAgdm5vZGUuJGluZGV4JCA9ICcwJztcbiAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCA9IFt2bm9kZV07XG4gICAgfVxufTtcbmNvbnN0IGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUgPSAobm9kZSwgb3JnTG9jTm9kZXMpID0+IHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBOT0RFX1RZUEUuRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShub2RlLmNoaWxkTm9kZXNbaV0sIG9yZ0xvY05vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplRG9jdW1lbnRIeWRyYXRlKG5vZGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzW2ldLCBvcmdMb2NOb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBOT0RFX1RZUEUuQ29tbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY29uc3QgY2hpbGRJZFNwbHQgPSBub2RlLm5vZGVWYWx1ZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY2hpbGRJZFNwbHRbMF0gPT09IE9SR19MT0NBVElPTl9JRCkge1xuICAgICAgICAgICAgb3JnTG9jTm9kZXMuc2V0KGNoaWxkSWRTcGx0WzFdICsgJy4nICsgY2hpbGRJZFNwbHRbMl0sIG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSAnJztcbiAgICAgICAgICAgIC8vIHVzZWZ1bCB0byBrbm93IGlmIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBpc1xuICAgICAgICAgICAgLy8gdGhlIHJvb3QgbGlnaHQtZG9tIG9mIGEgc2hhZG93IGRvbSBjb21wb25lbnRcbiAgICAgICAgICAgIG5vZGVbJ3MtZW4nXSA9IGNoaWxkSWRTcGx0WzNdO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vIFByaXZhdGVcbmNvbnN0IGNvbXB1dGVNb2RlID0gKGVsbSkgPT4gbW9kZVJlc29sdXRpb25DaGFpbi5tYXAoKGgpID0+IGgoZWxtKSkuZmluZCgobSkgPT4gISFtKTtcbi8vIFB1YmxpY1xuY29uc3Qgc2V0TW9kZSA9IChoYW5kbGVyKSA9PiBtb2RlUmVzb2x1dGlvbkNoYWluLnB1c2goaGFuZGxlcik7XG5jb25zdCBnZXRNb2RlID0gKHJlZikgPT4gZ2V0SG9zdFJlZihyZWYpLiRtb2RlTmFtZSQ7XG4vKipcbiAqIFBhcnNlIGEgbmV3IHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIHByb3BlcnR5IHR5cGUuXG4gKlxuICogV2hpbGUgdGhlIHByb3AgdmFsdWUgY2FuIHJlYXNvbmFibHkgYmUgZXhwZWN0ZWQgdG8gYmUgb2YgYGFueWAgdHlwZSBhcyBmYXIgYXMgVHlwZVNjcmlwdCdzIHR5cGUgY2hlY2tlciBpcyBjb25jZXJuZWQsXG4gKiBpdCBpcyBub3Qgc2FmZSB0byBhc3N1bWUgdGhhdCB0aGUgc3RyaW5nIHJldHVybmVkIGJ5IGV2YWx1YXRpbmcgYHR5cGVvZiBwcm9wVmFsdWVgIG1hdGNoZXM6XG4gKiAgIDEuIGBhbnlgLCB0aGUgdHlwZSBnaXZlbiB0byBgcHJvcFZhbHVlYCBpbiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlXG4gKiAgIDIuIHRoZSB0eXBlIHN0b3JlZCBmcm9tIGBwcm9wVHlwZWAuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBwcm92aWRlcyB0aGUgY2FwYWJpbGl0eSB0byBwYXJzZS9jb2VyY2UgYSBwcm9wZXJ0eSdzIHZhbHVlIHRvIHBvdGVudGlhbGx5IGFueSBvdGhlciBKYXZhU2NyaXB0IHR5cGUuXG4gKlxuICogUHJvcGVydHkgdmFsdWVzIHJlcHJlc2VudGVkIGluIFRTWCBwcmVzZXJ2ZSB0aGVpciB0eXBlIGluZm9ybWF0aW9uLiBJbiB0aGUgZXhhbXBsZSBiZWxvdywgdGhlIG51bWJlciAwIGlzIHBhc3NlZCB0b1xuICogYSBjb21wb25lbnQuIFRoaXMgYHByb3BWYWx1ZWAgd2lsbCBwcmVzZXJ2ZSBpdHMgdHlwZSBpbmZvcm1hdGlvbiAoYHR5cGVvZiBwcm9wVmFsdWUgPT09ICdudW1iZXInYCkuIE5vdGUgdGhhdCBpc1xuICogYmFzZWQgb24gdGhlIHR5cGUgb2YgdGhlIHZhbHVlIGJlaW5nIHBhc3NlZCBpbiwgbm90IHRoZSB0eXBlIGRlY2xhcmVkIG9mIHRoZSBjbGFzcyBtZW1iZXIgZGVjb3JhdGVkIHdpdGggYEBQcm9wYC5cbiAqIGBgYHRzeFxuICogPG15LWNtcCBwcm9wLXZhbD17MH0+PC9teS1jbXA+XG4gKiBgYGBcbiAqXG4gKiBIVE1MIHByb3AgdmFsdWVzIG9uIHRoZSBvdGhlciBoYW5kLCB3aWxsIGFsd2F5cyBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSBwcm9wVmFsdWUgdGhlIG5ldyB2YWx1ZSB0byBjb2VyY2UgdG8gc29tZSB0eXBlXG4gKiBAcGFyYW0gcHJvcFR5cGUgdGhlIHR5cGUgb2YgdGhlIHByb3AsIGV4cHJlc3NlZCBhcyBhIGJpbmFyeSBudW1iZXJcbiAqIEByZXR1cm5zIHRoZSBwYXJzZWQvY29lcmNlZCB2YWx1ZVxuICovXG5jb25zdCBwYXJzZVByb3BlcnR5VmFsdWUgPSAocHJvcFZhbHVlLCBwcm9wVHlwZSkgPT4ge1xuICAgIC8vIGVuc3VyZSB0aGlzIHZhbHVlIGlzIG9mIHRoZSBjb3JyZWN0IHByb3AgdHlwZVxuICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiAhaXNDb21wbGV4VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIGlmIChCVUlMRC5wcm9wQm9vbGVhbiAmJiBwcm9wVHlwZSAmIDQgLyogTUVNQkVSX0ZMQUdTLkJvb2xlYW4gKi8pIHtcbiAgICAgICAgICAgIC8vIHBlciB0aGUgSFRNTCBzcGVjLCBhbnkgc3RyaW5nIHZhbHVlIG1lYW5zIGl0IGlzIGEgYm9vbGVhbiB0cnVlIHZhbHVlXG4gICAgICAgICAgICAvLyBidXQgd2UnbGwgY2hlYXQgaGVyZSBhbmQgc2F5IHRoYXQgdGhlIHN0cmluZyBcImZhbHNlXCIgaXMgdGhlIGJvb2xlYW4gZmFsc2VcbiAgICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHByb3BWYWx1ZSA9PT0gJycgfHwgISFwcm9wVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnByb3BOdW1iZXIgJiYgcHJvcFR5cGUgJiAyIC8qIE1FTUJFUl9GTEFHUy5OdW1iZXIgKi8pIHtcbiAgICAgICAgICAgIC8vIGZvcmNlIGl0IHRvIGJlIGEgbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5wcm9wU3RyaW5nICYmIHByb3BUeXBlICYgMSAvKiBNRU1CRVJfRkxBR1MuU3RyaW5nICovKSB7XG4gICAgICAgICAgICAvLyBjb3VsZCBoYXZlIGJlZW4gcGFzc2VkIGFzIGEgbnVtYmVyIG9yIGJvb2xlYW5cbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBzdGlsbCB3YW50IGl0IGFzIGEgc3RyaW5nXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVkdW5kYW50IHJldHVybiBoZXJlIGZvciBiZXR0ZXIgbWluaWZpY2F0aW9uXG4gICAgICAgIHJldHVybiBwcm9wVmFsdWU7XG4gICAgfVxuICAgIC8vIG5vdCBzdXJlIGV4YWN0bHkgd2hhdCB0eXBlIHdlIHdhbnRcbiAgICAvLyBzbyBubyBuZWVkIHRvIGNoYW5nZSB0byBhIGRpZmZlcmVudCB0eXBlXG4gICAgcmV0dXJuIHByb3BWYWx1ZTtcbn07XG5jb25zdCBnZXRFbGVtZW50ID0gKHJlZikgPT4gKEJVSUxELmxhenlMb2FkID8gZ2V0SG9zdFJlZihyZWYpLiRob3N0RWxlbWVudCQgOiByZWYpO1xuY29uc3QgY3JlYXRlRXZlbnQgPSAocmVmLCBuYW1lLCBmbGFncykgPT4ge1xuICAgIGNvbnN0IGVsbSA9IGdldEVsZW1lbnQocmVmKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbWl0OiAoZGV0YWlsKSA9PiB7XG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYgJiYgIWVsbS5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZXYXJuKGBUaGUgXCIke25hbWV9XCIgZXZlbnQgd2FzIGVtaXR0ZWQsIGJ1dCB0aGUgZGlzcGF0Y2hlciBub2RlIGlzIG5vIGxvbmdlciBjb25uZWN0ZWQgdG8gdGhlIGRvbS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbWl0RXZlbnQoZWxtLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgYnViYmxlczogISEoZmxhZ3MgJiA0IC8qIEVWRU5UX0ZMQUdTLkJ1YmJsZXMgKi8pLFxuICAgICAgICAgICAgICAgIGNvbXBvc2VkOiAhIShmbGFncyAmIDIgLyogRVZFTlRfRkxBR1MuQ29tcG9zZWQgKi8pLFxuICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICEhKGZsYWdzICYgMSAvKiBFVkVOVF9GTEFHUy5DYW5jZWxsYWJsZSAqLyksXG4gICAgICAgICAgICAgICAgZGV0YWlsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgJiBkaXNwYXRjaCBhIGN1c3RvbSBFdmVudCBvbiBhIHByb3ZpZGVkIHRhcmdldFxuICogQHBhcmFtIGVsbSB0aGUgdGFyZ2V0IG9mIHRoZSBFdmVudFxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgdG8gZ2l2ZSB0aGUgY3VzdG9tIEV2ZW50XG4gKiBAcGFyYW0gb3B0cyBvcHRpb25zIGZvciBjb25maWd1cmluZyBhIGN1c3RvbSBFdmVudFxuICogQHJldHVybnMgdGhlIGN1c3RvbSBFdmVudFxuICovXG5jb25zdCBlbWl0RXZlbnQgPSAoZWxtLCBuYW1lLCBvcHRzKSA9PiB7XG4gICAgY29uc3QgZXYgPSBwbHQuY2UobmFtZSwgb3B0cyk7XG4gICAgZWxtLmRpc3BhdGNoRXZlbnQoZXYpO1xuICAgIHJldHVybiBldjtcbn07XG5jb25zdCByb290QXBwbGllZFN0eWxlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlZ2lzdGVyU3R5bGUgPSAoc2NvcGVJZCwgY3NzVGV4dCwgYWxsb3dDUykgPT4ge1xuICAgIGxldCBzdHlsZSA9IHN0eWxlcy5nZXQoc2NvcGVJZCk7XG4gICAgaWYgKHN1cHBvcnRzQ29uc3RydWN0YWJsZVN0eWxlc2hlZXRzICYmIGFsbG93Q1MpIHtcbiAgICAgICAgc3R5bGUgPSAoc3R5bGUgfHwgbmV3IENTU1N0eWxlU2hlZXQoKSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdHlsZSA9IGNzc1RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5yZXBsYWNlU3luYyhjc3NUZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBjc3NUZXh0O1xuICAgIH1cbiAgICBzdHlsZXMuc2V0KHNjb3BlSWQsIHN0eWxlKTtcbn07XG5jb25zdCBhZGRTdHlsZSA9IChzdHlsZUNvbnRhaW5lck5vZGUsIGNtcE1ldGEsIG1vZGUsIGhvc3RFbG0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHNjb3BlSWQgPSBnZXRTY29wZUlkKGNtcE1ldGEsIG1vZGUpO1xuICAgIGNvbnN0IHN0eWxlID0gc3R5bGVzLmdldChzY29wZUlkKTtcbiAgICBpZiAoIUJVSUxELmF0dGFjaFN0eWxlcykge1xuICAgICAgICByZXR1cm4gc2NvcGVJZDtcbiAgICB9XG4gICAgLy8gaWYgYW4gZWxlbWVudCBpcyBOT1QgY29ubmVjdGVkIHRoZW4gZ2V0Um9vdE5vZGUoKSB3aWxsIHJldHVybiB0aGUgd3Jvbmcgcm9vdCBub2RlXG4gICAgLy8gc28gdGhlIGZhbGxiYWNrIGlzIHRvIGFsd2F5cyB1c2UgdGhlIGRvY3VtZW50IGZvciB0aGUgcm9vdCBub2RlIGluIHRob3NlIGNhc2VzXG4gICAgc3R5bGVDb250YWluZXJOb2RlID0gc3R5bGVDb250YWluZXJOb2RlLm5vZGVUeXBlID09PSAxMSAvKiBOT0RFX1RZUEUuRG9jdW1lbnRGcmFnbWVudCAqLyA/IHN0eWxlQ29udGFpbmVyTm9kZSA6IGRvYztcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZSA9IHN0eWxlQ29udGFpbmVyTm9kZS5oZWFkIHx8IHN0eWxlQ29udGFpbmVyTm9kZTtcbiAgICAgICAgICAgIGxldCBhcHBsaWVkU3R5bGVzID0gcm9vdEFwcGxpZWRTdHlsZXMuZ2V0KHN0eWxlQ29udGFpbmVyTm9kZSk7XG4gICAgICAgICAgICBsZXQgc3R5bGVFbG07XG4gICAgICAgICAgICBpZiAoIWFwcGxpZWRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICByb290QXBwbGllZFN0eWxlcy5zZXQoc3R5bGVDb250YWluZXJOb2RlLCAoYXBwbGllZFN0eWxlcyA9IG5ldyBTZXQoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcHBsaWVkU3R5bGVzLmhhcyhzY29wZUlkKSkge1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSAmJlxuICAgICAgICAgICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUuaG9zdCAmJlxuICAgICAgICAgICAgICAgICAgICAoc3R5bGVFbG0gPSBzdHlsZUNvbnRhaW5lck5vZGUucXVlcnlTZWxlY3RvcihgWyR7SFlEUkFURURfU1RZTEVfSUR9PVwiJHtzY29wZUlkfVwiXWApKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG9ubHkgaGFwcGVuaW5nIG9uIG5hdGl2ZSBzaGFkb3ctZG9tLCBkbyBub3QgbmVlZHMgQ1NTIHZhciBzaGltXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtLmlubmVySFRNTCA9IHN0eWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmNzc1ZhclNoaW0gJiYgcGx0LiRjc3NTaGltJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0gPSBwbHQuJGNzc1NoaW0kLmNyZWF0ZUhvc3RTdHlsZShob3N0RWxtLCBzY29wZUlkLCBzdHlsZSwgISEoY21wTWV0YS4kZmxhZ3MkICYgMTAgLyogQ01QX0ZMQUdTLm5lZWRzU2NvcGVkRW5jYXBzdWxhdGlvbiAqLykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2NvcGVJZCA9IHN0eWxlRWxtWydzLXNjJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2NvcGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlSWQgPSBuZXdTY29wZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gYWRkIHRoaXMgc3R5bGVJRCB0byB0aGUgYXBwbGllZFN0eWxlcyBTZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgY3NzVmFyU2hpbSBtaWdodCBuZWVkIHRvIGFwcGx5IHNldmVyYWwgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzaGVldHMgZm9yIHRoZSBzYW1lIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWRTdHlsZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0gPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtLmlubmVySFRNTCA9IHN0eWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IENTUCBub25jZSB0byB0aGUgc3R5bGUgdGFnIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub25jZSA9IChfYSA9IHBsdC4kbm9uY2UkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBxdWVyeU5vbmNlTWV0YVRhZ0NvbnRlbnQoZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlIHx8IEJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbS5zZXRBdHRyaWJ1dGUoSFlEUkFURURfU1RZTEVfSUQsIHNjb3BlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZS5pbnNlcnRCZWZvcmUoc3R5bGVFbG0sIHN0eWxlQ29udGFpbmVyTm9kZS5xdWVyeVNlbGVjdG9yKCdsaW5rJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXBwbGllZFN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWVkU3R5bGVzLmFkZChzY29wZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQuY29uc3RydWN0YWJsZUNTUyAmJiAhc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cy5pbmNsdWRlcyhzdHlsZSkpIHtcbiAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMgPSBbLi4uc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cywgc3R5bGVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY29wZUlkO1xufTtcbmNvbnN0IGF0dGFjaFN0eWxlcyA9IChob3N0UmVmKSA9PiB7XG4gICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgIGNvbnN0IGVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBmbGFncyA9IGNtcE1ldGEuJGZsYWdzJDtcbiAgICBjb25zdCBlbmRBdHRhY2hTdHlsZXMgPSBjcmVhdGVUaW1lKCdhdHRhY2hTdHlsZXMnLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgY29uc3Qgc2NvcGVJZCA9IGFkZFN0eWxlKEJVSUxELnNoYWRvd0RvbSAmJiBzdXBwb3J0c1NoYWRvdyAmJiBlbG0uc2hhZG93Um9vdCA/IGVsbS5zaGFkb3dSb290IDogZWxtLmdldFJvb3ROb2RlKCksIGNtcE1ldGEsIGhvc3RSZWYuJG1vZGVOYW1lJCwgZWxtKTtcbiAgICBpZiAoKEJVSUxELnNoYWRvd0RvbSB8fCBCVUlMRC5zY29wZWQpICYmIEJVSUxELmNzc0Fubm90YXRpb25zICYmIGZsYWdzICYgMTAgLyogQ01QX0ZMQUdTLm5lZWRzU2NvcGVkRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAvLyBvbmx5IHJlcXVpcmVkIHdoZW4gd2UncmUgTk9UIHVzaW5nIG5hdGl2ZSBzaGFkb3cgZG9tIChzbG90KVxuICAgICAgICAvLyBvciB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IG5hdGl2ZSBzaGFkb3cgZG9tXG4gICAgICAgIC8vIGFuZCB0aGlzIGhvc3QgZWxlbWVudCB3YXMgTk9UIGNyZWF0ZWQgd2l0aCBTU1JcbiAgICAgICAgLy8gbGV0J3MgcGljayBvdXQgdGhlIGlubmVyIGNvbnRlbnQgZm9yIHNsb3QgcHJvamVjdGlvblxuICAgICAgICAvLyBjcmVhdGUgYSBub2RlIHRvIHJlcHJlc2VudCB3aGVyZSB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gY29udGVudCB3YXMgZmlyc3QgcGxhY2VkLCB3aGljaCBpcyB1c2VmdWwgbGF0ZXIgb25cbiAgICAgICAgLy8gRE9NIFdSSVRFISFcbiAgICAgICAgZWxtWydzLXNjJ10gPSBzY29wZUlkO1xuICAgICAgICBlbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1oJyk7XG4gICAgICAgIGlmIChCVUlMRC5zY29wZWQgJiYgZmxhZ3MgJiAyIC8qIENNUF9GTEFHUy5zY29wZWRDc3NFbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICBlbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1zJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5kQXR0YWNoU3R5bGVzKCk7XG59O1xuY29uc3QgZ2V0U2NvcGVJZCA9IChjbXAsIG1vZGUpID0+ICdzYy0nICsgKEJVSUxELm1vZGUgJiYgbW9kZSAmJiBjbXAuJGZsYWdzJCAmIDMyIC8qIENNUF9GTEFHUy5oYXNNb2RlICovID8gY21wLiR0YWdOYW1lJCArICctJyArIG1vZGUgOiBjbXAuJHRhZ05hbWUkKTtcbmNvbnN0IGNvbnZlcnRTY29wZWRUb1NoYWRvdyA9IChjc3MpID0+IGNzcy5yZXBsYWNlKC9cXC9cXCohQChbXlxcL10rKVxcKlxcL1teXFx7XStcXHsvZywgJyQxeycpO1xuLyoqXG4gKiBQcm9kdWN0aW9uIHNldEFjY2Vzc29yKCkgZnVuY3Rpb24gYmFzZWQgb24gUHJlYWN0IGJ5XG4gKiBKYXNvbiBNaWxsZXIgKEBkZXZlbG9waXQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvcHJlYWN0L2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBNb2RpZmllZCBmb3IgU3RlbmNpbCdzIGNvbXBpbGVyIGFuZCB2ZG9tXG4gKi9cbmNvbnN0IHNldEFjY2Vzc29yID0gKGVsbSwgbWVtYmVyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBpc1N2ZywgZmxhZ3MpID0+IHtcbiAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIGxldCBpc1Byb3AgPSBpc01lbWJlckluRWxlbWVudChlbG0sIG1lbWJlck5hbWUpO1xuICAgICAgICBsZXQgbG4gPSBtZW1iZXJOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChCVUlMRC52ZG9tQ2xhc3MgJiYgbWVtYmVyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWxtLmNsYXNzTGlzdDtcbiAgICAgICAgICAgIGNvbnN0IG9sZENsYXNzZXMgPSBwYXJzZUNsYXNzTGlzdChvbGRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBuZXdDbGFzc2VzID0gcGFyc2VDbGFzc0xpc3QobmV3VmFsdWUpO1xuICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSguLi5vbGRDbGFzc2VzLmZpbHRlcigoYykgPT4gYyAmJiAhbmV3Q2xhc3Nlcy5pbmNsdWRlcyhjKSkpO1xuICAgICAgICAgICAgY2xhc3NMaXN0LmFkZCguLi5uZXdDbGFzc2VzLmZpbHRlcigoYykgPT4gYyAmJiAhb2xkQ2xhc3Nlcy5pbmNsdWRlcyhjKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnZkb21TdHlsZSAmJiBtZW1iZXJOYW1lID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgc3R5bGUgYXR0cmlidXRlLCBjc3MgcHJvcGVydGllcyBhbmQgdmFsdWVzXG4gICAgICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3VmFsdWUgfHwgbmV3VmFsdWVbcHJvcF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBwcm9wLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGVbcHJvcF0gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghb2xkVmFsdWUgfHwgbmV3VmFsdWVbcHJvcF0gIT09IG9sZFZhbHVlW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgcHJvcC5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgbmV3VmFsdWVbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnN0eWxlW3Byb3BdID0gbmV3VmFsdWVbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbUtleSAmJiBtZW1iZXJOYW1lID09PSAna2V5JylcbiAgICAgICAgICAgIDtcbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbVJlZiAmJiBtZW1iZXJOYW1lID09PSAncmVmJykge1xuICAgICAgICAgICAgLy8gbWluaWZpZXIgd2lsbCBjbGVhbiB0aGlzIHVwXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZShlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnZkb21MaXN0ZW5lciAmJlxuICAgICAgICAgICAgKEJVSUxELmxhenlMb2FkID8gIWlzUHJvcCA6ICFlbG0uX19sb29rdXBTZXR0ZXJfXyhtZW1iZXJOYW1lKSkgJiZcbiAgICAgICAgICAgIG1lbWJlck5hbWVbMF0gPT09ICdvJyAmJlxuICAgICAgICAgICAgbWVtYmVyTmFtZVsxXSA9PT0gJ24nKSB7XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGVyc1xuICAgICAgICAgICAgLy8gc28gaWYgdGhlIG1lbWJlciBuYW1lIHN0YXJ0cyB3aXRoIFwib25cIiBhbmQgdGhlIDNyZCBjaGFyYWN0ZXJzIGlzXG4gICAgICAgICAgICAvLyBhIGNhcGl0YWwgbGV0dGVyLCBhbmQgaXQncyBub3QgYWxyZWFkeSBhIG1lbWJlciBvbiB0aGUgZWxlbWVudCxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UncmUgYXNzdW1pbmcgaXQncyBhbiBldmVudCBsaXN0ZW5lclxuICAgICAgICAgICAgaWYgKG1lbWJlck5hbWVbMl0gPT09ICctJykge1xuICAgICAgICAgICAgICAgIC8vIG9uLSBwcmVmaXhlZCBldmVudHNcbiAgICAgICAgICAgICAgICAvLyBhbGxvd3MgdG8gYmUgZXhwbGljaXQgYWJvdXQgdGhlIGRvbSBldmVudCB0byBsaXN0ZW4gd2l0aG91dCBhbnkgbWFnaWNcbiAgICAgICAgICAgICAgICAvLyB1bmRlciB0aGUgaG9vZDpcbiAgICAgICAgICAgICAgICAvLyA8bXktY21wIG9uLWNsaWNrPiAvLyBsaXN0ZW5zIGZvciBcImNsaWNrXCJcbiAgICAgICAgICAgICAgICAvLyA8bXktY21wIG9uLUNsaWNrPiAvLyBsaXN0ZW5zIGZvciBcIkNsaWNrXCJcbiAgICAgICAgICAgICAgICAvLyA8bXktY21wIG9uLWlvbkNoYW5nZT4gLy8gbGlzdGVucyBmb3IgXCJpb25DaGFuZ2VcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tRVZFTlRTPiAvLyBsaXN0ZW5zIGZvciBcIkVWRU5UU1wiXG4gICAgICAgICAgICAgICAgbWVtYmVyTmFtZSA9IG1lbWJlck5hbWUuc2xpY2UoMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc01lbWJlckluRWxlbWVudCh3aW4sIGxuKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gdGhlIEpTWCBhdHRyaWJ1dGUgY291bGQgaGF2ZSBiZWVuIFwib25Nb3VzZU92ZXJcIiBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gbWVtYmVyIG5hbWUgXCJvbm1vdXNlb3ZlclwiIGlzIG9uIHRoZSB3aW5kb3cncyBwcm90b3R5cGVcbiAgICAgICAgICAgICAgICAvLyBzbyBsZXQncyBhZGQgdGhlIGxpc3RlbmVyIFwibW91c2VvdmVyXCIsIHdoaWNoIGlzIGFsbCBsb3dlcmNhc2VkXG4gICAgICAgICAgICAgICAgbWVtYmVyTmFtZSA9IGxuLnNsaWNlKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gdGhlIEpTWCBhdHRyaWJ1dGUgY291bGQgaGF2ZSBiZWVuIFwib25NeUN1c3RvbUV2ZW50XCJcbiAgICAgICAgICAgICAgICAvLyBzbyBsZXQncyB0cmltIG9mZiB0aGUgXCJvblwiIHByZWZpeCBhbmQgbG93ZXJjYXNlIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAvLyBhbmQgYWRkIHRoZSBsaXN0ZW5lciBcIm15Q3VzdG9tRXZlbnRcIlxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNoYXJhY3Rlciwgd2Uga2VlcCB0aGUgZXZlbnQgbmFtZSBjYXNlXG4gICAgICAgICAgICAgICAgbWVtYmVyTmFtZSA9IGxuWzJdICsgbWVtYmVyTmFtZS5zbGljZSgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHBsdC5yZWwoZWxtLCBtZW1iZXJOYW1lLCBvbGRWYWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGx0LmFlbChlbG0sIG1lbWJlck5hbWUsIG5ld1ZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbVByb3BPckF0dHIpIHtcbiAgICAgICAgICAgIC8vIFNldCBwcm9wZXJ0eSBpZiBpdCBleGlzdHMgYW5kIGl0J3Mgbm90IGEgU1ZHXG4gICAgICAgICAgICBjb25zdCBpc0NvbXBsZXggPSBpc0NvbXBsZXhUeXBlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGlmICgoaXNQcm9wIHx8IChpc0NvbXBsZXggJiYgbmV3VmFsdWUgIT09IG51bGwpKSAmJiAhaXNTdmcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsbS50YWdOYW1lLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBuZXdWYWx1ZSA9PSBudWxsID8gJycgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIFNhZmFyaSwgbW92aW5nIHRoZSA8aW5wdXQ+IGNhcmV0IHdoZW4gcmUtYXNzaWduaW5nIHRoZSBzYW1lIHZhbHVlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlck5hbWUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUgPT0gbnVsbCB8fCBlbG1bbWVtYmVyTmFtZV0gIT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG1bbWVtYmVyTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5lZWQgdG8gbWFudWFsbHkgdXBkYXRlIGF0dHJpYnV0ZSBpZjpcbiAgICAgICAgICAgICAqIC0gbWVtYmVyTmFtZSBpcyBub3QgYW4gYXR0cmlidXRlXG4gICAgICAgICAgICAgKiAtIGlmIHdlIGFyZSByZW5kZXJpbmcgdGhlIGhvc3QgZWxlbWVudCBpbiBvcmRlciB0byByZWZsZWN0IGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogLSBpZiBpdCdzIGEgU1ZHLCBzaW5jZSBwcm9wZXJ0aWVzIG1pZ2h0IG5vdCB3b3JrIGluIDxzdmc+XG4gICAgICAgICAgICAgKiAtIGlmIHRoZSBuZXdWYWx1ZSBpcyBudWxsL3VuZGVmaW5lZCBvciAnZmFsc2UnLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgeGxpbmsgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tWGxpbmspIHtcbiAgICAgICAgICAgICAgICBpZiAobG4gIT09IChsbiA9IGxuLnJlcGxhY2UoL154bGlua1xcOj8vLCAnJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBsbjtcbiAgICAgICAgICAgICAgICAgICAgeGxpbmsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsIHx8IG5ld1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gZmFsc2UgfHwgZWxtLmdldEF0dHJpYnV0ZShtZW1iZXJOYW1lKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKFhMSU5LX05TLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUobWVtYmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoIWlzUHJvcCB8fCBmbGFncyAmIDQgLyogVk5PREVfRkxBR1MuaXNIb3N0ICovIHx8IGlzU3ZnKSAmJiAhaXNDb21wbGV4KSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZSA9PT0gdHJ1ZSA/ICcnIDogbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIG1lbWJlck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUobWVtYmVyTmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBwYXJzZUNsYXNzTGlzdFJlZ2V4ID0gL1xccy87XG5jb25zdCBwYXJzZUNsYXNzTGlzdCA9ICh2YWx1ZSkgPT4gKCF2YWx1ZSA/IFtdIDogdmFsdWUuc3BsaXQocGFyc2VDbGFzc0xpc3RSZWdleCkpO1xuY29uc3QgdXBkYXRlRWxlbWVudCA9IChvbGRWbm9kZSwgbmV3Vm5vZGUsIGlzU3ZnTW9kZSwgbWVtYmVyTmFtZSkgPT4ge1xuICAgIC8vIGlmIHRoZSBlbGVtZW50IHBhc3NlZCBpbiBpcyBhIHNoYWRvdyByb290LCB3aGljaCBpcyBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgLy8gdGhlbiB3ZSB3YW50IHRvIGJlIGFkZGluZyBhdHRycy9wcm9wcyB0byB0aGUgc2hhZG93IHJvb3QncyBcImhvc3RcIiBlbGVtZW50XG4gICAgLy8gaWYgaXQncyBub3QgYSBzaGFkb3cgcm9vdCwgdGhlbiB3ZSBhZGQgYXR0cnMvcHJvcHMgdG8gdGhlIHNhbWUgZWxlbWVudFxuICAgIGNvbnN0IGVsbSA9IG5ld1Zub2RlLiRlbG0kLm5vZGVUeXBlID09PSAxMSAvKiBOT0RFX1RZUEUuRG9jdW1lbnRGcmFnbWVudCAqLyAmJiBuZXdWbm9kZS4kZWxtJC5ob3N0XG4gICAgICAgID8gbmV3Vm5vZGUuJGVsbSQuaG9zdFxuICAgICAgICA6IG5ld1Zub2RlLiRlbG0kO1xuICAgIGNvbnN0IG9sZFZub2RlQXR0cnMgPSAob2xkVm5vZGUgJiYgb2xkVm5vZGUuJGF0dHJzJCkgfHwgRU1QVFlfT0JKO1xuICAgIGNvbnN0IG5ld1Zub2RlQXR0cnMgPSBuZXdWbm9kZS4kYXR0cnMkIHx8IEVNUFRZX09CSjtcbiAgICBpZiAoQlVJTEQudXBkYXRhYmxlKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhdHRyaWJ1dGVzIG5vIGxvbmdlciBwcmVzZW50IG9uIHRoZSB2bm9kZSBieSBzZXR0aW5nIHRoZW0gdG8gdW5kZWZpbmVkXG4gICAgICAgIGZvciAobWVtYmVyTmFtZSBpbiBvbGRWbm9kZUF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoIShtZW1iZXJOYW1lIGluIG5ld1Zub2RlQXR0cnMpKSB7XG4gICAgICAgICAgICAgICAgc2V0QWNjZXNzb3IoZWxtLCBtZW1iZXJOYW1lLCBvbGRWbm9kZUF0dHJzW21lbWJlck5hbWVdLCB1bmRlZmluZWQsIGlzU3ZnTW9kZSwgbmV3Vm5vZGUuJGZsYWdzJCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIG5ldyAmIHVwZGF0ZSBjaGFuZ2VkIGF0dHJpYnV0ZXNcbiAgICBmb3IgKG1lbWJlck5hbWUgaW4gbmV3Vm5vZGVBdHRycykge1xuICAgICAgICBzZXRBY2Nlc3NvcihlbG0sIG1lbWJlck5hbWUsIG9sZFZub2RlQXR0cnNbbWVtYmVyTmFtZV0sIG5ld1Zub2RlQXR0cnNbbWVtYmVyTmFtZV0sIGlzU3ZnTW9kZSwgbmV3Vm5vZGUuJGZsYWdzJCk7XG4gICAgfVxufTtcbi8qKlxuICogQ3JlYXRlIGEgRE9NIE5vZGUgY29ycmVzcG9uZGluZyB0byBvbmUgb2YgdGhlIGNoaWxkcmVuIG9mIGEgZ2l2ZW4gVk5vZGUuXG4gKlxuICogQHBhcmFtIG9sZFBhcmVudFZOb2RlIHRoZSBwYXJlbnQgVk5vZGUgZnJvbSB0aGUgcHJldmlvdXMgcmVuZGVyXG4gKiBAcGFyYW0gbmV3UGFyZW50Vk5vZGUgdGhlIHBhcmVudCBWTm9kZSBmcm9tIHRoZSBjdXJyZW50IHJlbmRlclxuICogQHBhcmFtIGNoaWxkSW5kZXggdGhlIGluZGV4IG9mIHRoZSBWTm9kZSwgaW4gdGhlIF9uZXdfIHBhcmVudCBub2RlJ3NcbiAqIGNoaWxkcmVuLCBmb3Igd2hpY2ggd2Ugd2lsbCBjcmVhdGUgYSBuZXcgRE9NIG5vZGVcbiAqIEBwYXJhbSBwYXJlbnRFbG0gdGhlIHBhcmVudCBET00gbm9kZSB3aGljaCBvdXIgbmV3IG5vZGUgd2lsbCBiZSBhIGNoaWxkIG9mXG4gKiBAcmV0dXJucyB0aGUgbmV3bHkgY3JlYXRlZCBub2RlXG4gKi9cbmNvbnN0IGNyZWF0ZUVsbSA9IChvbGRQYXJlbnRWTm9kZSwgbmV3UGFyZW50Vk5vZGUsIGNoaWxkSW5kZXgsIHBhcmVudEVsbSkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWNvbnN0XG4gICAgY29uc3QgbmV3Vk5vZGUgPSBuZXdQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgZWxtO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IG9sZFZOb2RlO1xuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAhdXNlTmF0aXZlU2hhZG93RG9tKSB7XG4gICAgICAgIC8vIHJlbWVtYmVyIGZvciBsYXRlciB3ZSBuZWVkIHRvIGNoZWNrIHRvIHJlbG9jYXRlIG5vZGVzXG4gICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgICAgaWYgKG5ld1ZOb2RlLiR0YWckID09PSAnc2xvdCcpIHtcbiAgICAgICAgICAgIGlmIChzY29wZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gc2NvcGVkIGNzcyBuZWVkcyB0byBhZGQgaXRzIHNjb3BlZCBpZCB0byB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBwYXJlbnRFbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdWTm9kZS4kZmxhZ3MkIHw9IG5ld1ZOb2RlLiRjaGlsZHJlbiRcbiAgICAgICAgICAgICAgICA/IC8vIHNsb3QgZWxlbWVudCBoYXMgZmFsbGJhY2sgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAyIC8qIFZOT0RFX0ZMQUdTLmlzU2xvdEZhbGxiYWNrICovXG4gICAgICAgICAgICAgICAgOiAvLyBzbG90IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBmYWxsYmFjayBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDEgLyogVk5PREVfRkxBR1MuaXNTbG90UmVmZXJlbmNlICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5pc0RldiAmJiBuZXdWTm9kZS4kZWxtJCkge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRoZSBKU1ggJHtuZXdWTm9kZS4kdGV4dCQgIT09IG51bGwgPyBgXCIke25ld1ZOb2RlLiR0ZXh0JH1cIiB0ZXh0YCA6IGBcIiR7bmV3Vk5vZGUuJHRhZyR9XCIgZWxlbWVudGB9IG5vZGUgc2hvdWxkIG5vdCBiZSBzaGFyZWQgd2l0aGluIHRoZSBzYW1lIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2FjaGVzIGVsZW1lbnQgbG9va3VwcyBpbiBvcmRlciB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLiBIb3dldmVyLCBhIHNpZGUgZWZmZWN0IGZyb20gdGhpcyBpcyB0aGF0IHRoZSBleGFjdCBzYW1lIEpTWCBub2RlIHNob3VsZCBub3QgYmUgcmV1c2VkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBwbGVhc2Ugc2VlIGh0dHBzOi8vc3RlbmNpbGpzLmNvbS9kb2NzL3RlbXBsYXRpbmctanN4I2F2b2lkLXNoYXJlZC1qc3gtbm9kZXNgKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21UZXh0ICYmIG5ld1ZOb2RlLiR0ZXh0JCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBjcmVhdGUgdGV4dCBub2RlXG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID0gZG9jLmNyZWF0ZVRleHROb2RlKG5ld1ZOb2RlLiR0ZXh0JCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlLiRmbGFncyQgJiAxIC8qIFZOT0RFX0ZMQUdTLmlzU2xvdFJlZmVyZW5jZSAqLykge1xuICAgICAgICAvLyBjcmVhdGUgYSBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID1cbiAgICAgICAgICAgIEJVSUxELmlzRGVidWcgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBzbG90UmVmZXJlbmNlRGVidWdOb2RlKG5ld1ZOb2RlKSA6IGRvYy5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmICFpc1N2Z01vZGUpIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IG5ld1ZOb2RlLiR0YWckID09PSAnc3ZnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgZWxlbWVudFxuICAgICAgICBlbG0gPSBuZXdWTm9kZS4kZWxtJCA9IChCVUlMRC5zdmdcbiAgICAgICAgICAgID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhpc1N2Z01vZGUgPyBTVkdfTlMgOiBIVE1MX05TLCBCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBuZXdWTm9kZS4kZmxhZ3MkICYgMiAvKiBWTk9ERV9GTEFHUy5pc1Nsb3RGYWxsYmFjayAqL1xuICAgICAgICAgICAgICAgID8gJ3Nsb3QtZmInXG4gICAgICAgICAgICAgICAgOiBuZXdWTm9kZS4kdGFnJClcbiAgICAgICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgbmV3Vk5vZGUuJGZsYWdzJCAmIDIgLyogVk5PREVfRkxBR1MuaXNTbG90RmFsbGJhY2sgKi9cbiAgICAgICAgICAgICAgICA/ICdzbG90LWZiJ1xuICAgICAgICAgICAgICAgIDogbmV3Vk5vZGUuJHRhZyQpKTtcbiAgICAgICAgaWYgKEJVSUxELnN2ZyAmJiBpc1N2Z01vZGUgJiYgbmV3Vk5vZGUuJHRhZyQgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGNzcyBjbGFzc2VzLCBhdHRycywgcHJvcHMsIGxpc3RlbmVycywgZXRjLlxuICAgICAgICBpZiAoQlVJTEQudmRvbUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdXBkYXRlRWxlbWVudChudWxsLCBuZXdWTm9kZSwgaXNTdmdNb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKEJVSUxELnNoYWRvd0RvbSB8fCBCVUlMRC5zY29wZWQpICYmIGlzRGVmKHNjb3BlSWQpICYmIGVsbVsncy1zaSddICE9PSBzY29wZUlkKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNjb3BlSWQgYW5kIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgICAvLyB0aGVuIGxldCdzIGFkZCB0aGUgc2NvcGVJZCBhcyBhIGNzcyBjbGFzc1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoKGVsbVsncy1zaSddID0gc2NvcGVJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3Vk5vZGUuJGNoaWxkcmVuJC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgbm9kZVxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShvbGRQYXJlbnRWTm9kZSwgbmV3Vk5vZGUsIGksIGVsbSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIG5vZGUgY291bGQgaGF2ZSBiZWVuIG51bGxcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBvdXIgbmV3IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgZWxtLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdmcpIHtcbiAgICAgICAgICAgIGlmIChuZXdWTm9kZS4kdGFnJCA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlc2V0IHRoZSBTVkcgY29udGV4dCB3aGVuIHdlJ3JlIGV4aXRpbmcgPHN2Zz4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxtLnRhZ05hbWUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlZW50ZXIgU1ZHIGNvbnRleHQgd2hlbiB3ZSdyZSBleGl0aW5nIDxmb3JlaWduT2JqZWN0PiBlbGVtZW50XG4gICAgICAgICAgICAgICAgaXNTdmdNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgZWxtWydzLWhuJ10gPSBob3N0VGFnTmFtZTtcbiAgICAgICAgaWYgKG5ld1ZOb2RlLiRmbGFncyQgJiAoMiAvKiBWTk9ERV9GTEFHUy5pc1Nsb3RGYWxsYmFjayAqLyB8IDEgLyogVk5PREVfRkxBR1MuaXNTbG90UmVmZXJlbmNlICovKSkge1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGNvbnRlbnQgcmVmZXJlbmNlIGNvbW1lbnRcbiAgICAgICAgICAgIGVsbVsncy1zciddID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBjb250ZW50IHJlZmVyZW5jZSBjb21tZW50XG4gICAgICAgICAgICBlbG1bJ3MtY3InXSA9IGNvbnRlbnRSZWY7XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgc2xvdCBuYW1lLCBvciBlbXB0eSBzdHJpbmcgZm9yIGRlZmF1bHQgc2xvdFxuICAgICAgICAgICAgZWxtWydzLXNuJ10gPSBuZXdWTm9kZS4kbmFtZSQgfHwgJyc7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYW4gb2xkIHZub2RlIGZvciB0aGlzIHNsb3RcbiAgICAgICAgICAgIG9sZFZOb2RlID0gb2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuJGNoaWxkcmVuJCAmJiBvbGRQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICAgICAgICAgICAgaWYgKG9sZFZOb2RlICYmIG9sZFZOb2RlLiR0YWckID09PSBuZXdWTm9kZS4kdGFnJCAmJiBvbGRQYXJlbnRWTm9kZS4kZWxtJCkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIGdvdCBhbiBvbGQgc2xvdCB2bm9kZSBhbmQgdGhlIHdyYXBwZXIgaXMgYmVpbmcgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAvLyBzbyBsZXQncyBtb3ZlIHRoZSBvbGQgc2xvdCBjb250ZW50IGJhY2sgdG8gaXQncyBvcmlnaW5hbCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkUGFyZW50Vk5vZGUuJGVsbSQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxtO1xufTtcbmNvbnN0IHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24gPSAocGFyZW50RWxtLCByZWN1cnNpdmUpID0+IHtcbiAgICBwbHQuJGZsYWdzJCB8PSAxIC8qIFBMQVRGT1JNX0ZMQUdTLmlzVG1wRGlzY29ubmVjdGVkICovO1xuICAgIGNvbnN0IG9sZFNsb3RDaGlsZE5vZGVzID0gcGFyZW50RWxtLmNoaWxkTm9kZXM7XG4gICAgZm9yIChsZXQgaSA9IG9sZFNsb3RDaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG9sZFNsb3RDaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlWydzLWhuJ10gIT09IGhvc3RUYWdOYW1lICYmIGNoaWxkTm9kZVsncy1vbCddKSB7XG4gICAgICAgICAgICAvLyAvLyB0aGlzIGNoaWxkIG5vZGUgaW4gdGhlIG9sZCBlbGVtZW50IGlzIGZyb20gYW5vdGhlciBjb21wb25lbnRcbiAgICAgICAgICAgIC8vIC8vIHJlbW92ZSB0aGlzIG5vZGUgZnJvbSB0aGUgb2xkIHNsb3QncyBwYXJlbnRcbiAgICAgICAgICAgIC8vIGNoaWxkTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIC8vIGFuZCByZWxvY2F0ZSBpdCBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZU5vZGUoY2hpbGROb2RlKS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGQgb3JpZ2luYWwgbG9jYXRpb24gY29tbWVudCBlbnRpcmVseVxuICAgICAgICAgICAgLy8gbGF0ZXIgb24gdGhlIHBhdGNoIGZ1bmN0aW9uIHdpbGwga25vdyB3aGF0IHRvIGRvXG4gICAgICAgICAgICAvLyBhbmQgbW92ZSB0aGlzIHRvIHRoZSBjb3JyZWN0IHNwb3QgaW4gbmVlZCBiZVxuICAgICAgICAgICAgY2hpbGROb2RlWydzLW9sJ10ucmVtb3ZlKCk7XG4gICAgICAgICAgICBjaGlsZE5vZGVbJ3Mtb2wnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGNoaWxkTm9kZSwgcmVjdXJzaXZlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwbHQuJGZsYWdzJCAmPSB+MSAvKiBQTEFURk9STV9GTEFHUy5pc1RtcERpc2Nvbm5lY3RlZCAqLztcbn07XG4vKipcbiAqIENyZWF0ZSBET00gbm9kZXMgY29ycmVzcG9uZGluZyB0byBhIGxpc3Qgb2Yge0BsaW5rIGQuVm5vZGV9IG9iamVjdHMgYW5kXG4gKiBhZGQgdGhlbSB0byB0aGUgRE9NIGluIHRoZSBhcHByb3ByaWF0ZSBwbGFjZS5cbiAqXG4gKiBAcGFyYW0gcGFyZW50RWxtIHRoZSBET00gbm9kZSB3aGljaCBzaG91bGQgYmUgdXNlZCBhcyBhIHBhcmVudCBmb3IgdGhlIG5ld1xuICogRE9NIG5vZGVzXG4gKiBAcGFyYW0gYmVmb3JlIGEgY2hpbGQgb2YgdGhlIGBwYXJlbnRFbG1gIHdoaWNoIHRoZSBuZXcgY2hpbGRyZW4gc2hvdWxkIGJlXG4gKiBpbnNlcnRlZCBiZWZvcmUgKG9wdGlvbmFsKVxuICogQHBhcmFtIHBhcmVudFZOb2RlIHRoZSBwYXJlbnQgdmlydHVhbCBET00gbm9kZVxuICogQHBhcmFtIHZub2RlcyB0aGUgbmV3IGNoaWxkIHZpcnR1YWwgRE9NIG5vZGVzIHRvIHByb2R1Y2UgRE9NIG5vZGVzIGZvclxuICogQHBhcmFtIHN0YXJ0SWR4IHRoZSBpbmRleCBpbiB0aGUgY2hpbGQgdmlydHVhbCBET00gbm9kZXMgYXQgd2hpY2ggdG8gc3RhcnRcbiAqIGNyZWF0aW5nIERPTSBub2RlcyAoaW5jbHVzaXZlKVxuICogQHBhcmFtIGVuZElkeCB0aGUgaW5kZXggaW4gdGhlIGNoaWxkIHZpcnR1YWwgRE9NIG5vZGVzIGF0IHdoaWNoIHRvIHN0b3BcbiAqIGNyZWF0aW5nIERPTSBub2RlcyAoaW5jbHVzaXZlKVxuICovXG5jb25zdCBhZGRWbm9kZXMgPSAocGFyZW50RWxtLCBiZWZvcmUsIHBhcmVudFZOb2RlLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpID0+IHtcbiAgICBsZXQgY29udGFpbmVyRWxtID0gKChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBwYXJlbnRFbG1bJ3MtY3InXSAmJiBwYXJlbnRFbG1bJ3MtY3InXS5wYXJlbnROb2RlKSB8fCBwYXJlbnRFbG0pO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBjb250YWluZXJFbG0uc2hhZG93Um9vdCAmJiBjb250YWluZXJFbG0udGFnTmFtZSA9PT0gaG9zdFRhZ05hbWUpIHtcbiAgICAgICAgY29udGFpbmVyRWxtID0gY29udGFpbmVyRWxtLnNoYWRvd1Jvb3Q7XG4gICAgfVxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgaWYgKHZub2Rlc1tzdGFydElkeF0pIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShudWxsLCBwYXJlbnRWTm9kZSwgc3RhcnRJZHgsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVzW3N0YXJ0SWR4XS4kZWxtJCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbG0uaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgQlVJTEQuc2xvdFJlbG9jYXRpb24gPyByZWZlcmVuY2VOb2RlKGJlZm9yZSkgOiBiZWZvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogUmVtb3ZlIHRoZSBET00gZWxlbWVudHMgY29ycmVzcG9uZGluZyB0byBhIGxpc3Qgb2Yge0BsaW5rIGQuVk5vZGV9IG9iamVjdHMuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvLCBmb3IgaW5zdGFuY2UsIGNsZWFuIHVwIGFmdGVyIGEgbGlzdCBvZiBjaGlsZHJlbiB3aGljaFxuICogc2hvdWxkIG5vIGxvbmdlciBiZSBzaG93bi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsc28gaGFuZGxlcyBzb21lIG9mIFN0ZW5jaWwncyBzbG90IHJlbG9jYXRpb24gbG9naWMuXG4gKlxuICogQHBhcmFtIHZub2RlcyBhIGxpc3Qgb2YgdmlydHVhbCBET00gbm9kZXMgdG8gcmVtb3ZlXG4gKiBAcGFyYW0gc3RhcnRJZHggdGhlIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IHJlbW92aW5nIG5vZGVzIChpbmNsdXNpdmUpXG4gKiBAcGFyYW0gZW5kSWR4IHRoZSBpbmRleCBhdCB3aGljaCB0byBzdG9wIHJlbW92aW5nIG5vZGVzIChpbmNsdXNpdmUpXG4gKiBAcGFyYW0gdm5vZGUgYSBWTm9kZVxuICogQHBhcmFtIGVsbSBhbiBlbGVtZW50XG4gKi9cbmNvbnN0IHJlbW92ZVZub2RlcyA9ICh2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIHZub2RlLCBlbG0pID0+IHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgIGlmICgodm5vZGUgPSB2bm9kZXNbc3RhcnRJZHhdKSkge1xuICAgICAgICAgICAgZWxtID0gdm5vZGUuJGVsbSQ7XG4gICAgICAgICAgICBjYWxsTm9kZVJlZnModm5vZGUpO1xuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UncmUgcmVtb3ZpbmcgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gc28gaXQncyBwb3NzaWJsZSB3ZSBuZWVkIHRvIHNob3cgc2xvdCBmYWxsYmFjayBjb250ZW50IG5vd1xuICAgICAgICAgICAgICAgIGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGVsbVsncy1vbCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgb3JpZ2luYWwgbG9jYXRpb24gY29tbWVudFxuICAgICAgICAgICAgICAgICAgICBlbG1bJ3Mtb2wnXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCBjaGlsZCBub2RlcyBvZiB0aGUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0J3MgYmVpbmcgcmVtb3ZlZCBhcmUgc2xvdCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGVsbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB2bm9kZSdzIGVsZW1lbnQgZnJvbSB0aGUgZG9tXG4gICAgICAgICAgICBlbG0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBSZWNvbmNpbGUgdGhlIGNoaWxkcmVuIG9mIGEgbmV3IFZOb2RlIHdpdGggdGhlIGNoaWxkcmVuIG9mIGFuIG9sZCBWTm9kZSBieVxuICogdHJhdmVyc2luZyB0aGUgdHdvIGNvbGxlY3Rpb25zIG9mIGNoaWxkcmVuLCBpZGVudGlmeWluZyBub2RlcyB0aGF0IGFyZVxuICogY29uc2VydmVkIG9yIGNoYW5nZWQsIGNhbGxpbmcgb3V0IHRvIGBwYXRjaGAgdG8gbWFrZSBhbnkgbmVjZXNzYXJ5XG4gKiB1cGRhdGVzIHRvIHRoZSBET00sIGFuZCByZWFycmFuZ2luZyBET00gbm9kZXMgYXMgbmVlZGVkLlxuICpcbiAqIFRoZSBhbGdvcml0aG0gZm9yIHJlY29uY2lsaW5nIGNoaWxkcmVuIHdvcmtzIGJ5IGFuYWx5emluZyB0d28gJ3dpbmRvd3MnIG9udG9cbiAqIHRoZSB0d28gYXJyYXlzIG9mIGNoaWxkcmVuIChgb2xkQ2hgIGFuZCBgbmV3Q2hgKS4gV2Uga2VlcCB0cmFjayBvZiB0aGVcbiAqICd3aW5kb3dzJyBieSBzdG9yaW5nIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyBhbmQgcmVmZXJlbmNlcyB0byB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgYXJyYXkgZW50cmllcy4gSW5pdGlhbGx5IHRoZSB0d28gJ3dpbmRvd3MnIGFyZSBiYXNpY2FsbHkgZXF1YWxcbiAqIHRvIHRoZSBlbnRpcmUgYXJyYXksIGJ1dCB3ZSBwcm9ncmVzc2l2ZWx5IG5hcnJvdyB0aGUgd2luZG93cyB1bnRpbCB0aGVyZSBhcmVcbiAqIG5vIGNoaWxkcmVuIGxlZnQgdG8gdXBkYXRlIGJ5IGRvaW5nIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogMS4gU2tpcCBhbnkgYG51bGxgIGVudHJpZXMgYXQgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIHR3byBhcnJheXMsIHNvXG4gKiAgICB0aGF0IGlmIHdlIGhhdmUgYW4gaW5pdGlhbCBhcnJheSBsaWtlIHRoZSBmb2xsb3dpbmcgd2UnbGwgZW5kIHVwIGRlYWxpbmdcbiAqICAgIG9ubHkgd2l0aCBhIHdpbmRvdyBib3VuZGVkIGJ5IHRoZSBoaWdobGlnaHRlZCBlbGVtZW50czpcbiAqXG4gKiAgICBbbnVsbCwgbnVsbCwgVk5vZGUxICwgLi4uICwgVk5vZGUyLCBudWxsLCBudWxsXVxuICogICAgICAgICAgICAgICAgIF5eXl5eXiAgICAgICAgIF5eXl5eXlxuICpcbiAqIDIuIENoZWNrIHRvIHNlZSBpZiB0aGUgZWxlbWVudHMgYXQgdGhlIGhlYWQgYW5kIHRhaWwgcG9zaXRpb25zIGFyZSBlcXVhbFxuICogICAgYWNyb3NzIHRoZSB3aW5kb3dzLiBUaGlzIHdpbGwgYmFzaWNhbGx5IGRldGVjdCBlbGVtZW50cyB3aGljaCBoYXZlbid0XG4gKiAgICBiZWVuIGFkZGVkLCByZW1vdmVkLCBvciBjaGFuZ2VkIHBvc2l0aW9uLCBpLmUuIGlmIHlvdSBoYWQgdGhlIGZvbGxvd2luZ1xuICogICAgVk5vZGUgZWxlbWVudHMgKHJlcHJlc2VudGVkIGFzIEhUTUwpOlxuICpcbiAqICAgIG9sZFZOb2RlOiBgPGRpdj48cD48c3Bhbj5IRVk8L3NwYW4+PC9wPjwvZGl2PmBcbiAqICAgIG5ld1ZOb2RlOiBgPGRpdj48cD48c3Bhbj5USEVSRTwvc3Bhbj48L3A+PC9kaXY+YFxuICpcbiAqICAgIFRoZW4gd2hlbiBjb21wYXJpbmcgdGhlIGNoaWxkcmVuIG9mIHRoZSBgPGRpdj5gIHRhZyB3ZSBjaGVjayB0aGUgZXF1YWxpdHlcbiAqICAgIG9mIHRoZSBWTm9kZXMgY29ycmVzcG9uZGluZyB0byB0aGUgYDxwPmAgdGFncyBhbmQsIHNpbmNlIHRoZXkgYXJlIHRoZVxuICogICAgc2FtZSB0YWcgaW4gdGhlIHNhbWUgcG9zaXRpb24sIHdlJ2QgYmUgYWJsZSB0byBhdm9pZCBjb21wbGV0ZWx5XG4gKiAgICByZS1yZW5kZXJpbmcgdGhlIHN1YnRyZWUgdW5kZXIgdGhlbSB3aXRoIGEgbmV3IERPTSBlbGVtZW50IGFuZCB3b3VsZCBqdXN0XG4gKiAgICBjYWxsIG91dCB0byBgcGF0Y2hgIHRvIGhhbmRsZSByZWNvbmNpbGluZyB0aGVpciBjaGlsZHJlbiBhbmQgc28gb24uXG4gKlxuICogMy4gQ2hlY2ssIGZvciBib3RoIHdpbmRvd3MsIHRvIHNlZSBpZiB0aGUgZWxlbWVudCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICogICAgd2luZG93IGNvcnJlc3BvbmRzIHRvIHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIG90aGVyIHdpbmRvdy4gVGhpcyBpc1xuICogICAgYSBoZXVyaXN0aWMgd2hpY2ggd2lsbCBsZXQgdXMgaWRlbnRpZnkgX3NvbWVfIHNpdHVhdGlvbnMgaW4gd2hpY2hcbiAqICAgIGVsZW1lbnRzIGhhdmUgY2hhbmdlZCBwb3NpdGlvbiwgZm9yIGluc3RhbmNlIGl0IF9zaG91bGRfIGRldGVjdCB0aGF0IHRoZVxuICogICAgY2hpbGRyZW4gbm9kZXMgdGhlbXNlbHZlcyBoYXZlIG5vdCBjaGFuZ2VkIGJ1dCBtZXJlbHkgbW92ZWQgaW4gdGhlXG4gKiAgICBmb2xsb3dpbmcgZXhhbXBsZTpcbiAqXG4gKiAgICBvbGRWTm9kZTogYDxkaXY+PGVsZW1lbnQtb25lIC8+PGVsZW1lbnQtdHdvIC8+PC9kaXY+YFxuICogICAgbmV3Vk5vZGU6IGA8ZGl2PjxlbGVtZW50LXR3byAvPjxlbGVtZW50LW9uZSAvPjwvZGl2PmBcbiAqXG4gKiAgICBJZiB3ZSBmaW5kIGNhc2VzIGxpa2UgdGhpcyB0aGVuIHdlIGFsc28gbmVlZCB0byBtb3ZlIHRoZSBjb25jcmV0ZSBET01cbiAqICAgIGVsZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1vdmVkIGNoaWxkcmVuIHRvIHdyaXRlIHRoZSByZS1vcmRlciB0byB0aGVcbiAqICAgIERPTS5cbiAqXG4gKiA0LiBGaW5hbGx5LCBpZiBWTm9kZXMgaGF2ZSB0aGUgYGtleWAgYXR0cmlidXRlIHNldCBvbiB0aGVtIHdlIGNoZWNrIGZvciBhbnlcbiAqICAgIG5vZGVzIGluIHRoZSBvbGQgY2hpbGRyZW4gd2hpY2ggaGF2ZSB0aGUgc2FtZSBrZXkgYXMgdGhlIGZpcnN0IGVsZW1lbnQgaW5cbiAqICAgIG91ciB3aW5kb3cgb24gdGhlIG5ldyBjaGlsZHJlbi4gSWYgd2UgZmluZCBzdWNoIGEgbm9kZSB3ZSBoYW5kbGUgY2FsbGluZ1xuICogICAgb3V0IHRvIGBwYXRjaGAsIG1vdmluZyByZWxldmFudCBET00gbm9kZXMsIGFuZCBzbyBvbiwgaW4gYWNjb3JkYW5jZSB3aXRoXG4gKiAgICB3aGF0IHdlIGZpbmQuXG4gKlxuICogRmluYWxseSwgb25jZSB3ZSd2ZSBuYXJyb3dlZCBvdXIgJ3dpbmRvd3MnIHRvIHRoZSBwb2ludCB0aGF0IGVpdGhlciBvZiB0aGVtXG4gKiBjb2xsYXBzZSAoaS5lLiB0aGV5IGhhdmUgbGVuZ3RoIDApIHdlIHRoZW4gaGFuZGxlIGFueSByZW1haW5pbmcgVk5vZGVcbiAqIGluc2VydGlvbiBvciBkZWxldGlvbiB0aGF0IG5lZWRzIHRvIGhhcHBlbiB0byBnZXQgYSBET00gc3RhdGUgdGhhdCBjb3JyZWN0bHlcbiAqIHJlZmxlY3RzIHRoZSBuZXcgY2hpbGQgVk5vZGVzLiBJZiwgZm9yIGluc3RhbmNlLCBhZnRlciBvdXIgd2luZG93IG9uIHRoZSBvbGRcbiAqIGNoaWxkcmVuIGhhcyBjb2xsYXBzZWQgd2Ugc3RpbGwgaGF2ZSBtb3JlIG5vZGVzIG9uIHRoZSBuZXcgY2hpbGRyZW4gdGhhdFxuICogd2UgaGF2ZW4ndCBkZWFsdCB3aXRoIHlldCB0aGVuIHdlIG5lZWQgdG8gYWRkIHRoZW0sIG9yIGlmIHRoZSBuZXcgY2hpbGRyZW5cbiAqIGNvbGxhcHNlIGJ1dCB3ZSBzdGlsbCBoYXZlIHVuaGFuZGxlZCBfb2xkXyBjaGlsZHJlbiB0aGVuIHdlIG5lZWQgdG8gbWFrZVxuICogc3VyZSB0aGUgY29ycmVzcG9uZGluZyBET00gbm9kZXMgYXJlIHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHBhcmVudEVsbSB0aGUgbm9kZSBpbnRvIHdoaWNoIHRoZSBwYXJlbnQgVk5vZGUgaXMgcmVuZGVyZWRcbiAqIEBwYXJhbSBvbGRDaCB0aGUgb2xkIGNoaWxkcmVuIG9mIHRoZSBwYXJlbnQgbm9kZVxuICogQHBhcmFtIG5ld1ZOb2RlIHRoZSBuZXcgVk5vZGUgd2hpY2ggd2lsbCByZXBsYWNlIHRoZSBwYXJlbnRcbiAqIEBwYXJhbSBuZXdDaCB0aGUgbmV3IGNoaWxkcmVuIG9mIHRoZSBwYXJlbnQgbm9kZVxuICovXG5jb25zdCB1cGRhdGVDaGlsZHJlbiA9IChwYXJlbnRFbG0sIG9sZENoLCBuZXdWTm9kZSwgbmV3Q2gpID0+IHtcbiAgICBsZXQgb2xkU3RhcnRJZHggPSAwO1xuICAgIGxldCBuZXdTdGFydElkeCA9IDA7XG4gICAgbGV0IGlkeEluT2xkID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgbGV0IG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICBsZXQgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIGxldCBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIGxldCBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgbGV0IG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgZWxtVG9Nb3ZlO1xuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICAgIGlmIChvbGRTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFZOb2RlIG1pZ2h0IGhhdmUgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkRW5kVm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhcnRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3RW5kVm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzdGFydCBub2RlcyBhcmUgdGhlIHNhbWUgdGhlbiB3ZSBzaG91bGQgcGF0Y2ggdGhlIG5ldyBWTm9kZVxuICAgICAgICAgICAgLy8gb250byB0aGUgb2xkIG9uZSwgYW5kIGluY3JlbWVudCBvdXIgYG5ld1N0YXJ0SWR4YCBhbmQgYG9sZFN0YXJ0SWR4YFxuICAgICAgICAgICAgLy8gaW5kaWNlcyB0byByZWZsZWN0IHRoYXQuIFdlIGRvbid0IG5lZWQgdG8gbW92ZSBhbnkgRE9NIE5vZGVzIGFyb3VuZFxuICAgICAgICAgICAgLy8gc2luY2UgdGhpbmdzIGFyZSBtYXRjaGVkIHVwIGluIG9yZGVyLlxuICAgICAgICAgICAgcGF0Y2gob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSk7XG4gICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICAgICAgLy8gbGlrZXdpc2UsIGlmIHRoZSBlbmQgbm9kZXMgYXJlIHRoZSBzYW1lIHdlIHBhdGNoIG5ldyBvbnRvIG9sZCBhbmRcbiAgICAgICAgICAgIC8vIGRlY3JlbWVudCBvdXIgZW5kIGluZGljZXMsIGFuZCBhbHNvIGxpa2V3aXNlIGluIHRoaXMgY2FzZSB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gbmVlZCB0byBtb3ZlIGFueSBET00gTm9kZXMuXG4gICAgICAgICAgICBwYXRjaChvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGNhc2U6IFwiVm5vZGUgbW92ZWQgcmlnaHRcIlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFdlJ3ZlIGZvdW5kIHRoYXQgdGhlIGxhc3Qgbm9kZSBpbiBvdXIgd2luZG93IG9uIHRoZSBuZXcgY2hpbGRyZW4gaXNcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIFZOb2RlIGFzIHRoZSBfZmlyc3RfIG5vZGUgaW4gb3VyIHdpbmRvdyBvbiB0aGUgb2xkIGNoaWxkcmVuXG4gICAgICAgICAgICAvLyB3ZSdyZSBkZWFsaW5nIHdpdGggbm93LiBWaXN1YWxseSwgdGhpcyBpcyB0aGUgbGF5b3V0IG9mIHRoZXNlIHR3b1xuICAgICAgICAgICAgLy8gbm9kZXM6XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gbmV3Q2g6IFsuLi4sIG5ld1N0YXJ0Vm5vZGUgLCAuLi4gLCBuZXdFbmRWbm9kZSAsIC4uLl1cbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl5cbiAgICAgICAgICAgIC8vIG9sZENoOiBbLi4uLCBvbGRTdGFydFZub2RlICwgLi4uICwgb2xkRW5kVm5vZGUgLCAuLi5dXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgXl5eXl5eXl5eXl5eXlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEluIHRoaXMgc2l0dWF0aW9uIHdlIG5lZWQgdG8gcGF0Y2ggYG5ld0VuZFZub2RlYCBvbnRvIGBvbGRTdGFydFZub2RlYFxuICAgICAgICAgICAgLy8gYW5kIG1vdmUgdGhlIERPTSBlbGVtZW50IGZvciBgb2xkU3RhcnRWbm9kZWAuXG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgKG9sZFN0YXJ0Vm5vZGUuJHRhZyQgPT09ICdzbG90JyB8fCBuZXdFbmRWbm9kZS4kdGFnJCA9PT0gJ3Nsb3QnKSkge1xuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkU3RhcnRWbm9kZS4kZWxtJC5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaChvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSk7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG1vdmUgdGhlIGVsZW1lbnQgZm9yIGBvbGRTdGFydFZub2RlYCBpbnRvIGEgcG9zaXRpb24gd2hpY2hcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgYXBwcm9wcmlhdGUgZm9yIGBuZXdFbmRWbm9kZWAuIEZvciB0aGlzIHdlIGNhbiB1c2VcbiAgICAgICAgICAgIC8vIGAuaW5zZXJ0QmVmb3JlYCBhbmQgYG9sZEVuZFZub2RlLiRlbG0kLm5leHRTaWJsaW5nYC4gSWYgdGhlcmUgaXMgYVxuICAgICAgICAgICAgLy8gc2libGluZyBmb3IgYG9sZEVuZFZub2RlLiRlbG0kYCB0aGVuIHdlIHdhbnQgdG8gbW92ZSB0aGUgRE9NIG5vZGUgZm9yXG4gICAgICAgICAgICAvLyBgb2xkU3RhcnRWbm9kZWAgYmV0d2VlbiBgb2xkRW5kVm5vZGVgIGFuZCBpdCdzIHNpYmxpbmcsIGxpa2Ugc286XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gPG9sZC1zdGFydC1ub2RlIC8+XG4gICAgICAgICAgICAvLyA8c29tZS1pbnRlcnZlbmluZy1ub2RlIC8+XG4gICAgICAgICAgICAvLyA8b2xkLWVuZC1ub2RlIC8+XG4gICAgICAgICAgICAvLyA8IS0tIC0+ICAgICAgICAgICAgICA8LS0gYG9sZFN0YXJ0Vm5vZGUuJGVsbSRgIHNob3VsZCBiZSBpbnNlcnRlZCBoZXJlXG4gICAgICAgICAgICAvLyA8bmV4dC1zaWJsaW5nIC8+XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSWYgaW5zdGVhZCBgb2xkRW5kVm5vZGUuJGVsbSRgIGhhcyBubyBzaWJsaW5nIHRoZW4gd2UganVzdCB3YW50IHRvIHB1dFxuICAgICAgICAgICAgLy8gdGhlIG5vZGUgZm9yIGBvbGRTdGFydFZub2RlYCBhdCB0aGUgZW5kIG9mIHRoZSBjaGlsZHJlbiBvZlxuICAgICAgICAgICAgLy8gYHBhcmVudEVsbWAuIEx1Y2tpbHksIGBOb2RlLm5leHRTaWJsaW5nYCB3aWxsIHJldHVybiBgbnVsbGAgaWYgdGhlcmVcbiAgICAgICAgICAgIC8vIGFyZW4ndCBhbnkgc2libGluZ3MsIGFuZCBwYXNzaW5nIGBudWxsYCB0byBgTm9kZS5pbnNlcnRCZWZvcmVgIHdpbGxcbiAgICAgICAgICAgIC8vIGFwcGVuZCBpdCB0byB0aGUgY2hpbGRyZW4gb2YgdGhlIHBhcmVudCBlbGVtZW50LlxuICAgICAgICAgICAgcGFyZW50RWxtLmluc2VydEJlZm9yZShvbGRTdGFydFZub2RlLiRlbG0kLCBvbGRFbmRWbm9kZS4kZWxtJC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGNhc2U6IFwiVm5vZGUgbW92ZWQgbGVmdFwiXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gV2UndmUgZm91bmQgdGhhdCB0aGUgZmlyc3Qgbm9kZSBpbiBvdXIgd2luZG93IG9uIHRoZSBuZXcgY2hpbGRyZW4gaXNcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIFZOb2RlIGFzIHRoZSBfbGFzdF8gbm9kZSBpbiBvdXIgd2luZG93IG9uIHRoZSBvbGQgY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBWaXN1YWxseSwgdGhpcyBpcyB0aGUgbGF5b3V0IG9mIHRoZXNlIHR3byBub2RlczpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBuZXdDaDogWy4uLiwgbmV3U3RhcnRWbm9kZSAsIC4uLiAsIG5ld0VuZFZub2RlICwgLi4uXVxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIF5eXl5eXl5eXl5eXl5cbiAgICAgICAgICAgIC8vIG9sZENoOiBbLi4uLCBvbGRTdGFydFZub2RlICwgLi4uICwgb2xkRW5kVm5vZGUgLCAuLi5dXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5eXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSW4gdGhpcyBzaXR1YXRpb24gd2UgbmVlZCB0byBwYXRjaCBgbmV3U3RhcnRWbm9kZWAgb250byBgb2xkRW5kVm5vZGVgXG4gICAgICAgICAgICAvLyAod2hpY2ggd2lsbCBoYW5kbGUgdXBkYXRpbmcgYW55IGNoYW5nZWQgYXR0cmlidXRlcywgcmVjb25jaWxpbmcgdGhlaXJcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuIGV0YykgYnV0IHdlIGFsc28gbmVlZCB0byBtb3ZlIHRoZSBET00gbm9kZSB0byB3aGljaFxuICAgICAgICAgICAgLy8gYG9sZEVuZFZub2RlYCBjb3JyZXNwb25kcy5cbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAob2xkU3RhcnRWbm9kZS4kdGFnJCA9PT0gJ3Nsb3QnIHx8IG5ld0VuZFZub2RlLiR0YWckID09PSAnc2xvdCcpKSB7XG4gICAgICAgICAgICAgICAgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihvbGRFbmRWbm9kZS4kZWxtJC5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaChvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSk7XG4gICAgICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IGNoZWNrZWQgYWJvdmUgaWYgYG9sZFN0YXJ0Vm5vZGVgIGFuZCBgbmV3U3RhcnRWbm9kZWAgYXJlXG4gICAgICAgICAgICAvLyB0aGUgc2FtZSBub2RlLCBzbyBzaW5jZSB3ZSdyZSBoZXJlIHdlIGtub3cgdGhhdCB0aGV5IGFyZSBub3QuIFRodXMgd2VcbiAgICAgICAgICAgIC8vIGNhbiBtb3ZlIHRoZSBlbGVtZW50IGZvciBgb2xkRW5kVm5vZGVgIF9iZWZvcmVfIHRoZSBlbGVtZW50IGZvclxuICAgICAgICAgICAgLy8gYG9sZFN0YXJ0Vm5vZGVgLCBsZWF2aW5nIGBvbGRTdGFydFZub2RlYCB0byBiZSByZWNvbmNpbGVkIGluIHRoZVxuICAgICAgICAgICAgLy8gZnV0dXJlLlxuICAgICAgICAgICAgcGFyZW50RWxtLmluc2VydEJlZm9yZShvbGRFbmRWbm9kZS4kZWxtJCwgb2xkU3RhcnRWbm9kZS4kZWxtJCk7XG4gICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhlcmUgd2UgZG8gc29tZSBjaGVja3MgdG8gbWF0Y2ggdXAgb2xkIGFuZCBuZXcgbm9kZXMgYmFzZWQgb24gdGhlXG4gICAgICAgICAgICAvLyBgJGtleSRgIGF0dHJpYnV0ZSwgd2hpY2ggaXMgc2V0IGJ5IHB1dHRpbmcgYSBga2V5PVwibXkta2V5XCJgIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy8gaW4gdGhlIEpTWCBmb3IgYSBET00gZWxlbWVudCBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgYSBTdGVuY2lsXG4gICAgICAgICAgICAvLyBjb21wb25lbnQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRmlyc3Qgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgbm9kZXMgaW4gdGhlIGFycmF5IG9mIG9sZFxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gd2hpY2ggaGF2ZSB0aGUgc2FtZSBrZXkgYXMgdGhlIGZpcnN0IG5vZGUgaW4gdGhlIG5ld1xuICAgICAgICAgICAgLy8gY2hpbGRyZW4uXG4gICAgICAgICAgICBpZHhJbk9sZCA9IC0xO1xuICAgICAgICAgICAgaWYgKEJVSUxELnZkb21LZXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBvbGRTdGFydElkeDsgaSA8PSBvbGRFbmRJZHg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkQ2hbaV0gJiYgb2xkQ2hbaV0uJGtleSQgIT09IG51bGwgJiYgb2xkQ2hbaV0uJGtleSQgPT09IG5ld1N0YXJ0Vm5vZGUuJGtleSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeEluT2xkID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELnZkb21LZXkgJiYgaWR4SW5PbGQgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbm9kZSBpbiB0aGUgb2xkIGNoaWxkcmVuIHdoaWNoIG1hdGNoZXMgdXAgd2l0aCB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAvLyBub2RlIGluIHRoZSBuZXcgY2hpbGRyZW4hIFNvIGxldCdzIGRlYWwgd2l0aCB0aGF0XG4gICAgICAgICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgICAgICAgIGlmIChlbG1Ub01vdmUuJHRhZyQgIT09IG5ld1N0YXJ0Vm5vZGUuJHRhZyQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHRhZyBkb2Vzbid0IG1hdGNoIHNvIHdlJ2xsIG5lZWQgYSBuZXcgRE9NIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZUVsbShvbGRDaCAmJiBvbGRDaFtuZXdTdGFydElkeF0sIG5ld1ZOb2RlLCBpZHhJbk9sZCwgcGFyZW50RWxtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludmFsaWRhdGUgdGhlIG1hdGNoaW5nIG9sZCBub2RlIHNvIHRoYXQgd2Ugd29uJ3QgdHJ5IHRvIHVwZGF0ZSBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBhZ2FpbiBsYXRlciBvblxuICAgICAgICAgICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbG1Ub01vdmUuJGVsbSQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGVpdGhlciBkaWRuJ3QgZmluZCBhbiBlbGVtZW50IGluIHRoZSBvbGQgY2hpbGRyZW4gdGhhdCBtYXRjaGVzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGtleSBvZiB0aGUgZmlyc3QgbmV3IGNoaWxkIE9SIHRoZSBidWlsZCBpcyBub3QgdXNpbmcgYGtleWBcbiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGVzIGF0IGFsbC4gSW4gZWl0aGVyIGNhc2Ugd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgbmV3IG5vZGUuXG4gICAgICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZUVsbShvbGRDaCAmJiBvbGRDaFtuZXdTdGFydElkeF0sIG5ld1ZOb2RlLCBuZXdTdGFydElkeCwgcGFyZW50RWxtKTtcbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNyZWF0ZWQgYSBuZXcgbm9kZSB0aGVuIGhhbmRsZSBpbnNlcnRpbmcgaXQgdG8gdGhlIERPTVxuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZWZlcmVuY2VOb2RlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQpLmluc2VydEJlZm9yZShub2RlLCByZWZlcmVuY2VOb2RlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUuJGVsbSQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgb2xkU3RhcnRWbm9kZS4kZWxtJCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICAvLyB3ZSBoYXZlIHNvbWUgbW9yZSBuZXcgbm9kZXMgdG8gYWRkIHdoaWNoIGRvbid0IG1hdGNoIHVwIHdpdGggb2xkIG5vZGVzXG4gICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIG5ld0NoW25ld0VuZElkeCArIDFdID09IG51bGwgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uJGVsbSQsIG5ld1ZOb2RlLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnVwZGF0YWJsZSAmJiBuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgICAvLyB0aGVyZSBhcmUgbm9kZXMgaW4gdGhlIGBvbGRDaGAgYXJyYXkgd2hpY2ggbm8gbG9uZ2VyIGNvcnJlc3BvbmQgdG8gbm9kZXNcbiAgICAgICAgLy8gaW4gdGhlIG5ldyBhcnJheSwgc28gbGV0cyByZW1vdmUgdGhlbSAod2hpY2ggZW50YWlscyBjbGVhbmluZyB1cCB0aGVcbiAgICAgICAgLy8gcmVsZXZhbnQgRE9NIG5vZGVzKVxuICAgICAgICByZW1vdmVWbm9kZXMob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbn07XG4vKipcbiAqIENvbXBhcmUgdHdvIFZOb2RlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgdGhlIHNhbWVcbiAqXG4gKiAqKk5CKio6IFRoaXMgZnVuY3Rpb24gaXMgYW4gZXF1YWxpdHkgX2hldXJpc3RpY18gYmFzZWQgb24gdGhlIGF2YWlsYWJsZVxuICogaW5mb3JtYXRpb24gc2V0IG9uIHRoZSB0d28gVk5vZGVzIGFuZCBjYW4gYmUgbWlzbGVhZGluZyB1bmRlciBjZXJ0YWluXG4gKiBjaXJjdW1zdGFuY2VzLiBJbiBwYXJ0aWN1bGFyLCBpZiB0aGUgdHdvIG5vZGVzIGRvIG5vdCBoYXZlIGBrZXlgIGF0dHJzXG4gKiAoYXZhaWxhYmxlIHVuZGVyIGAka2V5JGAgb24gVk5vZGVzKSB0aGVuIHRoZSBmdW5jdGlvbiBmYWxscyBiYWNrIG9uIG1lcmVseVxuICogY2hlY2tpbmcgdGhhdCB0aGV5IGhhdmUgdGhlIHNhbWUgdGFnLlxuICpcbiAqIFNvLCBpbiBvdGhlciB3b3JkcywgaWYgYGtleWAgYXR0cnMgYXJlIG5vdCBzZXQgb24gVk5vZGVzIHdoaWNoIG1heSBiZVxuICogY2hhbmdpbmcgb3JkZXIgd2l0aGluIGEgYGNoaWxkcmVuYCBhcnJheSBvciBzb21ldGhpbmcgYWxvbmcgdGhvc2UgbGluZXMgdGhlblxuICogd2UgY291bGQgb2J0YWluIGEgZmFsc2UgbmVnYXRpdmUgYW5kIHRoZW4gaGF2ZSB0byBkbyBuZWVkbGVzcyByZS1yZW5kZXJpbmdcbiAqIChpLmUuIHdlJ2Qgc2F5IHR3byBWTm9kZXMgYXJlbid0IGVxdWFsIHdoZW4gaW4gZmFjdCB0aGV5IHNob3VsZCBiZSkuXG4gKlxuICogQHBhcmFtIGxlZnRWTm9kZSB0aGUgZmlyc3QgVk5vZGUgdG8gY2hlY2tcbiAqIEBwYXJhbSByaWdodFZOb2RlIHRoZSBzZWNvbmQgVk5vZGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhleSdyZSBlcXVhbCBvciBub3RcbiAqL1xuY29uc3QgaXNTYW1lVm5vZGUgPSAobGVmdFZOb2RlLCByaWdodFZOb2RlKSA9PiB7XG4gICAgLy8gY29tcGFyZSBpZiB0d28gdm5vZGUgdG8gc2VlIGlmIHRoZXkncmUgXCJ0ZWNobmljYWxseVwiIHRoZSBzYW1lXG4gICAgLy8gbmVlZCB0byBoYXZlIHRoZSBzYW1lIGVsZW1lbnQgdGFnLCBhbmQgc2FtZSBrZXkgdG8gYmUgdGhlIHNhbWVcbiAgICBpZiAobGVmdFZOb2RlLiR0YWckID09PSByaWdodFZOb2RlLiR0YWckKSB7XG4gICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBsZWZ0Vk5vZGUuJHRhZyQgPT09ICdzbG90Jykge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnRWTm9kZS4kbmFtZSQgPT09IHJpZ2h0Vk5vZGUuJG5hbWUkO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgd2lsbCBiZSBzZXQgaWYgY29tcG9uZW50cyBpbiB0aGUgYnVpbGQgaGF2ZSBga2V5YCBhdHRycyBzZXQgb24gdGhlbVxuICAgICAgICBpZiAoQlVJTEQudmRvbUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnRWTm9kZS4ka2V5JCA9PT0gcmlnaHRWTm9kZS4ka2V5JDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IHJlZmVyZW5jZU5vZGUgPSAobm9kZSkgPT4ge1xuICAgIC8vIHRoaXMgbm9kZSB3YXMgcmVsb2NhdGVkIHRvIGEgbmV3IGxvY2F0aW9uIGluIHRoZSBkb21cbiAgICAvLyBiZWNhdXNlIG9mIHNvbWUgb3RoZXIgY29tcG9uZW50J3Mgc2xvdFxuICAgIC8vIGJ1dCB3ZSBzdGlsbCBoYXZlIGFuIGh0bWwgY29tbWVudCBpbiBwbGFjZSBvZiB3aGVyZVxuICAgIC8vIGl0J3Mgb3JpZ2luYWwgbG9jYXRpb24gd2FzIGFjY29yZGluZyB0byBpdCdzIG9yaWdpbmFsIHZkb21cbiAgICByZXR1cm4gKG5vZGUgJiYgbm9kZVsncy1vbCddKSB8fCBub2RlO1xufTtcbmNvbnN0IHBhcmVudFJlZmVyZW5jZU5vZGUgPSAobm9kZSkgPT4gKG5vZGVbJ3Mtb2wnXSA/IG5vZGVbJ3Mtb2wnXSA6IG5vZGUpLnBhcmVudE5vZGU7XG4vKipcbiAqIEhhbmRsZSByZWNvbmNpbGluZyBhbiBvdXRkYXRlZCBWTm9kZSB3aXRoIGEgbmV3IG9uZSB3aGljaCBjb3JyZXNwb25kcyB0b1xuICogaXQuIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyBmbHVzaGluZyB1cGRhdGVzIHRvIHRoZSBET00gYW5kIHJlY29uY2lsaW5nIHRoZVxuICogY2hpbGRyZW4gb2YgdGhlIHR3byBub2RlcyAoaWYgYW55KS5cbiAqXG4gKiBAcGFyYW0gb2xkVk5vZGUgYW4gb2xkIFZOb2RlIHdob3NlIERPTSBlbGVtZW50IGFuZCBjaGlsZHJlbiB3ZSB3YW50IHRvIHVwZGF0ZVxuICogQHBhcmFtIG5ld1ZOb2RlIGEgbmV3IFZOb2RlIHJlcHJlc2VudGluZyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIG9sZCBvbmVcbiAqL1xuY29uc3QgcGF0Y2ggPSAob2xkVk5vZGUsIG5ld1ZOb2RlKSA9PiB7XG4gICAgY29uc3QgZWxtID0gKG5ld1ZOb2RlLiRlbG0kID0gb2xkVk5vZGUuJGVsbSQpO1xuICAgIGNvbnN0IG9sZENoaWxkcmVuID0gb2xkVk5vZGUuJGNoaWxkcmVuJDtcbiAgICBjb25zdCBuZXdDaGlsZHJlbiA9IG5ld1ZOb2RlLiRjaGlsZHJlbiQ7XG4gICAgY29uc3QgdGFnID0gbmV3Vk5vZGUuJHRhZyQ7XG4gICAgY29uc3QgdGV4dCA9IG5ld1ZOb2RlLiR0ZXh0JDtcbiAgICBsZXQgZGVmYXVsdEhvbGRlcjtcbiAgICBpZiAoIUJVSUxELnZkb21UZXh0IHx8IHRleHQgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKEJVSUxELnN2Zykge1xuICAgICAgICAgICAgLy8gdGVzdCBpZiB3ZSdyZSByZW5kZXJpbmcgYW4gc3ZnIGVsZW1lbnQsIG9yIHN0aWxsIHJlbmRlcmluZyBub2RlcyBpbnNpZGUgb2Ygb25lXG4gICAgICAgICAgICAvLyBvbmx5IGFkZCB0aGlzIHRvIHRoZSB3aGVuIHRoZSBjb21waWxlciBzZWVzIHdlJ3JlIHVzaW5nIGFuIHN2ZyBzb21ld2hlcmVcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IHRhZyA9PT0gJ3N2ZycgPyB0cnVlIDogdGFnID09PSAnZm9yZWlnbk9iamVjdCcgPyBmYWxzZSA6IGlzU3ZnTW9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudmRvbUF0dHJpYnV0ZSB8fCBCVUlMRC5yZWZsZWN0KSB7XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdCAmJiB0YWcgPT09ICdzbG90JylcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgcmVuZGVyIG9mIGFuIGVsZW1lbnQgT1IgaXQncyBhbiB1cGRhdGVcbiAgICAgICAgICAgICAgICAvLyBBTkQgd2UgYWxyZWFkeSBrbm93IGl0J3MgcG9zc2libGUgaXQgY291bGQgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB1cGRhdGVzIHRoZSBlbGVtZW50J3MgY3NzIGNsYXNzZXMsIGF0dHJzLCBwcm9wcywgbGlzdGVuZXJzLCBldGMuXG4gICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudChvbGRWTm9kZSwgbmV3Vk5vZGUsIGlzU3ZnTW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnVwZGF0YWJsZSAmJiBvbGRDaGlsZHJlbiAhPT0gbnVsbCAmJiBuZXdDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbG9va3MgbGlrZSB0aGVyZSdzIGNoaWxkIHZub2RlcyBmb3IgYm90aCB0aGUgb2xkIGFuZCBuZXcgdm5vZGVzXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGNhbGwgYHVwZGF0ZUNoaWxkcmVuYCB0byByZWNvbmNpbGUgdGhlbVxuICAgICAgICAgICAgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaGlsZHJlbiwgbmV3Vk5vZGUsIG5ld0NoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm8gb2xkIGNoaWxkIHZub2RlcywgYnV0IHRoZXJlIGFyZSBuZXcgY2hpbGQgdm5vZGVzIHRvIGFkZFxuICAgICAgICAgICAgaWYgKEJVSUxELnVwZGF0YWJsZSAmJiBCVUlMRC52ZG9tVGV4dCAmJiBvbGRWTm9kZS4kdGV4dCQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2xkIHZub2RlIHdhcyB0ZXh0LCBzbyBiZSBzdXJlIHRvIGNsZWFyIGl0IG91dFxuICAgICAgICAgICAgICAgIGVsbS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIHRoZSBuZXcgdm5vZGUgY2hpbGRyZW5cbiAgICAgICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIG5ld1ZOb2RlLCBuZXdDaGlsZHJlbiwgMCwgbmV3Q2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG9sZENoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBubyBuZXcgY2hpbGQgdm5vZGVzLCBidXQgdGhlcmUgYXJlIG9sZCBjaGlsZCB2bm9kZXMgdG8gcmVtb3ZlXG4gICAgICAgICAgICByZW1vdmVWbm9kZXMob2xkQ2hpbGRyZW4sIDAsIG9sZENoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdmcgJiYgaXNTdmdNb2RlICYmIHRhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnZkb21UZXh0ICYmIEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIChkZWZhdWx0SG9sZGVyID0gZWxtWydzLWNyJ10pKSB7XG4gICAgICAgIC8vIHRoaXMgZWxlbWVudCBoYXMgc2xvdHRlZCBjb250ZW50XG4gICAgICAgIGRlZmF1bHRIb2xkZXIucGFyZW50Tm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnZkb21UZXh0ICYmIG9sZFZOb2RlLiR0ZXh0JCAhPT0gdGV4dCkge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHRleHQgY29udGVudCBmb3IgdGhlIHRleHQgb25seSB2bm9kZVxuICAgICAgICAvLyBhbmQgYWxzbyBvbmx5IGlmIHRoZSB0ZXh0IGlzIGRpZmZlcmVudCB0aGFuIGJlZm9yZVxuICAgICAgICBlbG0uZGF0YSA9IHRleHQ7XG4gICAgfVxufTtcbmNvbnN0IHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkgPSAoZWxtKSA9PiB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItY29uc3RcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gZWxtLmNoaWxkTm9kZXM7XG4gICAgbGV0IGNoaWxkTm9kZTtcbiAgICBsZXQgaTtcbiAgICBsZXQgaWxlbjtcbiAgICBsZXQgajtcbiAgICBsZXQgc2xvdE5hbWVBdHRyO1xuICAgIGxldCBub2RlVHlwZTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBOT0RFX1RZUEUuRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVbJ3Mtc3InXSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzbG90IGZhbGxiYWNrIG5vZGVcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHNsb3QgbmFtZSBmb3IgdGhpcyBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICAgICAgICAgICAgc2xvdE5hbWVBdHRyID0gY2hpbGROb2RlWydzLXNuJ107XG4gICAgICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCBhbHdheXMgc2hvdyBhIGZhbGxiYWNrIHNsb3Qgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHRoZW4gaGlkZSBpdCBpZiB0aGVyZSBhcmUgb3RoZXIgc2xvdHMgaW4gdGhlIGxpZ2h0IGRvbVxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaWxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gY2hpbGROb2Rlc1tqXS5ub2RlVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNbal1bJ3MtaG4nXSAhPT0gY2hpbGROb2RlWydzLWhuJ10gfHwgc2xvdE5hbWVBdHRyICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBzaWJsaW5nIG5vZGUgaXMgZnJvbSBhIGRpZmZlcmVudCBjb21wb25lbnQgT1IgaXMgYSBuYW1lZCBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gMSAvKiBOT0RFX1RZUEUuRWxlbWVudE5vZGUgKi8gJiYgc2xvdE5hbWVBdHRyID09PSBjaGlsZE5vZGVzW2pdLmdldEF0dHJpYnV0ZSgnc2xvdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgZGVmYXVsdCBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBlbGVtZW50IG9yIHRleHQgbm9kZSAod2l0aCBjb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGhpZGUgdGhlIGRlZmF1bHQgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgLyogTk9ERV9UWVBFLkVsZW1lbnROb2RlICovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVUeXBlID09PSAzIC8qIE5PREVfVFlQRS5UZXh0Tm9kZSAqLyAmJiBjaGlsZE5vZGVzW2pdLnRleHRDb250ZW50LnRyaW0oKSAhPT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBrZWVwIGRyaWxsaW5nIGRvd25cbiAgICAgICAgICAgIHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkoY2hpbGROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCByZWxvY2F0ZU5vZGVzID0gW107XG5jb25zdCByZWxvY2F0ZVNsb3RDb250ZW50ID0gKGVsbSkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWNvbnN0XG4gICAgbGV0IGNoaWxkTm9kZTtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgaG9zdENvbnRlbnROb2RlcztcbiAgICBsZXQgc2xvdE5hbWVBdHRyO1xuICAgIGxldCByZWxvY2F0ZU5vZGVEYXRhO1xuICAgIGxldCBqO1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gZWxtLmNoaWxkTm9kZXM7XG4gICAgY29uc3QgaWxlbiA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGVbJ3Mtc3InXSAmJiAobm9kZSA9IGNoaWxkTm9kZVsncy1jciddKSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IGdvdCB0aGUgY29udGVudCByZWZlcmVuY2UgY29tbWVudCBub2RlXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGdvdCBpdCdzIHBhcmVudCwgd2hpY2ggaXMgd2hlcmUgYWxsIHRoZSBob3N0IGNvbnRlbnQgaXMgaW4gbm93XG4gICAgICAgICAgICBob3N0Q29udGVudE5vZGVzID0gbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBzbG90TmFtZUF0dHIgPSBjaGlsZE5vZGVbJ3Mtc24nXTtcbiAgICAgICAgICAgIGZvciAoaiA9IGhvc3RDb250ZW50Tm9kZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gaG9zdENvbnRlbnROb2Rlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVbJ3MtY24nXSAmJiAhbm9kZVsncy1uciddICYmIG5vZGVbJ3MtaG4nXSAhPT0gY2hpbGROb2RlWydzLWhuJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgZG8gc29tZSByZWxvY2F0aW5nIHRvIGl0cyBuZXcgaG9tZVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgbmV2ZXIgcmVsb2NhdGUgYSBjb250ZW50IHJlZmVyZW5jZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgaXMgc3VwcG9zZSB0byBhbHdheXMgcmVwcmVzZW50IHRoZSBvcmlnaW5hbCBjb250ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGVMb2NhdGVkSW5TbG90KG5vZGUsIHNsb3ROYW1lQXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgd2UndmUgYWxyZWFkeSBkZWNpZGVkIHRvIHJlbG9jYXRlIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YSA9IHJlbG9jYXRlTm9kZXMuZmluZCgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hZGUgc29tZSBjaGFuZ2VzIHRvIHNsb3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBtYWtlIHN1cmUgd2UgYWxzbyBkb3VibGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrcyBhcmUgY29ycmVjdGx5IGhpZGRlbiBvciBzaG93blxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3Mtc24nXSA9IG5vZGVbJ3Mtc24nXSB8fCBzbG90TmFtZUF0dHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsb2NhdGVOb2RlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzbHkgd2UgbmV2ZXIgZm91bmQgYSBzbG90IGhvbWUgZm9yIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0dXJucyBvdXQgd2UgZGlkLCBzbyBsZXQncyByZW1lbWJlciBpdCBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVEYXRhLiRzbG90UmVmTm9kZSQgPSBjaGlsZE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gb3VyIGxpc3Qgb2Ygbm9kZXMgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2xvdFJlZk5vZGUkOiBjaGlsZE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRub2RlVG9SZWxvY2F0ZSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVsncy1zciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2Rlcy5tYXAoKHJlbG9jYXRlTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlTG9jYXRlZEluU2xvdChyZWxvY2F0ZU5vZGUuJG5vZGVUb1JlbG9jYXRlJCwgbm9kZVsncy1zbiddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YSA9IHJlbG9jYXRlTm9kZXMuZmluZCgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxvY2F0ZU5vZGVEYXRhICYmICFyZWxvY2F0ZU5vZGUuJHNsb3RSZWZOb2RlJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZS4kc2xvdFJlZk5vZGUkID0gcmVsb2NhdGVOb2RlRGF0YS4kc2xvdFJlZk5vZGUkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXJlbG9jYXRlTm9kZXMuc29tZSgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gZmFyIHRoaXMgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGEgc2xvdCBob21lLCBub3Qgc2V0dGluZyBzbG90UmVmTm9kZSBvbiBwdXJwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBuZXZlciBmaW5kIGEgaG9tZSBmb3IgdGhpcyBlbGVtZW50IHRoZW4gd2UnbGwgbmVlZCB0byBoaWRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRub2RlVG9SZWxvY2F0ZSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxIC8qIE5PREVfVFlQRS5FbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgcmVsb2NhdGVTbG90Q29udGVudChjaGlsZE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGlzTm9kZUxvY2F0ZWRJblNsb3QgPSAobm9kZVRvUmVsb2NhdGUsIHNsb3ROYW1lQXR0cikgPT4ge1xuICAgIGlmIChub2RlVG9SZWxvY2F0ZS5ub2RlVHlwZSA9PT0gMSAvKiBOT0RFX1RZUEUuRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlLmdldEF0dHJpYnV0ZSgnc2xvdCcpID09PSBudWxsICYmIHNsb3ROYW1lQXR0ciA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSA9PT0gc2xvdE5hbWVBdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlVG9SZWxvY2F0ZVsncy1zbiddID09PSBzbG90TmFtZUF0dHIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90TmFtZUF0dHIgPT09ICcnO1xufTtcbmNvbnN0IGNhbGxOb2RlUmVmcyA9ICh2Tm9kZSkgPT4ge1xuICAgIGlmIChCVUlMRC52ZG9tUmVmKSB7XG4gICAgICAgIHZOb2RlLiRhdHRycyQgJiYgdk5vZGUuJGF0dHJzJC5yZWYgJiYgdk5vZGUuJGF0dHJzJC5yZWYobnVsbCk7XG4gICAgICAgIHZOb2RlLiRjaGlsZHJlbiQgJiYgdk5vZGUuJGNoaWxkcmVuJC5tYXAoY2FsbE5vZGVSZWZzKTtcbiAgICB9XG59O1xuLyoqXG4gKiBUaGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgU3RlbmNpbCdzIHZpcnR1YWwgRE9NLWJhc2VkIHJlbmRlcmluZyBlbmdpbmVcbiAqXG4gKiBHaXZlbiBhIHtAbGluayBkLkhvc3RSZWZ9IGNvbnRhaW5lciBhbmQgc29tZSB2aXJ0dWFsIERPTSBub2RlcywgdGhpc1xuICogZnVuY3Rpb24gd2lsbCBoYW5kbGUgY3JlYXRpbmcgYSB2aXJ0dWFsIERPTSB0cmVlIHdpdGggYSBzaW5nbGUgcm9vdCwgcGF0Y2hpbmdcbiAqIHRoZSBjdXJyZW50IHZpcnR1YWwgRE9NIHRyZWUgb250byBhbiBvbGQgb25lIChpZiBhbnkpLCBkZWFsaW5nIHdpdGggc2xvdFxuICogcmVsb2NhdGlvbiwgYW5kIHJlZmxlY3RpbmcgYXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0gaG9zdFJlZiBkYXRhIG5lZWRlZCB0byByb290IGFuZCByZW5kZXIgdGhlIHZpcnR1YWwgRE9NIHRyZWUsIHN1Y2ggYXNcbiAqIHRoZSBET00gbm9kZSBpbnRvIHdoaWNoIGl0IHNob3VsZCBiZSByZW5kZXJlZC5cbiAqIEBwYXJhbSByZW5kZXJGblJlc3VsdHMgdGhlIHZpcnR1YWwgRE9NIG5vZGVzIHRvIGJlIHJlbmRlcmVkXG4gKi9cbmNvbnN0IHJlbmRlclZkb20gPSAoaG9zdFJlZiwgcmVuZGVyRm5SZXN1bHRzKSA9PiB7XG4gICAgY29uc3QgaG9zdEVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gICAgY29uc3Qgb2xkVk5vZGUgPSBob3N0UmVmLiR2bm9kZSQgfHwgbmV3Vk5vZGUobnVsbCwgbnVsbCk7XG4gICAgY29uc3Qgcm9vdFZub2RlID0gaXNIb3N0KHJlbmRlckZuUmVzdWx0cykgPyByZW5kZXJGblJlc3VsdHMgOiBoKG51bGwsIG51bGwsIHJlbmRlckZuUmVzdWx0cyk7XG4gICAgaG9zdFRhZ05hbWUgPSBob3N0RWxtLnRhZ05hbWU7XG4gICAgLy8gPEhvc3Q+IHJ1bnRpbWUgY2hlY2tcbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgQXJyYXkuaXNBcnJheShyZW5kZXJGblJlc3VsdHMpICYmIHJlbmRlckZuUmVzdWx0cy5zb21lKGlzSG9zdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgPEhvc3Q+IG11c3QgYmUgdGhlIHNpbmdsZSByb290IGNvbXBvbmVudC5cbkxvb2tzIGxpa2UgdGhlIHJlbmRlcigpIGZ1bmN0aW9uIG9mIFwiJHtob3N0VGFnTmFtZS50b0xvd2VyQ2FzZSgpfVwiIGlzIHJldHVybmluZyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSA8SG9zdD4uXG5cblRoZSByZW5kZXIoKSBmdW5jdGlvbiBzaG91bGQgbG9vayBsaWtlIHRoaXMgaW5zdGVhZDpcblxucmVuZGVyKCkge1xuICAvLyBEbyBub3QgcmV0dXJuIGFuIGFycmF5XG4gIHJldHVybiAoXG4gICAgPEhvc3Q+e2NvbnRlbnR9PC9Ib3N0PlxuICApO1xufVxuICBgKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnJlZmxlY3QgJiYgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkKSB7XG4gICAgICAgIHJvb3RWbm9kZS4kYXR0cnMkID0gcm9vdFZub2RlLiRhdHRycyQgfHwge307XG4gICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JC5tYXAoKFtwcm9wTmFtZSwgYXR0cmlidXRlXSkgPT4gKHJvb3RWbm9kZS4kYXR0cnMkW2F0dHJpYnV0ZV0gPSBob3N0RWxtW3Byb3BOYW1lXSkpO1xuICAgIH1cbiAgICByb290Vm5vZGUuJHRhZyQgPSBudWxsO1xuICAgIHJvb3RWbm9kZS4kZmxhZ3MkIHw9IDQgLyogVk5PREVfRkxBR1MuaXNIb3N0ICovO1xuICAgIGhvc3RSZWYuJHZub2RlJCA9IHJvb3RWbm9kZTtcbiAgICByb290Vm5vZGUuJGVsbSQgPSBvbGRWTm9kZS4kZWxtJCA9IChCVUlMRC5zaGFkb3dEb20gPyBob3N0RWxtLnNoYWRvd1Jvb3QgfHwgaG9zdEVsbSA6IGhvc3RFbG0pO1xuICAgIGlmIChCVUlMRC5zY29wZWQgfHwgQlVJTEQuc2hhZG93RG9tKSB7XG4gICAgICAgIHNjb3BlSWQgPSBob3N0RWxtWydzLXNjJ107XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICBjb250ZW50UmVmID0gaG9zdEVsbVsncy1jciddO1xuICAgICAgICB1c2VOYXRpdmVTaGFkb3dEb20gPSBzdXBwb3J0c1NoYWRvdyAmJiAoY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBDTVBfRkxBR1Muc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykgIT09IDA7XG4gICAgICAgIC8vIGFsd2F5cyByZXNldFxuICAgICAgICBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gc3luY2hyb25vdXMgcGF0Y2hcbiAgICBwYXRjaChvbGRWTm9kZSwgcm9vdFZub2RlKTtcbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgLy8gd2hpbGUgd2UncmUgbW92aW5nIG5vZGVzIGFyb3VuZCBleGlzdGluZyBub2RlcywgdGVtcG9yYXJpbHkgZGlzYWJsZVxuICAgICAgICAvLyB0aGUgZGlzY29ubmVjdENhbGxiYWNrIGZyb20gd29ya2luZ1xuICAgICAgICBwbHQuJGZsYWdzJCB8PSAxIC8qIFBMQVRGT1JNX0ZMQUdTLmlzVG1wRGlzY29ubmVjdGVkICovO1xuICAgICAgICBpZiAoY2hlY2tTbG90UmVsb2NhdGUpIHtcbiAgICAgICAgICAgIHJlbG9jYXRlU2xvdENvbnRlbnQocm9vdFZub2RlLiRlbG0kKTtcbiAgICAgICAgICAgIGxldCByZWxvY2F0ZURhdGE7XG4gICAgICAgICAgICBsZXQgbm9kZVRvUmVsb2NhdGU7XG4gICAgICAgICAgICBsZXQgb3JnTG9jYXRpb25Ob2RlO1xuICAgICAgICAgICAgbGV0IHBhcmVudE5vZGVSZWY7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0QmVmb3JlTm9kZTtcbiAgICAgICAgICAgIGxldCByZWZOb2RlO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCByZWxvY2F0ZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVsb2NhdGVEYXRhID0gcmVsb2NhdGVOb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZSA9IHJlbG9jYXRlRGF0YS4kbm9kZVRvUmVsb2NhdGUkO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYSByZWZlcmVuY2Ugbm9kZSBtYXJraW5nIHRoaXMgbm9kZSdzIG9yaWdpbmFsIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhpcyBub2RlIGZvciBsYXRlciBsb29rdXBzXG4gICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBCVUlMRC5pc0RlYnVnIHx8IEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvcmlnaW5hbExvY2F0aW9uRGVidWdOb2RlKG5vZGVUb1JlbG9jYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZG9jLmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlWydzLW5yJ10gPSBub2RlVG9SZWxvY2F0ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoKG5vZGVUb1JlbG9jYXRlWydzLW9sJ10gPSBvcmdMb2NhdGlvbk5vZGUpLCBub2RlVG9SZWxvY2F0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlbG9jYXRlTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZWxvY2F0ZURhdGEgPSByZWxvY2F0ZU5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlID0gcmVsb2NhdGVEYXRhLiRub2RlVG9SZWxvY2F0ZSQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlbG9jYXRlRGF0YS4kc2xvdFJlZk5vZGUkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgd2UncmUganVzdCBnb2luZyB0byBpbnNlcnQgaXQgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIHNsb3QgcmVmZXJlbmNlIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZVJlZiA9IHJlbG9jYXRlRGF0YS4kc2xvdFJlZk5vZGUkLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZU5vZGUgPSByZWxvY2F0ZURhdGEuJHNsb3RSZWZOb2RlJC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlID0gbm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChvcmdMb2NhdGlvbk5vZGUgPSBvcmdMb2NhdGlvbk5vZGUucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmTm9kZSA9IG9yZ0xvY2F0aW9uTm9kZVsncy1uciddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZk5vZGUgJiYgcmVmTm9kZVsncy1zbiddID09PSBub2RlVG9SZWxvY2F0ZVsncy1zbiddICYmIHBhcmVudE5vZGVSZWYgPT09IHJlZk5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZk5vZGUgPSByZWZOb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVmTm9kZSB8fCAhcmVmTm9kZVsncy1uciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZU5vZGUgPSByZWZOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCghaW5zZXJ0QmVmb3JlTm9kZSAmJiBwYXJlbnROb2RlUmVmICE9PSBub2RlVG9SZWxvY2F0ZS5wYXJlbnROb2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUubmV4dFNpYmxpbmcgIT09IGluc2VydEJlZm9yZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIGNoZWNrZWQgdGhhdCBpdCdzIHdvcnRoIHdoaWxlIHRvIHJlbG9jYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGF0IHRoZSBub2RlIHRvIHJlbG9jYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXMgYSBkaWZmZXJlbnQgbmV4dCBzaWJsaW5nIG9yIHBhcmVudCByZWxvY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZSAhPT0gaW5zZXJ0QmVmb3JlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZVRvUmVsb2NhdGVbJ3MtaG4nXSAmJiBub2RlVG9SZWxvY2F0ZVsncy1vbCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2JhYmx5IGEgY29tcG9uZW50IGluIHRoZSBpbmRleC5odG1sIHRoYXQgZG9lc24ndCBoYXZlIGl0J3MgaG9zdG5hbWUgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlWydzLWhuJ10gPSBub2RlVG9SZWxvY2F0ZVsncy1vbCddLnBhcmVudE5vZGUubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpdCBiYWNrIHRvIHRoZSBkb20gYnV0IGluIGl0cyBuZXcgaG9tZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGVSZWYuaW5zZXJ0QmVmb3JlKG5vZGVUb1JlbG9jYXRlLCBpbnNlcnRCZWZvcmVOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBub2RlIGRvZXNuJ3QgaGF2ZSBhIHNsb3QgaG9tZSB0byBnbyB0bywgc28gbGV0J3MgaGlkZSBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVRvUmVsb2NhdGUubm9kZVR5cGUgPT09IDEgLyogTk9ERV9UWVBFLkVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkocm9vdFZub2RlLiRlbG0kKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb25lIG1vdmluZyBub2RlcyBhcm91bmRcbiAgICAgICAgLy8gYWxsb3cgdGhlIGRpc2Nvbm5lY3QgY2FsbGJhY2sgdG8gd29yayBhZ2FpblxuICAgICAgICBwbHQuJGZsYWdzJCAmPSB+MSAvKiBQTEFURk9STV9GTEFHUy5pc1RtcERpc2Nvbm5lY3RlZCAqLztcbiAgICAgICAgLy8gYWx3YXlzIHJlc2V0XG4gICAgICAgIHJlbG9jYXRlTm9kZXMubGVuZ3RoID0gMDtcbiAgICB9XG59O1xuLy8gc2xvdCBjb21tZW50IGRlYnVnIG5vZGVzIG9ubHkgY3JlYXRlZCB3aXRoIHRoZSBgLS1kZWJ1Z2AgZmxhZ1xuLy8gb3RoZXJ3aXNlIHRoZXNlIG5vZGVzIGFyZSB0ZXh0IG5vZGVzIHcvb3V0IGNvbnRlbnRcbmNvbnN0IHNsb3RSZWZlcmVuY2VEZWJ1Z05vZGUgPSAoc2xvdFZOb2RlKSA9PiBkb2MuY3JlYXRlQ29tbWVudChgPHNsb3Qke3Nsb3RWTm9kZS4kbmFtZSQgPyAnIG5hbWU9XCInICsgc2xvdFZOb2RlLiRuYW1lJCArICdcIicgOiAnJ30+IChob3N0PSR7aG9zdFRhZ05hbWUudG9Mb3dlckNhc2UoKX0pYCk7XG5jb25zdCBvcmlnaW5hbExvY2F0aW9uRGVidWdOb2RlID0gKG5vZGVUb1JlbG9jYXRlKSA9PiBkb2MuY3JlYXRlQ29tbWVudChgb3JnLWxvY2F0aW9uIGZvciBgICtcbiAgICAobm9kZVRvUmVsb2NhdGUubG9jYWxOYW1lXG4gICAgICAgID8gYDwke25vZGVUb1JlbG9jYXRlLmxvY2FsTmFtZX0+IChob3N0PSR7bm9kZVRvUmVsb2NhdGVbJ3MtaG4nXX0pYFxuICAgICAgICA6IGBbJHtub2RlVG9SZWxvY2F0ZS50ZXh0Q29udGVudH1dYCkpO1xuY29uc3QgYXR0YWNoVG9BbmNlc3RvciA9IChob3N0UmVmLCBhbmNlc3RvckNvbXBvbmVudCkgPT4ge1xuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgYW5jZXN0b3JDb21wb25lbnQgJiYgIWhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgJiYgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB7XG4gICAgICAgIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXS5wdXNoKG5ldyBQcm9taXNlKChyKSA9PiAoaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCA9IHIpKSk7XG4gICAgfVxufTtcbmNvbnN0IHNjaGVkdWxlVXBkYXRlID0gKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICBpZiAoQlVJTEQudGFza1F1ZXVlICYmIEJVSUxELnVwZGF0YWJsZSkge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTYgLyogSE9TVF9GTEFHUy5pc1F1ZXVlZEZvclVwZGF0ZSAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZyAmJiBob3N0UmVmLiRmbGFncyQgJiA0IC8qIEhPU1RfRkxBR1MuaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8pIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDUxMiAvKiBIT1NUX0ZMQUdTLm5lZWRzUmVyZW5kZXIgKi87XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXR0YWNoVG9BbmNlc3Rvcihob3N0UmVmLCBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQpO1xuICAgIC8vIHRoZXJlIGlzIG5vIGFuY2VzdG9yIGNvbXBvbmVudCBvciB0aGUgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgLy8gaGFzIGFscmVhZHkgZmlyZWQgb2ZmIGl0cyBsaWZlY3ljbGUgdXBkYXRlIHRoZW5cbiAgICAvLyBmaXJlIG9mZiB0aGUgaW5pdGlhbCB1cGRhdGVcbiAgICBjb25zdCBkaXNwYXRjaCA9ICgpID0+IGRpc3BhdGNoSG9va3MoaG9zdFJlZiwgaXNJbml0aWFsTG9hZCk7XG4gICAgcmV0dXJuIEJVSUxELnRhc2tRdWV1ZSA/IHdyaXRlVGFzayhkaXNwYXRjaCkgOiBkaXNwYXRjaCgpO1xufTtcbmNvbnN0IGRpc3BhdGNoSG9va3MgPSAoaG9zdFJlZiwgaXNJbml0aWFsTG9hZCkgPT4ge1xuICAgIGNvbnN0IGVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBlbmRTY2hlZHVsZSA9IGNyZWF0ZVRpbWUoJ3NjaGVkdWxlVXBkYXRlJywgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoaXNJbml0aWFsTG9hZCkge1xuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgJiYgQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMjU2IC8qIEhPU1RfRkxBR1MuaXNMaXN0ZW5SZWFkeSAqLztcbiAgICAgICAgICAgIGlmIChob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJC5tYXAoKFttZXRob2ROYW1lLCBldmVudF0pID0+IHNhZmVDYWxsKGluc3RhbmNlLCBtZXRob2ROYW1lLCBldmVudCkpO1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnRXaWxsTG9hZCcpO1xuICAgICAgICBpZiAoQlVJTEQuY21wV2lsbExvYWQpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudFdpbGxMb2FkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIGlmIChCVUlMRC5jbXBXaWxsVXBkYXRlKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gc2FmZUNhbGwoaW5zdGFuY2UsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudFdpbGxSZW5kZXInKTtcbiAgICBpZiAoQlVJTEQuY21wV2lsbFJlbmRlcikge1xuICAgICAgICBwcm9taXNlID0gdGhlbihwcm9taXNlLCAoKSA9PiBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudFdpbGxSZW5kZXInKSk7XG4gICAgfVxuICAgIGVuZFNjaGVkdWxlKCk7XG4gICAgcmV0dXJuIHRoZW4ocHJvbWlzZSwgKCkgPT4gdXBkYXRlQ29tcG9uZW50KGhvc3RSZWYsIGluc3RhbmNlLCBpc0luaXRpYWxMb2FkKSk7XG59O1xuY29uc3QgdXBkYXRlQ29tcG9uZW50ID0gYXN5bmMgKGhvc3RSZWYsIGluc3RhbmNlLCBpc0luaXRpYWxMb2FkKSA9PiB7XG4gICAgLy8gdXBkYXRlQ29tcG9uZW50XG4gICAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGVuZFVwZGF0ZSA9IGNyZWF0ZVRpbWUoJ3VwZGF0ZScsIGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJCk7XG4gICAgY29uc3QgcmMgPSBlbG1bJ3MtcmMnXTtcbiAgICBpZiAoQlVJTEQuc3R5bGUgJiYgaXNJbml0aWFsTG9hZCkge1xuICAgICAgICAvLyBET00gV1JJVEUhXG4gICAgICAgIGF0dGFjaFN0eWxlcyhob3N0UmVmKTtcbiAgICB9XG4gICAgY29uc3QgZW5kUmVuZGVyID0gY3JlYXRlVGltZSgncmVuZGVyJywgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEwMjQgLyogSE9TVF9GTEFHUy5kZXZPblJlbmRlciAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgIGF3YWl0IGNhbGxSZW5kZXIoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYWxsUmVuZGVyKGhvc3RSZWYsIGluc3RhbmNlLCBlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuY3NzVmFyU2hpbSAmJiBwbHQuJGNzc1NoaW0kKSB7XG4gICAgICAgIHBsdC4kY3NzU2hpbSQudXBkYXRlSG9zdChlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgaG9zdFJlZi4kcmVuZGVyQ291bnQkKys7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MTAyNCAvKiBIT1NUX0ZMQUdTLmRldk9uUmVuZGVyICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIG1hbnVhbGx5IGNvbm5lY3RlZCBjaGlsZCBjb21wb25lbnRzIGR1cmluZyBzZXJ2ZXItc2lkZSBoeWRyYXRlXG4gICAgICAgICAgICBzZXJ2ZXJTaWRlQ29ubmVjdGVkKGVsbSk7XG4gICAgICAgICAgICBpZiAoaXNJbml0aWFsTG9hZCkge1xuICAgICAgICAgICAgICAgIC8vIHVzaW5nIG9ubHkgZHVyaW5nIHNlcnZlci1zaWRlIGh5ZHJhdGVcbiAgICAgICAgICAgICAgICBpZiAoaG9zdFJlZi4kY21wTWV0YSQuJGZsYWdzJCAmIDEgLyogQ01QX0ZMQUdTLnNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtWydzLWVuJ10gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaG9zdFJlZi4kY21wTWV0YSQuJGZsYWdzJCAmIDIgLyogQ01QX0ZMQUdTLnNjb3BlZENzc0VuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtWydzLWVuJ10gPSAnYyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSwgZWxtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIHJjKSB7XG4gICAgICAgIC8vIG9rLCBzbyB0dXJucyBvdXQgdGhlcmUgYXJlIHNvbWUgY2hpbGQgaG9zdCBlbGVtZW50c1xuICAgICAgICAvLyB3YWl0aW5nIG9uIHRoaXMgcGFyZW50IGVsZW1lbnQgdG8gbG9hZFxuICAgICAgICAvLyBsZXQncyBmaXJlIG9mZiBhbGwgdXBkYXRlIGNhbGxiYWNrcyB3YWl0aW5nXG4gICAgICAgIHJjLm1hcCgoY2IpID0+IGNiKCkpO1xuICAgICAgICBlbG1bJ3MtcmMnXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZW5kUmVuZGVyKCk7XG4gICAgZW5kVXBkYXRlKCk7XG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZykge1xuICAgICAgICBjb25zdCBjaGlsZHJlblByb21pc2VzID0gZWxtWydzLXAnXTtcbiAgICAgICAgY29uc3QgcG9zdFVwZGF0ZSA9ICgpID0+IHBvc3RVcGRhdGVDb21wb25lbnQoaG9zdFJlZik7XG4gICAgICAgIGlmIChjaGlsZHJlblByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcG9zdFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoY2hpbGRyZW5Qcm9taXNlcykudGhlbihwb3N0VXBkYXRlKTtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA0IC8qIEhPU1RfRkxBR1MuaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi87XG4gICAgICAgICAgICBjaGlsZHJlblByb21pc2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvc3RVcGRhdGVDb21wb25lbnQoaG9zdFJlZik7XG4gICAgfVxufTtcbmNvbnN0IGNhbGxSZW5kZXIgPSAoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSkgPT4ge1xuICAgIC8vIGluIG9yZGVyIGZvciBidW5kbGVycyB0byBjb3JyZWN0bHkgdHJlZXNoYWtlIHRoZSBCVUlMRCBvYmplY3RcbiAgICAvLyB3ZSBuZWVkIHRvIGVuc3VyZSBCVUlMRCBpcyBub3QgZGVvcHRpbWl6ZWQgd2l0aGluIGEgdHJ5L2NhdGNoXG4gICAgLy8gaHR0cHM6Ly9yb2xsdXBqcy5vcmcvZ3VpZGUvZW4vI3RyZWVzaGFrZSB0cnlDYXRjaERlb3B0aW1pemF0aW9uXG4gICAgY29uc3QgYWxsUmVuZGVyRm4gPSBCVUlMRC5hbGxSZW5kZXJGbiA/IHRydWUgOiBmYWxzZTtcbiAgICBjb25zdCBsYXp5TG9hZCA9IEJVSUxELmxhenlMb2FkID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IHRhc2tRdWV1ZSA9IEJVSUxELnRhc2tRdWV1ZSA/IHRydWUgOiBmYWxzZTtcbiAgICBjb25zdCB1cGRhdGFibGUgPSBCVUlMRC51cGRhdGFibGUgPyB0cnVlIDogZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyaW5nUmVmID0gaW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlID0gYWxsUmVuZGVyRm4gPyBpbnN0YW5jZS5yZW5kZXIoKSA6IGluc3RhbmNlLnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgaWYgKHVwZGF0YWJsZSAmJiB0YXNrUXVldWUpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MTYgLyogSE9TVF9GTEFHUy5pc1F1ZXVlZEZvclVwZGF0ZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRhYmxlIHx8IGxhenlMb2FkKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMiAvKiBIT1NUX0ZMQUdTLmhhc1JlbmRlcmVkICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5oYXNSZW5kZXJGbiB8fCBCVUlMRC5yZWZsZWN0KSB7XG4gICAgICAgICAgICBpZiAoQlVJTEQudmRvbVJlbmRlciB8fCBCVUlMRC5yZWZsZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gbG9va3MgbGlrZSB3ZSd2ZSBnb3QgY2hpbGQgbm9kZXMgdG8gcmVuZGVyIGludG8gdGhpcyBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBvciB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgY3NzIGNsYXNzL2F0dHJzIG9uIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBET00gV1JJVEUhXG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW5zdGFuY2UpLnRoZW4oKHZhbHVlKSA9PiByZW5kZXJWZG9tKGhvc3RSZWYsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJWZG9tKGhvc3RSZWYsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbG0udGV4dENvbnRlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlRXJyb3IoZSwgaG9zdFJlZi4kaG9zdEVsZW1lbnQkKTtcbiAgICB9XG4gICAgcmVuZGVyaW5nUmVmID0gbnVsbDtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBnZXRSZW5kZXJpbmdSZWYgPSAoKSA9PiByZW5kZXJpbmdSZWY7XG5jb25zdCBwb3N0VXBkYXRlQ29tcG9uZW50ID0gKGhvc3RSZWYpID0+IHtcbiAgICBjb25zdCB0YWdOYW1lID0gaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkO1xuICAgIGNvbnN0IGVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBlbmRQb3N0VXBkYXRlID0gY3JlYXRlVGltZSgncG9zdFVwZGF0ZScsIHRhZ05hbWUpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gQlVJTEQubGF6eUxvYWQgPyBob3N0UmVmLiRsYXp5SW5zdGFuY2UkIDogZWxtO1xuICAgIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50ID0gaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkO1xuICAgIGlmIChCVUlMRC5jbXBEaWRSZW5kZXIpIHtcbiAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTAyNCAvKiBIT1NUX0ZMQUdTLmRldk9uUmVuZGVyICovO1xuICAgICAgICB9XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkUmVuZGVyJyk7XG4gICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIEhPU1RfRkxBR1MuZGV2T25SZW5kZXIgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZFJlbmRlcicpO1xuICAgIGlmICghKGhvc3RSZWYuJGZsYWdzJCAmIDY0IC8qIEhPU1RfRkxBR1MuaGFzTG9hZGVkQ29tcG9uZW50ICovKSkge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gNjQgLyogSE9TVF9GTEFHUy5oYXNMb2FkZWRDb21wb25lbnQgKi87XG4gICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgQlVJTEQuY3NzQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgICAgIGFkZEh5ZHJhdGVkRmxhZyhlbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRMb2FkKSB7XG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMjA0OCAvKiBIT1NUX0ZMQUdTLmRldk9uRGlkTG9hZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkTG9hZCcpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4yMDQ4IC8qIEhPU1RfRkxBR1MuZGV2T25EaWRMb2FkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnREaWRMb2FkJyk7XG4gICAgICAgIGVuZFBvc3RVcGRhdGUoKTtcbiAgICAgICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZykge1xuICAgICAgICAgICAgaG9zdFJlZi4kb25SZWFkeVJlc29sdmUkKGVsbSk7XG4gICAgICAgICAgICBpZiAoIWFuY2VzdG9yQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgYXBwRGlkTG9hZCh0YWdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKEJVSUxELmNtcERpZFVwZGF0ZSkge1xuICAgICAgICAgICAgLy8gd2UndmUgYWxyZWFkeSBsb2FkZWQgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgIC8vIGZpcmUgb2ZmIHRoZSB1c2VyJ3MgY29tcG9uZW50RGlkVXBkYXRlIG1ldGhvZCAoaWYgb25lIHdhcyBwcm92aWRlZClcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudERpZFVwZGF0ZSBydW5zIEFGVEVSIHJlbmRlcigpIGhhcyBiZWVuIGNhbGxlZFxuICAgICAgICAgICAgLy8gYW5kIGFsbCBjaGlsZCBjb21wb25lbnRzIGhhdmUgZmluaXNoZWQgdXBkYXRpbmdcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxMDI0IC8qIEhPU1RfRkxBR1MuZGV2T25SZW5kZXIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIEhPU1RfRkxBR1MuZGV2T25SZW5kZXIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICBlbmRQb3N0VXBkYXRlKCk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICBlbG1bJ3MtaG1yLWxvYWQnXSAmJiBlbG1bJ3MtaG1yLWxvYWQnXSgpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQubWV0aG9kICYmIEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uSW5zdGFuY2VSZXNvbHZlJChlbG0pO1xuICAgIH1cbiAgICAvLyBsb2FkIGV2ZW50cyBmaXJlIGZyb20gYm90dG9tIHRvIHRvcFxuICAgIC8vIHRoZSBkZWVwZXN0IGVsZW1lbnRzIGxvYWQgZmlyc3QgdGhlbiBidWJibGVzIHVwXG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZykge1xuICAgICAgICBpZiAoaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCkge1xuICAgICAgICAgICAgaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCgpO1xuICAgICAgICAgICAgaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgNTEyIC8qIEhPU1RfRkxBR1MubmVlZHNSZXJlbmRlciAqLykge1xuICAgICAgICAgICAgbmV4dFRpY2soKCkgPT4gc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBob3N0UmVmLiRmbGFncyQgJj0gfig0IC8qIEhPU1RfRkxBR1MuaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8gfCA1MTIgLyogSE9TVF9GTEFHUy5uZWVkc1JlcmVuZGVyICovKTtcbiAgICB9XG4gICAgLy8gKCDigKJf4oCiKVxuICAgIC8vICgg4oCiX+KAoik+4oyQ4pagLeKWoFxuICAgIC8vICjijJDilqBf4pagKVxufTtcbmNvbnN0IGZvcmNlVXBkYXRlID0gKHJlZikgPT4ge1xuICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSBob3N0UmVmLiRob3N0RWxlbWVudCQuaXNDb25uZWN0ZWQ7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RlZCAmJlxuICAgICAgICAgICAgKGhvc3RSZWYuJGZsYWdzJCAmICgyIC8qIEhPU1RfRkxBR1MuaGFzUmVuZGVyZWQgKi8gfCAxNiAvKiBIT1NUX0ZMQUdTLmlzUXVldWVkRm9yVXBkYXRlICovKSkgPT09IDIgLyogSE9TVF9GTEFHUy5oYXNSZW5kZXJlZCAqLykge1xuICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybnMgXCJ0cnVlXCIgd2hlbiB0aGUgZm9yY2VkIHVwZGF0ZSB3YXMgc3VjY2Vzc2Z1bGx5IHNjaGVkdWxlZFxuICAgICAgICByZXR1cm4gaXNDb25uZWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBhcHBEaWRMb2FkID0gKHdobykgPT4ge1xuICAgIC8vIG9uIGFwcGxvYWRcbiAgICAvLyB3ZSBoYXZlIGZpbmlzaCB0aGUgZmlyc3QgYmlnIGluaXRpYWwgcmVuZGVyXG4gICAgaWYgKEJVSUxELmNzc0Fubm90YXRpb25zKSB7XG4gICAgICAgIGFkZEh5ZHJhdGVkRmxhZyhkb2MuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgcGx0LiRmbGFncyQgfD0gMiAvKiBQTEFURk9STV9GTEFHUy5hcHBMb2FkZWQgKi87XG4gICAgfVxuICAgIG5leHRUaWNrKCgpID0+IGVtaXRFdmVudCh3aW4sICdhcHBsb2FkJywgeyBkZXRhaWw6IHsgbmFtZXNwYWNlOiBOQU1FU1BBQ0UgfSB9KSk7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWVhc3VyZSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKGBbU3RlbmNpbF0gJHtOQU1FU1BBQ0V9IGluaXRpYWwgbG9hZCAoYnkgJHt3aG99KWAsICdzdDphcHA6c3RhcnQnKTtcbiAgICB9XG59O1xuY29uc3Qgc2FmZUNhbGwgPSAoaW5zdGFuY2UsIG1ldGhvZCwgYXJnKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlW21ldGhvZF0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVttZXRob2RdKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmNvbnN0IHRoZW4gPSAocHJvbWlzZSwgdGhlbkZuKSA9PiB7XG4gICAgcmV0dXJuIHByb21pc2UgJiYgcHJvbWlzZS50aGVuID8gcHJvbWlzZS50aGVuKHRoZW5GbikgOiB0aGVuRm4oKTtcbn07XG5jb25zdCBlbWl0TGlmZWN5Y2xlRXZlbnQgPSAoZWxtLCBsaWZlY3ljbGVOYW1lKSA9PiB7XG4gICAgaWYgKEJVSUxELmxpZmVjeWNsZURPTUV2ZW50cykge1xuICAgICAgICBlbWl0RXZlbnQoZWxtLCAnc3RlbmNpbF8nICsgbGlmZWN5Y2xlTmFtZSwge1xuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBOQU1FU1BBQ0UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgYWRkSHlkcmF0ZWRGbGFnID0gKGVsbSkgPT4gQlVJTEQuaHlkcmF0ZWRDbGFzc1xuICAgID8gZWxtLmNsYXNzTGlzdC5hZGQoJ2h5ZHJhdGVkJylcbiAgICA6IEJVSUxELmh5ZHJhdGVkQXR0cmlidXRlXG4gICAgICAgID8gZWxtLnNldEF0dHJpYnV0ZSgnaHlkcmF0ZWQnLCAnJylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5jb25zdCBzZXJ2ZXJTaWRlQ29ubmVjdGVkID0gKGVsbSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZWxtLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkRWxtID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkRWxtLmNvbm5lY3RlZENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRFbG0uY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcnZlclNpZGVDb25uZWN0ZWQoY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGdldFZhbHVlID0gKHJlZiwgcHJvcE5hbWUpID0+IGdldEhvc3RSZWYocmVmKS4kaW5zdGFuY2VWYWx1ZXMkLmdldChwcm9wTmFtZSk7XG5jb25zdCBzZXRWYWx1ZSA9IChyZWYsIHByb3BOYW1lLCBuZXdWYWwsIGNtcE1ldGEpID0+IHtcbiAgICAvLyBjaGVjayBvdXIgbmV3IHByb3BlcnR5IHZhbHVlIGFnYWluc3Qgb3VyIGludGVybmFsIHZhbHVlXG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICBjb25zdCBlbG0gPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGhvc3RFbGVtZW50JCA6IHJlZjtcbiAgICBjb25zdCBvbGRWYWwgPSBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQuZ2V0KHByb3BOYW1lKTtcbiAgICBjb25zdCBmbGFncyA9IGhvc3RSZWYuJGZsYWdzJDtcbiAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICBuZXdWYWwgPSBwYXJzZVByb3BlcnR5VmFsdWUobmV3VmFsLCBjbXBNZXRhLiRtZW1iZXJzJFtwcm9wTmFtZV1bMF0pO1xuICAgIC8vIGV4cGxpY2l0bHkgY2hlY2sgZm9yIE5hTiBvbiBib3RoIHNpZGVzLCBhcyBgTmFOID09PSBOYU5gIGlzIGFsd2F5cyBmYWxzZVxuICAgIGNvbnN0IGFyZUJvdGhOYU4gPSBOdW1iZXIuaXNOYU4ob2xkVmFsKSAmJiBOdW1iZXIuaXNOYU4obmV3VmFsKTtcbiAgICBjb25zdCBkaWRWYWx1ZUNoYW5nZSA9IG5ld1ZhbCAhPT0gb2xkVmFsICYmICFhcmVCb3RoTmFOO1xuICAgIGlmICgoIUJVSUxELmxhenlMb2FkIHx8ICEoZmxhZ3MgJiA4IC8qIEhPU1RfRkxBR1MuaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLykgfHwgb2xkVmFsID09PSB1bmRlZmluZWQpICYmIGRpZFZhbHVlQ2hhbmdlKSB7XG4gICAgICAgIC8vIGdhZHpvb2tzISB0aGUgcHJvcGVydHkncyB2YWx1ZSBoYXMgY2hhbmdlZCEhXG4gICAgICAgIC8vIHNldCBvdXIgbmV3IHZhbHVlIVxuICAgICAgICBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQuc2V0KHByb3BOYW1lLCBuZXdWYWwpO1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgIGlmIChob3N0UmVmLiRmbGFncyQgJiAxMDI0IC8qIEhPU1RfRkxBR1MuZGV2T25SZW5kZXIgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlRGV2V2FybihgVGhlIHN0YXRlL3Byb3AgXCIke3Byb3BOYW1lfVwiIGNoYW5nZWQgZHVyaW5nIHJlbmRlcmluZy4gVGhpcyBjYW4gcG90ZW50aWFsbHkgbGVhZCB0byBpbmZpbml0ZS1sb29wcyBhbmQgb3RoZXIgYnVncy5gLCAnXFxuRWxlbWVudCcsIGVsbSwgJ1xcbk5ldyB2YWx1ZScsIG5ld1ZhbCwgJ1xcbk9sZCB2YWx1ZScsIG9sZFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChob3N0UmVmLiRmbGFncyQgJiAyMDQ4IC8qIEhPU1RfRkxBR1MuZGV2T25EaWRMb2FkICovKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBzdGF0ZS9wcm9wIFwiJHtwcm9wTmFtZX1cIiBjaGFuZ2VkIGR1cmluZyBcImNvbXBvbmVudERpZExvYWQoKVwiLCB0aGlzIHRyaWdnZXJzIGV4dHJhIHJlLXJlbmRlcnMsIHRyeSB0byBzZXR1cCBvbiBcImNvbXBvbmVudFdpbGxMb2FkKClcImAsICdcXG5FbGVtZW50JywgZWxtLCAnXFxuTmV3IHZhbHVlJywgbmV3VmFsLCAnXFxuT2xkIHZhbHVlJywgb2xkVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIUJVSUxELmxhenlMb2FkIHx8IGluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBnZXQgYW4gYXJyYXkgb2YgbWV0aG9kIG5hbWVzIG9mIHdhdGNoIGZ1bmN0aW9ucyB0byBjYWxsXG4gICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjayAmJiBjbXBNZXRhLiR3YXRjaGVycyQgJiYgZmxhZ3MgJiAxMjggLyogSE9TVF9GTEFHUy5pc1dhdGNoUmVhZHkgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaE1ldGhvZHMgPSBjbXBNZXRhLiR3YXRjaGVycyRbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh3YXRjaE1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpbnN0YW5jZSBpcyB3YXRjaGluZyBmb3Igd2hlbiB0aGlzIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hNZXRob2RzLm1hcCgod2F0Y2hNZXRob2ROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgb2ZmIGVhY2ggb2YgdGhlIHdhdGNoIG1ldGhvZHMgdGhhdCBhcmUgd2F0Y2hpbmcgdGhpcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW3dhdGNoTWV0aG9kTmFtZV0obmV3VmFsLCBvbGRWYWwsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZUVycm9yKGUsIGVsbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUgJiZcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiAoMiAvKiBIT1NUX0ZMQUdTLmhhc1JlbmRlcmVkICovIHwgMTYgLyogSE9TVF9GTEFHUy5pc1F1ZXVlZEZvclVwZGF0ZSAqLykpID09PSAyIC8qIEhPU1RfRkxBR1MuaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuY21wU2hvdWxkVXBkYXRlICYmIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlKG5ld1ZhbCwgb2xkVmFsLCBwcm9wTmFtZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbG9va3MgbGlrZSB0aGlzIHZhbHVlIGFjdHVhbGx5IGNoYW5nZWQsIHNvIHdlJ3ZlIGdvdCB3b3JrIHRvIGRvIVxuICAgICAgICAgICAgICAgIC8vIGJ1dCBvbmx5IGlmIHdlJ3ZlIGFscmVhZHkgcmVuZGVyZWQsIG90aGVyd2lzZSBqdXN0IGNoaWxsIG91dFxuICAgICAgICAgICAgICAgIC8vIHF1ZXVlIHRoYXQgd2UgbmVlZCB0byBkbyBhbiB1cGRhdGUsIGJ1dCBkb24ndCB3b3JyeSBhYm91dCBxdWV1aW5nXG4gICAgICAgICAgICAgICAgLy8gdXAgbWlsbGlvbnMgY3V6IHRoaXMgZnVuY3Rpb24gZW5zdXJlcyBpdCBvbmx5IHJ1bnMgb25jZVxuICAgICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIEF0dGFjaCBhIHNlcmllcyBvZiBydW50aW1lIGNvbnN0cnVjdHMgdG8gYSBjb21waWxlZCBTdGVuY2lsIGNvbXBvbmVudFxuICogY29uc3RydWN0b3IsIGluY2x1ZGluZyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGZvciB0aGUgYEBQcm9wYCBhbmQgYEBTdGF0ZWBcbiAqIGRlY29yYXRvcnMsIGNhbGxiYWNrcyBmb3Igd2hlbiBhdHRyaWJ1dGVzIGNoYW5nZSwgYW5kIHNvIG9uLlxuICpcbiAqIEBwYXJhbSBDc3RyIHRoZSBjb25zdHJ1Y3RvciBmb3IgYSBjb21wb25lbnQgdGhhdCB3ZSBuZWVkIHRvIHByb2Nlc3NcbiAqIEBwYXJhbSBjbXBNZXRhIG1ldGFkYXRhIGNvbGxlY3RlZCBwcmV2aW91c2x5IGFib3V0IHRoZSBjb21wb25lbnRcbiAqIEBwYXJhbSBmbGFncyBhIG51bWJlciB1c2VkIHRvIHN0b3JlIGEgc2VyaWVzIG9mIGJpdCBmbGFnc1xuICogQHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHNhbWUgY29uc3RydWN0b3IgcGFzc2VkIGluIChidXQgbm93IG11dGF0ZWQpXG4gKi9cbmNvbnN0IHByb3h5Q29tcG9uZW50ID0gKENzdHIsIGNtcE1ldGEsIGZsYWdzKSA9PiB7XG4gICAgaWYgKEJVSUxELm1lbWJlciAmJiBjbXBNZXRhLiRtZW1iZXJzJCkge1xuICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjayAmJiBDc3RyLndhdGNoZXJzKSB7XG4gICAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLndhdGNoZXJzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0J3MgYmV0dGVyIHRvIGhhdmUgYSBjb25zdCB0aGFuIHR3byBPYmplY3QuZW50cmllcygpXG4gICAgICAgIGNvbnN0IG1lbWJlcnMgPSBPYmplY3QuZW50cmllcyhjbXBNZXRhLiRtZW1iZXJzJCk7XG4gICAgICAgIGNvbnN0IHByb3RvdHlwZSA9IENzdHIucHJvdG90eXBlO1xuICAgICAgICBtZW1iZXJzLm1hcCgoW21lbWJlck5hbWUsIFttZW1iZXJGbGFnc11dKSA9PiB7XG4gICAgICAgICAgICBpZiAoKEJVSUxELnByb3AgfHwgQlVJTEQuc3RhdGUpICYmXG4gICAgICAgICAgICAgICAgKG1lbWJlckZsYWdzICYgMzEgLyogTUVNQkVSX0ZMQUdTLlByb3AgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgKCghQlVJTEQubGF6eUxvYWQgfHwgZmxhZ3MgJiAyIC8qIFBST1hZX0ZMQUdTLnByb3h5U3RhdGUgKi8pICYmIG1lbWJlckZsYWdzICYgMzIgLyogTUVNQkVSX0ZMQUdTLlN0YXRlICovKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCAtIHByb3BcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBtZW1iZXJOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50LCBnZXQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZSh0aGlzLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGR1cmluZyBkZXYgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZ2V0SG9zdFJlZih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIHByb3h5aW5nIHRoZSBpbnN0YW5jZSAobm90IGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsYWdzICYgMSAvKiBQUk9YWV9GTEFHUy5pc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGVsZW1lbnQgaXMgbm90IGNvbnN0cnVjdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVmLiRmbGFncyQgJiA4IC8qIEhPU1RfRkxBR1MuaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1lbWJlciBpcyBhIHByb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1lbWJlckZsYWdzICYgMzEgLyogTUVNQkVSX0ZMQUdTLlByb3AgKi8pICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtZW1iZXIgaXMgbm90IG11dGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1lbWJlckZsYWdzICYgMTAyNCAvKiBNRU1CRVJfRkxBR1MuTXV0YWJsZSAqLykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYEBQcm9wKCkgXCIke21lbWJlck5hbWV9XCIgb24gPCR7Y21wTWV0YS4kdGFnTmFtZSR9PiBpcyBpbW11dGFibGUgYnV0IHdhcyBtb2RpZmllZCBmcm9tIHdpdGhpbiB0aGUgY29tcG9uZW50Llxcbk1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vc3RlbmNpbGpzLmNvbS9kb2NzL3Byb3BlcnRpZXMjcHJvcC1tdXRhYmlsaXR5YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJveHlDb21wb25lbnQsIHNldCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUodGhpcywgbWVtYmVyTmFtZSwgbmV3VmFsdWUsIGNtcE1ldGEpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChCVUlMRC5sYXp5TG9hZCAmJlxuICAgICAgICAgICAgICAgIEJVSUxELm1ldGhvZCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzICYgMSAvKiBQUk9YWV9GTEFHUy5pc0VsZW1lbnRDb25zdHJ1Y3RvciAqLyAmJlxuICAgICAgICAgICAgICAgIG1lbWJlckZsYWdzICYgNjQgLyogTUVNQkVSX0ZMQUdTLk1ldGhvZCAqLykge1xuICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50IC0gbWV0aG9kXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbWVtYmVyTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBnZXRIb3N0UmVmKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZi4kb25JbnN0YW5jZVByb21pc2UkLnRoZW4oKCkgPT4gcmVmLiRsYXp5SW5zdGFuY2UkW21lbWJlck5hbWVdKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChCVUlMRC5vYnNlcnZlQXR0cmlidXRlICYmICghQlVJTEQubGF6eUxvYWQgfHwgZmxhZ3MgJiAxIC8qIFBST1hZX0ZMQUdTLmlzRWxlbWVudENvbnN0cnVjdG9yICovKSkge1xuICAgICAgICAgICAgY29uc3QgYXR0ck5hbWVUb1Byb3BOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IGF0dHJOYW1lVG9Qcm9wTmFtZS5nZXQoYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgSW4gYSB3ZWIgY29tcG9uZW50IGxpZmVjeWNsZSB0aGUgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIHJ1bnMgcHJpb3IgdG8gY29ubmVjdGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gIGluIHRoZSBjYXNlIHdoZXJlIGFuIGF0dHJpYnV0ZSB3YXMgc2V0IGlubGluZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYGh0bWxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgPG15LWNvbXBvbmVudCBzb21lLWF0dHJpYnV0ZT1cInNvbWUtdmFsdWVcIj48L215LWNvbXBvbmVudD5cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAgVGhlcmUgaXMgYW4gZWRnZSBjYXNlIHdoZXJlIGEgZGV2ZWxvcGVyIHNldHMgdGhlIGF0dHJpYnV0ZSBpbmxpbmUgb24gYSBjdXN0b20gZWxlbWVudCBhbmQgdGhlblxuICAgICAgICAgICAgICAgICAgICAvLyAgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VzIGl0IGJlZm9yZSBpdCBoYXMgYmVlbiB1cGdyYWRlZCBhcyBzaG93biBiZWxvdzpcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYGh0bWxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgPCEtLSB0aGlzIGNvbXBvbmVudCBoYXMgX25vdF8gYmVlbiB1cGdyYWRlZCB5ZXQgLS0+XG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDxteS1jb21wb25lbnQgaWQ9XCJ0ZXN0XCIgc29tZS1hdHRyaWJ1dGU9XCJzb21lLXZhbHVlXCI+PC9teS1jb21wb25lbnQ+XG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDxzY3JpcHQ+XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgLy8gZ3JhYiBub24tdXBncmFkZWQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Rlc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgZWwuc29tZUF0dHJpYnV0ZSA9IFwiYW5vdGhlci12YWx1ZVwiO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIC8vIHVwZ3JhZGUgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdteS1jb21wb25lbnQnLCBNeUNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDwvc2NyaXB0PlxuICAgICAgICAgICAgICAgICAgICAvLyAgYGBgXG4gICAgICAgICAgICAgICAgICAgIC8vICBJbiB0aGlzIGNhc2UgaWYgd2UgZG8gbm90IHVuc2hhZG93IGhlcmUgYW5kIHVzZSB0aGUgdmFsdWUgb2YgdGhlIHNoYWRvd2luZyBwcm9wZXJ0eSwgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vICB3aWxsIGJlIGNhbGxlZCB3aXRoIGBuZXdWYWx1ZSA9IFwic29tZS12YWx1ZVwiYCBhbmQgd2lsbCBzZXQgdGhlIHNoYWRvd2VkIHByb3BlcnR5ICh0aGlzLnNvbWVBdHRyaWJ1dGUgPSBcImFub3RoZXItdmFsdWVcIilcbiAgICAgICAgICAgICAgICAgICAgLy8gIHRvIHRoZSB2YWx1ZSB0aGF0IHdhcyBzZXQgaW5saW5lIGkuZS4gXCJzb21lLXZhbHVlXCIgZnJvbSBhYm92ZSBleGFtcGxlLiBXaGVuXG4gICAgICAgICAgICAgICAgICAgIC8vICB0aGUgY29ubmVjdGVkQ2FsbGJhY2sgYXR0ZW1wdHMgdG8gdW5zaGFkb3cgaXQgd2lsbCB1c2UgXCJzb21lLXZhbHVlXCIgYXMgdGhlIGluaXRpYWwgdmFsdWUgcmF0aGVyIHRoYW4gXCJhbm90aGVyLXZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZSBjYXNlIHdoZXJlIHRoZSBhdHRyaWJ1dGUgd2FzIE5PVCBzZXQgaW5saW5lIGJ1dCB3YXMgbm90IHNldCBwcm9ncmFtbWF0aWNhbGx5IHNoYWxsIGJlIGhhbmRsZWQvdW5zaGFkb3dlZFxuICAgICAgICAgICAgICAgICAgICAvLyAgYnkgY29ubmVjdGVkQ2FsbGJhY2sgYXMgdGhpcyBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgd2lsbCBub3QgZmlyZS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi9mdW5kYW1lbnRhbHMvd2ViLWNvbXBvbmVudHMvYmVzdC1wcmFjdGljZXMjbGF6eS1wcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBUT0RPKFNURU5DSUwtMTYpIHdlIHNob3VsZCB0aGluayBhYm91dCB3aGV0aGVyIG9yIG5vdCB3ZSBhY3R1YWxseSB3YW50IHRvIGJlIHJlZmxlY3RpbmcgdGhlIGF0dHJpYnV0ZXMgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gIHByb3BlcnRpZXMgaGVyZSBnaXZlbiB0aGF0IHRoaXMgZ29lcyBhZ2FpbnN0IGJlc3QgcHJhY3RpY2VzIG91dGxpbmVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi9mdW5kYW1lbnRhbHMvd2ViLWNvbXBvbmVudHMvYmVzdC1wcmFjdGljZXMjYXZvaWQtcmVlbnRyYW5jeVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRoaXNbcHJvcE5hbWVdID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wTmFtZV0gPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9wTmFtZSBleGlzdHMgb24gdGhlIHByb3RvdHlwZSBvZiBgQ3N0cmAsIHRoaXMgdXBkYXRlIG1heSBiZSBhIHJlc3VsdCBvZiBTdGVuY2lsIHVzaW5nIG5hdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVBJcyB0byByZWZsZWN0IHByb3BzIGFzIGF0dHJpYnV0ZXMuIENhbGxzIHRvIGBzZXRBdHRyaWJ1dGUoc29tZUVsZW1lbnQsIHByb3BOYW1lKWAgd2lsbCByZXN1bHQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBwcm9wTmFtZWAgdG8gYmUgY29udmVydGVkIHRvIGEgYERPTVN0cmluZ2AsIHdoaWNoIG1heSBub3QgYmUgd2hhdCB3ZSB3YW50IGZvciBvdGhlciBwcmltaXRpdmUgcHJvcHMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuZXdWYWx1ZSA9PT0gbnVsbCAmJiB0eXBlb2YgdGhpc1twcm9wTmFtZV0gPT09ICdib29sZWFuJyA/IGZhbHNlIDogbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gb2JzZXJ2ZVxuICAgICAgICAgICAgLy8gYW5kIGFsc28gY3JlYXRlIGEgbWFwIG9mIGh0bWwgYXR0cmlidXRlIG5hbWUgdG8ganMgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgQ3N0ci5vYnNlcnZlZEF0dHJpYnV0ZXMgPSBtZW1iZXJzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoW18sIG1dKSA9PiBtWzBdICYgMTUgLyogTUVNQkVSX0ZMQUdTLkhhc0F0dHJpYnV0ZSAqLykgLy8gZmlsdGVyIHRvIG9ubHkga2VlcCBwcm9wcyB0aGF0IHNob3VsZCBtYXRjaCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgLm1hcCgoW3Byb3BOYW1lLCBtXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lID0gbVsxXSB8fCBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICBhdHRyTmFtZVRvUHJvcE5hbWUuc2V0KGF0dHJOYW1lLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnJlZmxlY3QgJiYgbVswXSAmIDUxMiAvKiBNRU1CRVJfRkxBR1MuUmVmbGVjdEF0dHIgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkLnB1c2goW3Byb3BOYW1lLCBhdHRyTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0ck5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQ3N0cjtcbn07XG5jb25zdCBpbml0aWFsaXplQ29tcG9uZW50ID0gYXN5bmMgKGVsbSwgaG9zdFJlZiwgY21wTWV0YSwgaG1yVmVyc2lvbklkLCBDc3RyKSA9PiB7XG4gICAgLy8gaW5pdGlhbGl6ZUNvbXBvbmVudFxuICAgIGlmICgoQlVJTEQubGF6eUxvYWQgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgfHwgQlVJTEQuc3R5bGUpICYmXG4gICAgICAgIChob3N0UmVmLiRmbGFncyQgJiAzMiAvKiBIT1NUX0ZMQUdTLmhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovKSA9PT0gMCkge1xuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgfHwgQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmVuJ3QgaW5pdGlhbGl6ZWQgdGhpcyBlbGVtZW50IHlldFxuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDMyIC8qIEhPU1RfRkxBR1MuaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQgKi87XG4gICAgICAgICAgICAvLyBsYXp5IGxvYWRlZCBjb21wb25lbnRzXG4gICAgICAgICAgICAvLyByZXF1ZXN0IHRoZSBjb21wb25lbnQncyBpbXBsZW1lbnRhdGlvbiB0byBiZVxuICAgICAgICAgICAgLy8gd2lyZWQgdXAgd2l0aCB0aGUgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICBDc3RyID0gbG9hZE1vZHVsZShjbXBNZXRhLCBob3N0UmVmLCBobXJWZXJzaW9uSWQpO1xuICAgICAgICAgICAgaWYgKENzdHIudGhlbikge1xuICAgICAgICAgICAgICAgIC8vIEF3YWl0IGNyZWF0ZXMgYSBtaWNyby10YXNrIGF2b2lkIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kTG9hZCA9IHVuaXF1ZVRpbWUoYHN0OmxvYWQ6JHtjbXBNZXRhLiR0YWdOYW1lJH06JHtob3N0UmVmLiRtb2RlTmFtZSR9YCwgYFtTdGVuY2lsXSBMb2FkIG1vZHVsZSBmb3IgPCR7Y21wTWV0YS4kdGFnTmFtZSR9PmApO1xuICAgICAgICAgICAgICAgIENzdHIgPSBhd2FpdCBDc3RyO1xuICAgICAgICAgICAgICAgIGVuZExvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoQlVJTEQuaXNEZXYgfHwgQlVJTEQuaXNEZWJ1ZykgJiYgIUNzdHIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnN0cnVjdG9yIGZvciBcIiR7Y21wTWV0YS4kdGFnTmFtZSR9IyR7aG9zdFJlZi4kbW9kZU5hbWUkfVwiIHdhcyBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5tZW1iZXIgJiYgIUNzdHIuaXNQcm94aWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UndmUgbmV2ZXIgcHJveGllZCB0aGlzIENvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIGxldCdzIGFkZCB0aGUgZ2V0dGVycy9zZXR0ZXJzIHRvIGl0cyBwcm90b3R5cGUgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IHRpbWUgd2UgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIud2F0Y2hlcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3h5Q29tcG9uZW50KENzdHIsIGNtcE1ldGEsIDIgLyogUFJPWFlfRkxBR1MucHJveHlTdGF0ZSAqLyk7XG4gICAgICAgICAgICAgICAgQ3N0ci5pc1Byb3hpZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW5kTmV3SW5zdGFuY2UgPSBjcmVhdGVUaW1lKCdjcmVhdGVJbnN0YW5jZScsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgICAgIC8vIG9rLCB0aW1lIHRvIGNvbnN0cnVjdCB0aGUgaW5zdGFuY2VcbiAgICAgICAgICAgIC8vIGJ1dCBsZXQncyBrZWVwIHRyYWNrIG9mIHdoZW4gd2Ugc3RhcnQgYW5kIHN0b3BcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGdldHRlcnMvc2V0dGVycyBkb24ndCBpbmNvcnJlY3RseSBzdGVwIG9uIGRhdGFcbiAgICAgICAgICAgIGlmIChCVUlMRC5tZW1iZXIpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gOCAvKiBIT1NUX0ZMQUdTLmlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zdHJ1Y3QgdGhlIGxhenktbG9hZGVkIGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgLy8gcGFzc2luZyB0aGUgaG9zdFJlZiBpcyB2ZXJ5IGltcG9ydGFudCBkdXJpbmdcbiAgICAgICAgICAgIC8vIGNvbnN0cnVjdGlvbiBpbiBvcmRlciB0byBkaXJlY3RseSB3aXJlIHRvZ2V0aGVyIHRoZVxuICAgICAgICAgICAgLy8gaG9zdCBlbGVtZW50IGFuZCB0aGUgbGF6eS1sb2FkZWQgaW5zdGFuY2VcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV3IENzdHIoaG9zdFJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5tZW1iZXIpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgJj0gfjggLyogSE9TVF9GTEFHUy5pc0NvbnN0cnVjdGluZ0luc3RhbmNlICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIEhPU1RfRkxBR1MuaXNXYXRjaFJlYWR5ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kTmV3SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGZpcmVDb25uZWN0ZWRDYWxsYmFjayhob3N0UmVmLiRsYXp5SW5zdGFuY2UkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN5bmMgY29uc3RydWN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICBDc3RyID0gZWxtLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDMyIC8qIEhPU1RfRkxBR1MuaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQgKi87XG4gICAgICAgICAgICAvLyB3YWl0IGZvciB0aGUgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5IHRvIG1hcmsgdGhlIGNvbXBvbmVudCBhcyByZWFkeSBiZWZvcmUgc2V0dGluZyBgaXNXYXRjaFJlYWR5YC4gT3RoZXJ3aXNlLFxuICAgICAgICAgICAgLy8gd2F0Y2hlcnMgbWF5IGZpcmUgcHJlbWF0dXJlbHkgaWYgYGN1c3RvbUVsZW1lbnRzLmdldCgpYC9gY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQoKWAgcmVzb2x2ZXMgX2JlZm9yZV9cbiAgICAgICAgICAgIC8vIFN0ZW5jaWwgaGFzIGNvbXBsZXRlZCBpbnN0YW50aWF0aW5nIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAgICBjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZChjbXBNZXRhLiR0YWdOYW1lJCkudGhlbigoKSA9PiAoaG9zdFJlZi4kZmxhZ3MkIHw9IDEyOCAvKiBIT1NUX0ZMQUdTLmlzV2F0Y2hSZWFkeSAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdHlsZSAmJiBDc3RyLnN0eWxlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBoYXMgc3R5bGVzIGJ1dCB3ZSBoYXZlbid0IHJlZ2lzdGVyZWQgdGhlbSB5ZXRcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IENzdHIuc3R5bGU7XG4gICAgICAgICAgICBpZiAoQlVJTEQubW9kZSAmJiB0eXBlb2Ygc3R5bGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZVsoaG9zdFJlZi4kbW9kZU5hbWUkID0gY29tcHV0ZU1vZGUoZWxtKSldO1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBob3N0UmVmLiRtb2RlTmFtZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZSgncy1tb2RlJywgaG9zdFJlZi4kbW9kZU5hbWUkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBob3N0UmVmLiRtb2RlTmFtZSQpO1xuICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kUmVnaXN0ZXJTdHlsZXMgPSBjcmVhdGVUaW1lKCdyZWdpc3RlclN0eWxlcycsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmXG4gICAgICAgICAgICAgICAgICAgIEJVSUxELnNoYWRvd0RvbSAmJlxuICAgICAgICAgICAgICAgICAgICBCVUlMRC5zaGFkb3dEb21TaGltICYmXG4gICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJGZsYWdzJCAmIDggLyogQ01QX0ZMQUdTLm5lZWRzU2hhZG93RG9tU2hpbSAqLykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IGF3YWl0IGltcG9ydCgnLi9zaGFkb3ctY3NzLmpzJykudGhlbigobSkgPT4gbS5zY29wZUNzcyhzdHlsZSwgc2NvcGVJZCwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJTdHlsZShzY29wZUlkLCBzdHlsZSwgISEoY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBDTVBfRkxBR1Muc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykpO1xuICAgICAgICAgICAgICAgIGVuZFJlZ2lzdGVyU3R5bGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UndmUgc3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgYSBsYXp5IGluc3RhbmNlXG4gICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnQgPSBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQ7XG4gICAgY29uc3Qgc2NoZWR1bGUgPSAoKSA9PiBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCB0cnVlKTtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGFuY2VzdG9yQ29tcG9uZW50ICYmIGFuY2VzdG9yQ29tcG9uZW50WydzLXJjJ10pIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgaW5pdGlhbCBsb2FkIGFuZCB0aGlzIGNvbXBvbmVudCBpdCBoYXMgYW4gYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgIC8vIGJ1dCB0aGUgYW5jZXN0b3IgY29tcG9uZW50IGhhcyBOT1QgZmlyZWQgaXRzIHdpbGwgdXBkYXRlIGxpZmVjeWNsZSB5ZXRcbiAgICAgICAgLy8gc28gbGV0J3MganVzdCBjb29sIG91ciBqZXRzIGFuZCB3YWl0IGZvciB0aGUgYW5jZXN0b3IgdG8gY29udGludWUgZmlyc3RcbiAgICAgICAgLy8gdGhpcyB3aWxsIGdldCBmaXJlZCBvZmYgd2hlbiB0aGUgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgIC8vIGZpbmFsbHkgZ2V0cyBhcm91bmQgdG8gcmVuZGVyaW5nIGl0cyBsYXp5IHNlbGZcbiAgICAgICAgLy8gZmlyZSBvZmYgdGhlIGluaXRpYWwgdXBkYXRlXG4gICAgICAgIGFuY2VzdG9yQ29tcG9uZW50WydzLXJjJ10ucHVzaChzY2hlZHVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzY2hlZHVsZSgpO1xuICAgIH1cbn07XG5jb25zdCBmaXJlQ29ubmVjdGVkQ2FsbGJhY2sgPSAoaW5zdGFuY2UpID0+IHtcbiAgICBpZiAoQlVJTEQubGF6eUxvYWQgJiYgQlVJTEQuY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsICdjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgIH1cbn07XG5jb25zdCBjb25uZWN0ZWRDYWxsYmFjayA9IChlbG0pID0+IHtcbiAgICBpZiAoKHBsdC4kZmxhZ3MkICYgMSAvKiBQTEFURk9STV9GTEFHUy5pc1RtcERpc2Nvbm5lY3RlZCAqLykgPT09IDApIHtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAgICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgICAgICBjb25zdCBlbmRDb25uZWN0ZWQgPSBjcmVhdGVUaW1lKCdjb25uZWN0ZWRDYWxsYmFjaycsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFBhcmVudCkge1xuICAgICAgICAgICAgLy8gb25seSBydW4gaWYgd2UgaGF2ZSBsaXN0ZW5lcnMgYmVpbmcgYXR0YWNoZWQgdG8gYSBwYXJlbnRcbiAgICAgICAgICAgIGFkZEhvc3RFdmVudExpc3RlbmVycyhlbG0sIGhvc3RSZWYsIGNtcE1ldGEuJGxpc3RlbmVycyQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGhvc3RSZWYuJGZsYWdzJCAmIDEgLyogSE9TVF9GTEFHUy5oYXNDb25uZWN0ZWQgKi8pKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCB0aW1lIHRoaXMgY29tcG9uZW50IGhhcyBjb25uZWN0ZWRcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxIC8qIEhPU1RfRkxBR1MuaGFzQ29ubmVjdGVkICovO1xuICAgICAgICAgICAgbGV0IGhvc3RJZDtcbiAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSkge1xuICAgICAgICAgICAgICAgIGhvc3RJZCA9IGVsbS5nZXRBdHRyaWJ1dGUoSFlEUkFURV9JRCk7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHN1cHBvcnRzU2hhZG93ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogQ01QX0ZMQUdTLnNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlSWQgPSBCVUlMRC5tb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhZGRTdHlsZShlbG0uc2hhZG93Um9vdCwgY21wTWV0YSwgZWxtLmdldEF0dHJpYnV0ZSgncy1tb2RlJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhZGRTdHlsZShlbG0uc2hhZG93Um9vdCwgY21wTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0uY2xhc3NMaXN0LnJlbW92ZShzY29wZUlkICsgJy1oJywgc2NvcGVJZCArICctcycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVDbGllbnRIeWRyYXRlKGVsbSwgY21wTWV0YS4kdGFnTmFtZSQsIGhvc3RJZCwgaG9zdFJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmICFob3N0SWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0VXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNsb3QgcG9seWZpbGwgaXMgcmVxdWlyZWQgd2UnbGwgbmVlZCB0byBwdXQgc29tZSBub2Rlc1xuICAgICAgICAgICAgICAgIC8vIGluIGhlcmUgdG8gYWN0IGFzIG9yaWdpbmFsIGNvbnRlbnQgYW5jaG9ycyBhcyB3ZSBtb3ZlIG5vZGVzIGFyb3VuZFxuICAgICAgICAgICAgICAgIC8vIGhvc3QgZWxlbWVudCBoYXMgYmVlbiBjb25uZWN0ZWQgdG8gdGhlIERPTVxuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSB8fFxuICAgICAgICAgICAgICAgICAgICAoKEJVSUxELnNsb3QgfHwgQlVJTEQuc2hhZG93RG9tKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY21wTWV0YS4kZmxhZ3MkICYgKDQgLyogQ01QX0ZMQUdTLmhhc1Nsb3RSZWxvY2F0aW9uICovIHwgOCAvKiBDTVBfRkxBR1MubmVlZHNTaGFkb3dEb21TaGltICovKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q29udGVudFJlZmVyZW5jZShlbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBhbmNlc3RvciBjb21wb25lbnQgKGlmIHRoZXJlIGlzIG9uZSkgYW5kIHJlZ2lzdGVyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgYXMgb25lIG9mIHRoZSBhY3RpdmVseSBsb2FkaW5nIGNoaWxkIGNvbXBvbmVudHMgZm9yIGl0cyBhbmNlc3RvclxuICAgICAgICAgICAgICAgIGxldCBhbmNlc3RvckNvbXBvbmVudCA9IGVsbTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGFuY2VzdG9yQ29tcG9uZW50ID0gYW5jZXN0b3JDb21wb25lbnQucGFyZW50Tm9kZSB8fCBhbmNlc3RvckNvbXBvbmVudC5ob3N0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGltYiB1cCB0aGUgYW5jZXN0b3JzIGxvb2tpbmcgZm9yIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgZmluaXNoZWQgaXRzIGxpZmVjeWNsZSB1cGRhdGUgeWV0XG4gICAgICAgICAgICAgICAgICAgIGlmICgoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yQ29tcG9uZW50Lm5vZGVUeXBlID09PSAxIC8qIE5PREVfVFlQRS5FbGVtZW50Tm9kZSAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JDb21wb25lbnQuaGFzQXR0cmlidXRlKCdzLWlkJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZm91bmQgdGhpcyBjb21wb25lbnRzIGZpcnN0IGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGlzIGNvbXBvbmVudCdzIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoVG9BbmNlc3Rvcihob3N0UmVmLCAoaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkID0gYW5jZXN0b3JDb21wb25lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGF6eSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2xhenktcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKEJVSUxELnByb3AgJiYgIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIGNtcE1ldGEuJG1lbWJlcnMkKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY21wTWV0YS4kbWVtYmVycyQpLm1hcCgoW21lbWJlck5hbWUsIFttZW1iZXJGbGFnc11dKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXJGbGFncyAmIDMxIC8qIE1FTUJFUl9GTEFHUy5Qcm9wICovICYmIGVsbS5oYXNPd25Qcm9wZXJ0eShtZW1iZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbG1bbWVtYmVyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxtW21lbWJlck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtW21lbWJlck5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5pbml0aWFsaXplTmV4dFRpY2spIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0ZWRDYWxsYmFjaywgdGFza1F1ZXVlLCBpbml0aWFsTG9hZFxuICAgICAgICAgICAgICAgIC8vIGFuZ3VsYXIgc2V0cyBhdHRyaWJ1dGUgQUZURVIgY29ubmVjdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTg5MDlcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xOTk0MFxuICAgICAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IGluaXRpYWxpemVDb21wb25lbnQoZWxtLCBob3N0UmVmLCBjbXBNZXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBub3QgdGhlIGZpcnN0IHRpbWUgdGhpcyBoYXMgY29ubmVjdGVkXG4gICAgICAgICAgICAvLyByZWF0dGFjaCBhbnkgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBob3N0XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IHdvdWxkIGhhdmUgYmVlbiByZW1vdmVkIHdoZW4gZGlzY29ubmVjdGVkXG4gICAgICAgICAgICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZWxtLCBob3N0UmVmLCBjbXBNZXRhLiRsaXN0ZW5lcnMkLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyBmaXJlIG9mZiBjb25uZWN0ZWRDYWxsYmFjaygpIG9uIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAgICAgICAgZmlyZUNvbm5lY3RlZENhbGxiYWNrKGhvc3RSZWYuJGxhenlJbnN0YW5jZSQpO1xuICAgICAgICB9XG4gICAgICAgIGVuZENvbm5lY3RlZCgpO1xuICAgIH1cbn07XG5jb25zdCBzZXRDb250ZW50UmVmZXJlbmNlID0gKGVsbSkgPT4ge1xuICAgIC8vIG9ubHkgcmVxdWlyZWQgd2hlbiB3ZSdyZSBOT1QgdXNpbmcgbmF0aXZlIHNoYWRvdyBkb20gKHNsb3QpXG4gICAgLy8gb3IgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBuYXRpdmUgc2hhZG93IGRvbVxuICAgIC8vIGFuZCB0aGlzIGhvc3QgZWxlbWVudCB3YXMgTk9UIGNyZWF0ZWQgd2l0aCBTU1JcbiAgICAvLyBsZXQncyBwaWNrIG91dCB0aGUgaW5uZXIgY29udGVudCBmb3Igc2xvdCBwcm9qZWN0aW9uXG4gICAgLy8gY3JlYXRlIGEgbm9kZSB0byByZXByZXNlbnQgd2hlcmUgdGhlIG9yaWdpbmFsXG4gICAgLy8gY29udGVudCB3YXMgZmlyc3QgcGxhY2VkLCB3aGljaCBpcyB1c2VmdWwgbGF0ZXIgb25cbiAgICBjb25zdCBjb250ZW50UmVmRWxtID0gKGVsbVsncy1jciddID0gZG9jLmNyZWF0ZUNvbW1lbnQoQlVJTEQuaXNEZWJ1ZyA/IGBjb250ZW50LXJlZiAoaG9zdD0ke2VsbS5sb2NhbE5hbWV9KWAgOiAnJykpO1xuICAgIGNvbnRlbnRSZWZFbG1bJ3MtY24nXSA9IHRydWU7XG4gICAgZWxtLmluc2VydEJlZm9yZShjb250ZW50UmVmRWxtLCBlbG0uZmlyc3RDaGlsZCk7XG59O1xuY29uc3QgZGlzY29ubmVjdGVkQ2FsbGJhY2sgPSAoZWxtKSA9PiB7XG4gICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogUExBVEZPUk1fRkxBR1MuaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gQlVJTEQubGF6eUxvYWQgPyBob3N0UmVmLiRsYXp5SW5zdGFuY2UkIDogZWxtO1xuICAgICAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kcm1MaXN0ZW5lcnMkKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcm1MaXN0ZW5lcnMkLm1hcCgocm1MaXN0ZW5lcikgPT4gcm1MaXN0ZW5lcigpKTtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRybUxpc3RlbmVycyQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYXIgQ1NTIHZhci1zaGltIHRyYWNraW5nXG4gICAgICAgIGlmIChCVUlMRC5jc3NWYXJTaGltICYmIHBsdC4kY3NzU2hpbSQpIHtcbiAgICAgICAgICAgIHBsdC4kY3NzU2hpbSQucmVtb3ZlSG9zdChlbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5sYXp5TG9hZCAmJiBCVUlMRC5kaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsICdkaXNjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRVbmxvYWQpIHtcbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkVW5sb2FkJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgZGVmaW5lQ3VzdG9tRWxlbWVudCA9IChDc3RyLCBjb21wYWN0TWV0YSkgPT4ge1xuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZShjb21wYWN0TWV0YVsxXSwgcHJveHlDdXN0b21FbGVtZW50KENzdHIsIGNvbXBhY3RNZXRhKSk7XG59O1xuY29uc3QgcHJveHlDdXN0b21FbGVtZW50ID0gKENzdHIsIGNvbXBhY3RNZXRhKSA9PiB7XG4gICAgY29uc3QgY21wTWV0YSA9IHtcbiAgICAgICAgJGZsYWdzJDogY29tcGFjdE1ldGFbMF0sXG4gICAgICAgICR0YWdOYW1lJDogY29tcGFjdE1ldGFbMV0sXG4gICAgfTtcbiAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgIGNtcE1ldGEuJG1lbWJlcnMkID0gY29tcGFjdE1ldGFbMl07XG4gICAgfVxuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgY21wTWV0YS4kbGlzdGVuZXJzJCA9IGNvbXBhY3RNZXRhWzNdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLiR3YXRjaGVycyQ7XG4gICAgfVxuICAgIGlmIChCVUlMRC5yZWZsZWN0KSB7XG4gICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JCA9IFtdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmICFzdXBwb3J0c1NoYWRvdyAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIENNUF9GTEFHUy5zaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIGNtcE1ldGEuJGZsYWdzJCB8PSA4IC8qIENNUF9GTEFHUy5uZWVkc1NoYWRvd0RvbVNoaW0gKi87XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsQ29ubmVjdGVkQ2FsbGJhY2sgPSBDc3RyLnByb3RvdHlwZS5jb25uZWN0ZWRDYWxsYmFjaztcbiAgICBjb25zdCBvcmlnaW5hbERpc2Nvbm5lY3RlZENhbGxiYWNrID0gQ3N0ci5wcm90b3R5cGUuZGlzY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgT2JqZWN0LmFzc2lnbihDc3RyLnByb3RvdHlwZSwge1xuICAgICAgICBfX3JlZ2lzdGVySG9zdCgpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVySG9zdCh0aGlzLCBjbXBNZXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBjb25uZWN0ZWRDYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5jb25uZWN0ZWRDYWxsYmFjayAmJiBvcmlnaW5hbENvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxDb25uZWN0ZWRDYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmRpc2Nvbm5lY3RlZENhbGxiYWNrICYmIG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbERpc2Nvbm5lY3RlZENhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9fYXR0YWNoU2hhZG93KCkge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzU2hhZG93KSB7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RlbGVnYXRlc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdvcGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlc0ZvY3VzOiAhIShjbXBNZXRhLiRmbGFncyQgJiAxNiAvKiBDTVBfRkxBR1Muc2hhZG93RGVsZWdhdGVzRm9jdXMgKi8pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgQ3N0ci5pcyA9IGNtcE1ldGEuJHRhZ05hbWUkO1xuICAgIHJldHVybiBwcm94eUNvbXBvbmVudChDc3RyLCBjbXBNZXRhLCAxIC8qIFBST1hZX0ZMQUdTLmlzRWxlbWVudENvbnN0cnVjdG9yICovIHwgMiAvKiBQUk9YWV9GTEFHUy5wcm94eVN0YXRlICovKTtcbn07XG5jb25zdCBmb3JjZU1vZGVVcGRhdGUgPSAoZWxtKSA9PiB7XG4gICAgaWYgKEJVSUxELnN0eWxlICYmIEJVSUxELm1vZGUgJiYgIUJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSBjb21wdXRlTW9kZShlbG0pO1xuICAgICAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihlbG0pO1xuICAgICAgICBpZiAoaG9zdFJlZi4kbW9kZU5hbWUkICE9PSBtb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gICAgICAgICAgICBjb25zdCBvbGRTY29wZUlkID0gZWxtWydzLXNjJ107XG4gICAgICAgICAgICBjb25zdCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBtb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWxtLmNvbnN0cnVjdG9yLnN0eWxlW21vZGVdO1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBjbXBNZXRhLiRmbGFncyQ7XG4gICAgICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlcy5oYXMoc2NvcGVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJTdHlsZShzY29wZUlkLCBzdHlsZSwgISEoZmxhZ3MgJiAxIC8qIENNUF9GTEFHUy5zaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvc3RSZWYuJG1vZGVOYW1lJCA9IG1vZGU7XG4gICAgICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUob2xkU2NvcGVJZCArICctaCcsIG9sZFNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hTdHlsZXMoaG9zdFJlZik7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBwYXRjaENsb25lTm9kZSA9IChIb3N0RWxlbWVudFByb3RvdHlwZSkgPT4ge1xuICAgIGNvbnN0IG9yZ0Nsb25lTm9kZSA9IEhvc3RFbGVtZW50UHJvdG90eXBlLmNsb25lTm9kZTtcbiAgICBIb3N0RWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGUgPSBmdW5jdGlvbiAoZGVlcCkge1xuICAgICAgICBjb25zdCBzcmNOb2RlID0gdGhpcztcbiAgICAgICAgY29uc3QgaXNTaGFkb3dEb20gPSBCVUlMRC5zaGFkb3dEb20gPyBzcmNOb2RlLnNoYWRvd1Jvb3QgJiYgc3VwcG9ydHNTaGFkb3cgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgY2xvbmVkTm9kZSA9IG9yZ0Nsb25lTm9kZS5jYWxsKHNyY05vZGUsIGlzU2hhZG93RG9tID8gZGVlcCA6IGZhbHNlKTtcbiAgICAgICAgaWYgKEJVSUxELnNsb3QgJiYgIWlzU2hhZG93RG9tICYmIGRlZXApIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGxldCBzbG90dGVkLCBub25TdGVuY2lsTm9kZTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZW5jaWxQcml2YXRlcyA9IFtcbiAgICAgICAgICAgICAgICAncy1pZCcsXG4gICAgICAgICAgICAgICAgJ3MtY3InLFxuICAgICAgICAgICAgICAgICdzLWxyJyxcbiAgICAgICAgICAgICAgICAncy1yYycsXG4gICAgICAgICAgICAgICAgJ3Mtc2MnLFxuICAgICAgICAgICAgICAgICdzLXAnLFxuICAgICAgICAgICAgICAgICdzLWNuJyxcbiAgICAgICAgICAgICAgICAncy1zcicsXG4gICAgICAgICAgICAgICAgJ3Mtc24nLFxuICAgICAgICAgICAgICAgICdzLWhuJyxcbiAgICAgICAgICAgICAgICAncy1vbCcsXG4gICAgICAgICAgICAgICAgJ3MtbnInLFxuICAgICAgICAgICAgICAgICdzLXNpJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHNyY05vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNsb3R0ZWQgPSBzcmNOb2RlLmNoaWxkTm9kZXNbaV1bJ3MtbnInXTtcbiAgICAgICAgICAgICAgICBub25TdGVuY2lsTm9kZSA9IHN0ZW5jaWxQcml2YXRlcy5ldmVyeSgocHJpdmF0ZUZpZWxkKSA9PiAhc3JjTm9kZS5jaGlsZE5vZGVzW2ldW3ByaXZhdGVGaWVsZF0pO1xuICAgICAgICAgICAgICAgIGlmIChzbG90dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5hcHBlbmRDaGlsZFNsb3RGaXggJiYgY2xvbmVkTm9kZS5fX2FwcGVuZENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWROb2RlLl9fYXBwZW5kQ2hpbGQoc2xvdHRlZC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5hcHBlbmRDaGlsZChzbG90dGVkLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vblN0ZW5jaWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lZE5vZGUuYXBwZW5kQ2hpbGQoc3JjTm9kZS5jaGlsZE5vZGVzW2ldLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZWROb2RlO1xuICAgIH07XG59O1xuY29uc3QgcGF0Y2hTbG90QXBwZW5kQ2hpbGQgPSAoSG9zdEVsZW1lbnRQcm90b3R5cGUpID0+IHtcbiAgICBIb3N0RWxlbWVudFByb3RvdHlwZS5fX2FwcGVuZENoaWxkID0gSG9zdEVsZW1lbnRQcm90b3R5cGUuYXBwZW5kQ2hpbGQ7XG4gICAgSG9zdEVsZW1lbnRQcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAobmV3Q2hpbGQpIHtcbiAgICAgICAgY29uc3Qgc2xvdE5hbWUgPSAobmV3Q2hpbGRbJ3Mtc24nXSA9IGdldFNsb3ROYW1lKG5ld0NoaWxkKSk7XG4gICAgICAgIGNvbnN0IHNsb3ROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKHRoaXMuY2hpbGROb2Rlcywgc2xvdE5hbWUpO1xuICAgICAgICBpZiAoc2xvdE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsb3RDaGlsZE5vZGVzID0gZ2V0SG9zdFNsb3RDaGlsZE5vZGVzKHNsb3ROb2RlLCBzbG90TmFtZSk7XG4gICAgICAgICAgICBjb25zdCBhcHBlbmRBZnRlciA9IHNsb3RDaGlsZE5vZGVzW3Nsb3RDaGlsZE5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGVuZEFmdGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLCBhcHBlbmRBZnRlci5uZXh0U2libGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX19hcHBlbmRDaGlsZChuZXdDaGlsZCk7XG4gICAgfTtcbn07XG4vKipcbiAqIFBhdGNoZXMgdGhlIHRleHQgY29udGVudCBvZiBhbiB1bm5hbWVkIHNsb3R0ZWQgbm9kZSBpbnNpZGUgYSBzY29wZWQgY29tcG9uZW50XG4gKiBAcGFyYW0gaG9zdEVsZW1lbnRQcm90b3R5cGUgdGhlIGBFbGVtZW50YCB0byBiZSBwYXRjaGVkXG4gKiBAcGFyYW0gY21wTWV0YSBjb21wb25lbnQgcnVudGltZSBtZXRhZGF0YSB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSBwYXRjaGVkIG9yIG5vdFxuICovXG5jb25zdCBwYXRjaFRleHRDb250ZW50ID0gKGhvc3RFbGVtZW50UHJvdG90eXBlLCBjbXBNZXRhKSA9PiB7XG4gICAgaWYgKEJVSUxELnNjb3BlZCAmJiBjbXBNZXRhLiRmbGFncyQgJiAyIC8qIENNUF9GTEFHUy5zY29wZWRDc3NFbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5vZGUucHJvdG90eXBlLCAndGV4dENvbnRlbnQnKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3RFbGVtZW50UHJvdG90eXBlLCAnX190ZXh0Q29udGVudCcsIGRlc2NyaXB0b3IpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdEVsZW1lbnRQcm90b3R5cGUsICd0ZXh0Q29udGVudCcsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSAnZGVmYXVsdCBzbG90Jywgd2hpY2ggd291bGQgYmUgdGhlIGZpcnN0IHNsb3QgaW4gYSBzaGFkb3cgdHJlZSAoaWYgd2Ugd2VyZSB1c2luZyBvbmUpLCB3aG9zZSBuYW1lIGlzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3ROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKHRoaXMuY2hpbGROb2RlcywgJycpO1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gYSBzbG90IG5vZGUgaXMgZm91bmQsIHRoZSB0ZXh0Q29udGVudCBfbWF5XyBiZSBmb3VuZCBpbiB0aGUgbmV4dCBzaWJsaW5nICh0ZXh0KSBub2RlLCBkZXBlbmRpbmcgb24gaG93XG4gICAgICAgICAgICAgICAgLy8gbm9kZXMgd2VyZSByZW9yZGVyZWQgZHVyaW5nIHRoZSB2ZG9tIHJlbmRlci4gZmlyc3QgdHJ5IHRvIGdldCB0aGUgdGV4dCBjb250ZW50IGZyb20gdGhlIHNpYmxpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBzbG90Tm9kZSA9PT0gbnVsbCB8fCBzbG90Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2xvdE5vZGUubmV4dFNpYmxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlVHlwZSkgPT09IDMgLyogTk9ERV9UWVBFUy5URVhUX05PREUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsb3ROb2RlLm5leHRTaWJsaW5nLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzbG90Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xvdE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayB0byB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX190ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgJ2RlZmF1bHQgc2xvdCcsIHdoaWNoIHdvdWxkIGJlIHRoZSBmaXJzdCBzbG90IGluIGEgc2hhZG93IHRyZWUgKGlmIHdlIHdlcmUgdXNpbmcgb25lKSwgd2hvc2UgbmFtZSBpc1xuICAgICAgICAgICAgICAgIC8vIHRoZSBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90Tm9kZSA9IGdldEhvc3RTbG90Tm9kZSh0aGlzLmNoaWxkTm9kZXMsICcnKTtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGEgc2xvdCBub2RlIGlzIGZvdW5kLCB0aGUgdGV4dENvbnRlbnQgX21heV8gbmVlZCB0byBiZSBwbGFjZWQgaW4gdGhlIG5leHQgc2libGluZyAodGV4dCkgbm9kZSxcbiAgICAgICAgICAgICAgICAvLyBkZXBlbmRpbmcgb24gaG93IG5vZGVzIHdlcmUgcmVvcmRlcmVkIGR1cmluZyB0aGUgdmRvbSByZW5kZXIuIGZpcnN0IHRyeSB0byBzZXQgdGhlIHRleHQgY29udGVudCBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBzaWJsaW5nLlxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gc2xvdE5vZGUgPT09IG51bGwgfHwgc2xvdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNsb3ROb2RlLm5leHRTaWJsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZVR5cGUpID09PSAzIC8qIE5PREVfVFlQRVMuVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2RlLm5leHRTaWJsaW5nLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2RlLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjb3VsZG4ndCBmaW5kIGEgc2xvdCwgYnV0IHRoYXQgZG9lc24ndCBtZWFuIHRoYXQgdGhlcmUgaXNuJ3Qgb25lLiBpZiB0aGlzIGNoZWNrIHJhbiBiZWZvcmUgdGhlIERPTVxuICAgICAgICAgICAgICAgICAgICAvLyBsb2FkZWQsIHdlIGNvdWxkIGhhdmUgbWlzc2VkIGl0LiBjaGVjayBmb3IgYSBjb250ZW50IHJlZmVyZW5jZSBlbGVtZW50IG9uIHRoZSBzY29wZWQgY29tcG9uZW50IGFuZCBpbnNlcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRSZWZFbG0gPSB0aGlzWydzLWNyJ107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50UmVmRWxtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShjb250ZW50UmVmRWxtLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHBhdGNoQ2hpbGRTbG90Tm9kZXMgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gICAgY2xhc3MgRmFrZU5vZGVMaXN0IGV4dGVuZHMgQXJyYXkge1xuICAgICAgICBpdGVtKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW25dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbXBNZXRhLiRmbGFncyQgJiA4IC8qIENNUF9GTEFHUy5uZWVkc1NoYWRvd0RvbVNoaW0gKi8pIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2Rlc0ZuID0gZWxtLl9fbG9va3VwR2V0dGVyX18oJ2NoaWxkTm9kZXMnKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsbSwgJ2NoaWxkcmVuJywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubWFwKChuKSA9PiBuLm5vZGVUeXBlID09PSAxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCAnY2hpbGRFbGVtZW50Q291bnQnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsbS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsbSwgJ2NoaWxkTm9kZXMnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IGNoaWxkTm9kZXNGbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICgocGx0LiRmbGFncyQgJiAxIC8qIFBMQVRGT1JNX0ZMQUdTLmlzVG1wRGlzY29ubmVjdGVkICovKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBnZXRIb3N0UmVmKHRoaXMpLiRmbGFncyQgJiAyIC8qIEhPU1RfRkxBR1MuaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZha2VOb2RlTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZE5vZGVzW2ldWydzLW5yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNsb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBGYWtlTm9kZUxpc3QuZnJvbShjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBnZXRTbG90TmFtZSA9IChub2RlKSA9PiBub2RlWydzLXNuJ10gfHwgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSkgfHwgJyc7XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIGEgc2VyaWVzIG9mIGNoaWxkIG5vZGVzIGZvciBhIHNsb3Qgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZS5cbiAqIEBwYXJhbSBjaGlsZE5vZGVzIHRoZSBub2RlcyB0byBzZWFyY2ggZm9yIGEgc2xvdCB3aXRoIGEgc3BlY2lmaWMgbmFtZS5cbiAqIEBwYXJhbSBzbG90TmFtZSB0aGUgbmFtZSBvZiB0aGUgc2xvdCB0byBtYXRjaCBvbi5cbiAqIEByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBzbG90IG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBuYW1lLCBgbnVsbGAgb3RoZXJ3aXNlXG4gKi9cbmNvbnN0IGdldEhvc3RTbG90Tm9kZSA9IChjaGlsZE5vZGVzLCBzbG90TmFtZSkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGZvciAoOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlWydzLXNyJ10gJiYgY2hpbGROb2RlWydzLXNuJ10gPT09IHNsb3ROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkTm9kZSA9IGdldEhvc3RTbG90Tm9kZShjaGlsZE5vZGUuY2hpbGROb2Rlcywgc2xvdE5hbWUpO1xuICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldEhvc3RTbG90Q2hpbGROb2RlcyA9IChuLCBzbG90TmFtZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBbbl07XG4gICAgd2hpbGUgKChuID0gbi5uZXh0U2libGluZykgJiYgblsncy1zbiddID09PSBzbG90TmFtZSkge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2gobik7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZE5vZGVzO1xufTtcbmNvbnN0IGhtclN0YXJ0ID0gKGVsbSwgY21wTWV0YSwgaG1yVmVyc2lvbklkKSA9PiB7XG4gICAgLy8gwq9cXF8o44OEKV8vwq9cbiAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihlbG0pO1xuICAgIC8vIHJlc2V0IHN0YXRlIGZsYWdzIHRvIG9ubHkgaGF2ZSBiZWVuIGNvbm5lY3RlZFxuICAgIGhvc3RSZWYuJGZsYWdzJCA9IDEgLyogSE9TVF9GTEFHUy5oYXNDb25uZWN0ZWQgKi87XG4gICAgLy8gVE9ET1xuICAgIC8vIGRldGF0Y2ggYW55IGV2ZW50IGxpc3RlbmVycyB0aGF0IG1heSBoYXZlIGJlZW4gYWRkZWRcbiAgICAvLyBiZWNhdXNlIHdlJ3JlIG5vdCBwYXNzaW5nIGFuIGV4YWN0IGV2ZW50IG5hbWUgaXQnbGxcbiAgICAvLyByZW1vdmUgYWxsIG9mIHRoaXMgZWxlbWVudCdzIGV2ZW50LCB3aGljaCBpcyBnb29kXG4gICAgLy8gY3JlYXRlIGEgY2FsbGJhY2sgZm9yIHdoZW4gdGhpcyBjb21wb25lbnQgZmluaXNoZXMgaG1yXG4gICAgZWxtWydzLWhtci1sb2FkJ10gPSAoKSA9PiB7XG4gICAgICAgIC8vIGZpbmlzaGVkIGhtciBmb3IgdGhpcyBlbGVtZW50XG4gICAgICAgIGRlbGV0ZSBlbG1bJ3MtaG1yLWxvYWQnXTtcbiAgICB9O1xuICAgIC8vIHJlLWluaXRpYWxpemUgdGhlIGNvbXBvbmVudFxuICAgIGluaXRpYWxpemVDb21wb25lbnQoZWxtLCBob3N0UmVmLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQpO1xufTtcbmNvbnN0IGJvb3RzdHJhcExhenkgPSAobGF6eUJ1bmRsZXMsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoQlVJTEQucHJvZmlsZSAmJiBwZXJmb3JtYW5jZS5tYXJrKSB7XG4gICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3N0OmFwcDpzdGFydCcpO1xuICAgIH1cbiAgICBpbnN0YWxsRGV2VG9vbHMoKTtcbiAgICBjb25zdCBlbmRCb290c3RyYXAgPSBjcmVhdGVUaW1lKCdib290c3RyYXBMYXp5Jyk7XG4gICAgY29uc3QgY21wVGFncyA9IFtdO1xuICAgIGNvbnN0IGV4Y2x1ZGUgPSBvcHRpb25zLmV4Y2x1ZGUgfHwgW107XG4gICAgY29uc3QgY3VzdG9tRWxlbWVudHMgPSB3aW4uY3VzdG9tRWxlbWVudHM7XG4gICAgY29uc3QgaGVhZCA9IGRvYy5oZWFkO1xuICAgIGNvbnN0IG1ldGFDaGFyc2V0ID0gLypAX19QVVJFX18qLyBoZWFkLnF1ZXJ5U2VsZWN0b3IoJ21ldGFbY2hhcnNldF0nKTtcbiAgICBjb25zdCB2aXNpYmlsaXR5U3R5bGUgPSAvKkBfX1BVUkVfXyovIGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGNvbnN0IGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzID0gW107XG4gICAgY29uc3Qgc3R5bGVzID0gLypAX19QVVJFX18qLyBkb2MucXVlcnlTZWxlY3RvckFsbChgWyR7SFlEUkFURURfU1RZTEVfSUR9XWApO1xuICAgIGxldCBhcHBMb2FkRmFsbGJhY2s7XG4gICAgbGV0IGlzQm9vdHN0cmFwcGluZyA9IHRydWU7XG4gICAgbGV0IGkgPSAwO1xuICAgIE9iamVjdC5hc3NpZ24ocGx0LCBvcHRpb25zKTtcbiAgICBwbHQuJHJlc291cmNlc1VybCQgPSBuZXcgVVJMKG9wdGlvbnMucmVzb3VyY2VzVXJsIHx8ICcuLycsIGRvYy5iYXNlVVJJKS5ocmVmO1xuICAgIGlmIChCVUlMRC5hc3luY1F1ZXVlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN5bmNRdWV1ZSkge1xuICAgICAgICAgICAgcGx0LiRmbGFncyQgfD0gNCAvKiBQTEFURk9STV9GTEFHUy5xdWV1ZVN5bmMgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVDbGllbnRTaWRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBhcHAgaXMgYWxyZWFkeSBoeWRyYXRlZCB0aGVyZSBpcyBub3QgcG9pbnQgdG8gZGlzYWJsZSB0aGVcbiAgICAgICAgLy8gYXN5bmMgcXVldWUuIFRoaXMgd2lsbCBpbXByb3ZlIHRoZSBmaXJzdCBpbnB1dCBkZWxheVxuICAgICAgICBwbHQuJGZsYWdzJCB8PSAyIC8qIFBMQVRGT1JNX0ZMQUdTLmFwcExvYWRlZCAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVDbGllbnRTaWRlICYmIEJVSUxELnNoYWRvd0RvbSkge1xuICAgICAgICBmb3IgKDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVnaXN0ZXJTdHlsZShzdHlsZXNbaV0uZ2V0QXR0cmlidXRlKEhZRFJBVEVEX1NUWUxFX0lEKSwgY29udmVydFNjb3BlZFRvU2hhZG93KHN0eWxlc1tpXS5pbm5lckhUTUwpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsYXp5QnVuZGxlcy5tYXAoKGxhenlCdW5kbGUpID0+IHtcbiAgICAgICAgbGF6eUJ1bmRsZVsxXS5tYXAoKGNvbXBhY3RNZXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbXBNZXRhID0ge1xuICAgICAgICAgICAgICAgICRmbGFncyQ6IGNvbXBhY3RNZXRhWzBdLFxuICAgICAgICAgICAgICAgICR0YWdOYW1lJDogY29tcGFjdE1ldGFbMV0sXG4gICAgICAgICAgICAgICAgJG1lbWJlcnMkOiBjb21wYWN0TWV0YVsyXSxcbiAgICAgICAgICAgICAgICAkbGlzdGVuZXJzJDogY29tcGFjdE1ldGFbM10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKEJVSUxELm1lbWJlcikge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJG1lbWJlcnMkID0gY29tcGFjdE1ldGFbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgY21wTWV0YS4kbGlzdGVuZXJzJCA9IGNvbXBhY3RNZXRhWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY21wTWV0YS4kd2F0Y2hlcnMkID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmICFzdXBwb3J0c1NoYWRvdyAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIENNUF9GTEFHUy5zaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgY21wTWV0YS4kZmxhZ3MkIHw9IDggLyogQ01QX0ZMQUdTLm5lZWRzU2hhZG93RG9tU2hpbSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBCVUlMRC50cmFuc2Zvcm1UYWdOYW1lICYmIG9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKGNtcE1ldGEuJHRhZ05hbWUkKVxuICAgICAgICAgICAgICAgIDogY21wTWV0YS4kdGFnTmFtZSQ7XG4gICAgICAgICAgICBjb25zdCBIb3N0RWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICAgICAgICAgIC8vIFN0ZW5jaWxMYXp5SG9zdFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBzdXBlcihzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVySG9zdChzZWxmLCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIENNUF9GTEFHUy5zaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBpcyB1c2luZyBzaGFkb3cgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhpcyBicm93c2VyIHN1cHBvcnRzIHNoYWRvdyBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgcmVhZC1vbmx5IHByb3BlcnR5IFwic2hhZG93Um9vdFwiIHRvIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGluZyB0aGUgc2hhZG93IHJvb3QgYnVpbGQgY29uZGl0aW9uYWxzIHRvIG1pbmltaXplIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1NoYWRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEZWxlZ2F0ZXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmF0dGFjaFNoYWRvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiAnb3BlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZXNGb2N1czogISEoY21wTWV0YS4kZmxhZ3MkICYgMTYgLyogQ01QX0ZMQUdTLnNoYWRvd0RlbGVnYXRlc0ZvY3VzICovKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgISgnc2hhZG93Um9vdCcgaW4gc2VsZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNoYWRvd1Jvb3QgPSBzZWxmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zbG90Q2hpbGROb2Rlc0ZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hDaGlsZFNsb3ROb2RlcyhzZWxmLCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcExvYWRGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFwcExvYWRGYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBMb2FkRmFsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jvb3RzdHJhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3RlZENhbGxiYWNrIHdpbGwgYmUgcHJvY2Vzc2VkIG9uY2UgYWxsIGNvbXBvbmVudHMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbHQuam1wKCgpID0+IGNvbm5lY3RlZENhbGxiYWNrKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx0LmptcCgoKSA9PiBkaXNjb25uZWN0ZWRDYWxsYmFjayh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE9uUmVhZHkoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRIb3N0UmVmKHRoaXMpLiRvblJlYWR5UHJvbWlzZSQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5jbG9uZU5vZGVGaXgpIHtcbiAgICAgICAgICAgICAgICBwYXRjaENsb25lTm9kZShIb3N0RWxlbWVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmFwcGVuZENoaWxkU2xvdEZpeCkge1xuICAgICAgICAgICAgICAgIHBhdGNoU2xvdEFwcGVuZENoaWxkKEhvc3RFbGVtZW50LnByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBIb3N0RWxlbWVudC5wcm90b3R5cGVbJ3MtaG1yJ10gPSBmdW5jdGlvbiAoaG1yVmVyc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhtclN0YXJ0KHRoaXMsIGNtcE1ldGEsIGhtclZlcnNpb25JZCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5zY29wZWRTbG90VGV4dENvbnRlbnRGaXgpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFRleHRDb250ZW50KEhvc3RFbGVtZW50LnByb3RvdHlwZSwgY21wTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbXBNZXRhLiRsYXp5QnVuZGxlSWQkID0gbGF6eUJ1bmRsZVswXTtcbiAgICAgICAgICAgIGlmICghZXhjbHVkZS5pbmNsdWRlcyh0YWdOYW1lKSAmJiAhY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgY21wVGFncy5wdXNoKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBwcm94eUNvbXBvbmVudChIb3N0RWxlbWVudCwgY21wTWV0YSwgMSAvKiBQUk9YWV9GTEFHUy5pc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoQlVJTEQuaW52aXNpYmxlUHJlaHlkcmF0aW9uICYmIChCVUlMRC5oeWRyYXRlZENsYXNzIHx8IEJVSUxELmh5ZHJhdGVkQXR0cmlidXRlKSkge1xuICAgICAgICB2aXNpYmlsaXR5U3R5bGUuaW5uZXJIVE1MID0gY21wVGFncyArIEhZRFJBVEVEX0NTUztcbiAgICAgICAgdmlzaWJpbGl0eVN0eWxlLnNldEF0dHJpYnV0ZSgnZGF0YS1zdHlsZXMnLCAnJyk7XG4gICAgICAgIC8vIEFwcGx5IENTUCBub25jZSB0byB0aGUgc3R5bGUgdGFnIGlmIGl0IGV4aXN0c1xuICAgICAgICBjb25zdCBub25jZSA9IChfYSA9IHBsdC4kbm9uY2UkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBxdWVyeU5vbmNlTWV0YVRhZ0NvbnRlbnQoZG9jKTtcbiAgICAgICAgaWYgKG5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZpc2liaWxpdHlTdHlsZS5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICAgICAgICB9XG4gICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHZpc2liaWxpdHlTdHlsZSwgbWV0YUNoYXJzZXQgPyBtZXRhQ2hhcnNldC5uZXh0U2libGluZyA6IGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgZGVmZXJyZWQgY29ubmVjdGVkQ2FsbGJhY2tzIG5vdyBhbGwgY29tcG9uZW50cyBoYXZlIGJlZW4gcmVnaXN0ZXJlZFxuICAgIGlzQm9vdHN0cmFwcGluZyA9IGZhbHNlO1xuICAgIGlmIChkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MubWFwKChob3N0KSA9PiBob3N0LmNvbm5lY3RlZENhbGxiYWNrKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKEJVSUxELnByb2ZpbGUpIHtcbiAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4gKGFwcExvYWRGYWxsYmFjayA9IHNldFRpbWVvdXQoYXBwRGlkTG9hZCwgMzAsICd0aW1lb3V0JykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4gKGFwcExvYWRGYWxsYmFjayA9IHNldFRpbWVvdXQoYXBwRGlkTG9hZCwgMzApKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgYXBwTG9hZCBldmVudFxuICAgIGVuZEJvb3RzdHJhcCgpO1xufTtcbmNvbnN0IGdldENvbm5lY3QgPSAoX3JlZiwgdGFnTmFtZSkgPT4ge1xuICAgIGNvbnN0IGNvbXBvbmVudE9uUmVhZHkgPSAoKSA9PiB7XG4gICAgICAgIGxldCBlbG0gPSBkb2MucXVlcnlTZWxlY3Rvcih0YWdOYW1lKTtcbiAgICAgICAgaWYgKCFlbG0pIHtcbiAgICAgICAgICAgIGVsbSA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGVsbS5jb21wb25lbnRPblJlYWR5ID09PSAnZnVuY3Rpb24nID8gZWxtLmNvbXBvbmVudE9uUmVhZHkoKSA6IFByb21pc2UucmVzb2x2ZShlbG0pO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudE9uUmVhZHkoKS50aGVuKChlbCkgPT4gZWwuY3JlYXRlKC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgY29tcG9uZW50T25SZWFkeSxcbiAgICB9O1xufTtcbmNvbnN0IGdldENvbnRleHQgPSAoX2VsbSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChjb250ZXh0IGluIENvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRbY29udGV4dF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICd3aW5kb3cnKSB7XG4gICAgICAgIHJldHVybiB3aW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lzU2VydmVyJyB8fCBjb250ZXh0ID09PSAnaXNQcmVyZW5kZXInKSB7XG4gICAgICAgIHJldHVybiBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lzQ2xpZW50Jykge1xuICAgICAgICByZXR1cm4gQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdyZXNvdXJjZXNVcmwnIHx8IGNvbnRleHQgPT09ICdwdWJsaWNQYXRoJykge1xuICAgICAgICByZXR1cm4gZ2V0QXNzZXRQYXRoKCcuJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdxdWV1ZScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdyaXRlOiB3cml0ZVRhc2ssXG4gICAgICAgICAgICByZWFkOiByZWFkVGFzayxcbiAgICAgICAgICAgIHRpY2s6IHtcbiAgICAgICAgICAgICAgICB0aGVuKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VGljayhjYik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgRnJhZ21lbnQgPSAoXywgY2hpbGRyZW4pID0+IGNoaWxkcmVuO1xuY29uc3QgYWRkSG9zdEV2ZW50TGlzdGVuZXJzID0gKGVsbSwgaG9zdFJlZiwgbGlzdGVuZXJzLCBhdHRhY2hQYXJlbnRMaXN0ZW5lcnMpID0+IHtcbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyICYmIGxpc3RlbmVycykge1xuICAgICAgICAvLyB0aGlzIGlzIGNhbGxlZCBpbW1lZGlhdGVseSB3aXRoaW4gdGhlIGVsZW1lbnQncyBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBpbml0aWFsaXplIG91ciBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAvLyB3ZSBkbyB0aGlzIG5vdyBzbyB0aGF0IHdlIGNhbiBsaXN0ZW4gdG8gZXZlbnRzIHRoYXQgbWF5XG4gICAgICAgIC8vIGhhdmUgZmlyZWQgZXZlbiBiZWZvcmUgdGhlIGluc3RhbmNlIGlzIHJlYWR5XG4gICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IG1heSBoYXZlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICBpZiAoYXR0YWNoUGFyZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWluZyByYW4gZnJvbSB3aXRoaW4gdGhlIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgaW1wb3J0YW50IHNvIHRoYXQgd2Uga25vdyB0aGUgaG9zdCBlbGVtZW50IGFjdHVhbGx5IGhhcyBhIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0aGUgbGlzdGVuZXJzIHRvIG9ubHkgaGF2ZSB0aGUgb25lcyB0aGF0IEFSRSBiZWluZyBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcigoW2ZsYWdzXSkgPT4gZmxhZ3MgJiAzMiAvKiBMSVNURU5FUl9GTEFHUy5UYXJnZXRQYXJlbnQgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWluZyByYW4gZnJvbSB3aXRoaW4gdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgQlVUIHRoZSBwYXJlbnQgZWxlbWVudCBsaXN0ZW5lcnMgc2hvdWxkIGJlIGF0dGFjaGVkIGF0IHRoaXMgdGltZVxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgdGhlIGxpc3RlbmVycyB0aGF0IGFyZSBOT1QgYmVpbmcgYXR0YWNoZWQgdG8gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoKFtmbGFnc10pID0+ICEoZmxhZ3MgJiAzMiAvKiBMSVNURU5FUl9GTEFHUy5UYXJnZXRQYXJlbnQgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMubWFwKChbZmxhZ3MsIG5hbWUsIG1ldGhvZF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldCA/IGdldEhvc3RMaXN0ZW5lclRhcmdldChlbG0sIGZsYWdzKSA6IGVsbTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBob3N0TGlzdGVuZXJQcm94eShob3N0UmVmLCBtZXRob2QpO1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IGhvc3RMaXN0ZW5lck9wdHMoZmxhZ3MpO1xuICAgICAgICAgICAgcGx0LmFlbCh0YXJnZXQsIG5hbWUsIGhhbmRsZXIsIG9wdHMpO1xuICAgICAgICAgICAgKGhvc3RSZWYuJHJtTGlzdGVuZXJzJCA9IGhvc3RSZWYuJHJtTGlzdGVuZXJzJCB8fCBbXSkucHVzaCgoKSA9PiBwbHQucmVsKHRhcmdldCwgbmFtZSwgaGFuZGxlciwgb3B0cykpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgaG9zdExpc3RlbmVyUHJveHkgPSAoaG9zdFJlZiwgbWV0aG9kTmFtZSkgPT4gKGV2KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMjU2IC8qIEhPU1RfRkxBR1MuaXNMaXN0ZW5SZWFkeSAqLykge1xuICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlIGlzIHJlYWR5LCBsZXQncyBjYWxsIGl0J3MgbWVtYmVyIG1ldGhvZCBmb3IgdGhpcyBldmVudFxuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGxhenlJbnN0YW5jZSRbbWV0aG9kTmFtZV0oZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQgPSBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkIHx8IFtdKS5wdXNoKFttZXRob2ROYW1lLCBldl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9zdFJlZi4kaG9zdEVsZW1lbnQkW21ldGhvZE5hbWVdKGV2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgfVxufTtcbmNvbnN0IGdldEhvc3RMaXN0ZW5lclRhcmdldCA9IChlbG0sIGZsYWdzKSA9PiB7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldERvY3VtZW50ICYmIGZsYWdzICYgNCAvKiBMSVNURU5FUl9GTEFHUy5UYXJnZXREb2N1bWVudCAqLylcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyVGFyZ2V0V2luZG93ICYmIGZsYWdzICYgOCAvKiBMSVNURU5FUl9GTEFHUy5UYXJnZXRXaW5kb3cgKi8pXG4gICAgICAgIHJldHVybiB3aW47XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldEJvZHkgJiYgZmxhZ3MgJiAxNiAvKiBMSVNURU5FUl9GTEFHUy5UYXJnZXRCb2R5ICovKVxuICAgICAgICByZXR1cm4gZG9jLmJvZHk7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFBhcmVudCAmJiBmbGFncyAmIDMyIC8qIExJU1RFTkVSX0ZMQUdTLlRhcmdldFBhcmVudCAqLylcbiAgICAgICAgcmV0dXJuIGVsbS5wYXJlbnRFbGVtZW50O1xuICAgIHJldHVybiBlbG07XG59O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBob3N0TGlzdGVuZXJPcHRzID0gKGZsYWdzKSA9PiBzdXBwb3J0c0xpc3RlbmVyT3B0aW9uc1xuICAgID8gKHtcbiAgICAgICAgcGFzc2l2ZTogKGZsYWdzICYgMSAvKiBMSVNURU5FUl9GTEFHUy5QYXNzaXZlICovKSAhPT0gMCxcbiAgICAgICAgY2FwdHVyZTogKGZsYWdzICYgMiAvKiBMSVNURU5FUl9GTEFHUy5DYXB0dXJlICovKSAhPT0gMCxcbiAgICB9KVxuICAgIDogKGZsYWdzICYgMiAvKiBMSVNURU5FUl9GTEFHUy5DYXB0dXJlICovKSAhPT0gMDtcbi8qKlxuICogQXNzaWducyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIG5vbmNlIHByb3BlcnR5IG9uIHRoZSBydW50aW1lIHBsYXRmb3JtIG9iamVjdC5cbiAqIER1cmluZyBydW50aW1lLCB0aGlzIHZhbHVlIGlzIHVzZWQgdG8gc2V0IHRoZSBub25jZSBhdHRyaWJ1dGUgb24gYWxsIGR5bmFtaWNhbGx5IGNyZWF0ZWQgc2NyaXB0IGFuZCBzdHlsZSB0YWdzLlxuICogQHBhcmFtIG5vbmNlIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZCB0byB0aGUgcGxhdGZvcm0gbm9uY2UgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB2b2lkXG4gKi9cbmNvbnN0IHNldE5vbmNlID0gKG5vbmNlKSA9PiAocGx0LiRub25jZSQgPSBub25jZSk7XG5jb25zdCBzZXRQbGF0Zm9ybU9wdGlvbnMgPSAob3B0cykgPT4gT2JqZWN0LmFzc2lnbihwbHQsIG9wdHMpO1xuY29uc3QgaW5zZXJ0VmRvbUFubm90YXRpb25zID0gKGRvYywgc3RhdGljQ29tcG9uZW50cykgPT4ge1xuICAgIGlmIChkb2MgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkb2NEYXRhID0ge1xuICAgICAgICAgICAgaG9zdElkczogMCxcbiAgICAgICAgICAgIHJvb3RMZXZlbElkczogMCxcbiAgICAgICAgICAgIHN0YXRpY0NvbXBvbmVudHM6IG5ldyBTZXQoc3RhdGljQ29tcG9uZW50cyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgcGFyc2VWTm9kZUFubm90YXRpb25zKGRvYywgZG9jLmJvZHksIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpO1xuICAgICAgICBvcmdMb2NhdGlvbk5vZGVzLmZvckVhY2goKG9yZ0xvY2F0aW9uTm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlZiA9IG9yZ0xvY2F0aW9uTm9kZVsncy1uciddO1xuICAgICAgICAgICAgICAgIGxldCBob3N0SWQgPSBub2RlUmVmWydzLWhvc3QtaWQnXTtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZUlkID0gbm9kZVJlZlsncy1ub2RlLWlkJ107XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkSWQgPSBgJHtob3N0SWR9LiR7bm9kZUlkfWA7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RJZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRvY0RhdGEucm9vdExldmVsSWRzKys7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCA9IGRvY0RhdGEucm9vdExldmVsSWRzO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZElkID0gYCR7aG9zdElkfS4ke25vZGVJZH1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVJlZi5ub2RlVHlwZSA9PT0gMSAvKiBOT0RFX1RZUEUuRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVSZWYuc2V0QXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQsIGNoaWxkSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVSZWYubm9kZVR5cGUgPT09IDMgLyogTk9ERV9UWVBFLlRleHROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdElkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBub2RlUmVmLm5vZGVWYWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRDb250ZW50ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VsZXNzIHdoaXRlc3BhY2Ugbm9kZSBhdCB0aGUgZG9jdW1lbnQgcm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50QmVmb3JlVGV4dE5vZGUgPSBkb2MuY3JlYXRlQ29tbWVudChjaGlsZElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRCZWZvcmVUZXh0Tm9kZS5ub2RlVmFsdWUgPSBgJHtURVhUX05PREVfSUR9LiR7Y2hpbGRJZH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlZi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjb21tZW50QmVmb3JlVGV4dE5vZGUsIG5vZGVSZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBvcmdMb2NhdGlvbk5vZGVJZCA9IGAke09SR19MT0NBVElPTl9JRH0uJHtjaGlsZElkfWA7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25QYXJlbnROb2RlID0gb3JnTG9jYXRpb25Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uUGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JnTG9jYXRpb25QYXJlbnROb2RlWydzLWVuJ10gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmRpbmcgd2l0aCBhIFwiLlwiIG1lYW5zIHRoYXQgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGlzIG5vZGUncyBvcmlnaW5hbCBsb2NhdGlvbiBpcyBhIFNIQURPVyBkb20gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoaXMgbm9kZSBpcyBhcGFydCBvZiB0aGUgcm9vdCBsZXZlbCBsaWdodCBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZUlkICs9IGAuYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcmdMb2NhdGlvblBhcmVudE5vZGVbJ3MtZW4nXSA9PT0gJ2MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmRpbmcgd2l0aCBhIFwiLmNcIiBtZWFucyB0aGF0IHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhpcyBub2RlJ3Mgb3JpZ2luYWwgbG9jYXRpb24gaXMgYSBTQ09QRUQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoaXMgbm9kZSBpcyBhcGFydCBvZiB0aGUgcm9vdCBsZXZlbCBsaWdodCBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZUlkICs9IGAuY2A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlLm5vZGVWYWx1ZSA9IG9yZ0xvY2F0aW9uTm9kZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgcGFyc2VWTm9kZUFubm90YXRpb25zID0gKGRvYywgbm9kZSwgZG9jRGF0YSwgb3JnTG9jYXRpb25Ob2RlcykgPT4ge1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobm9kZVsncy1uciddICE9IG51bGwpIHtcbiAgICAgICAgb3JnTG9jYXRpb25Ob2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBOT0RFX1RZUEUuRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoY2hpbGROb2RlKTtcbiAgICAgICAgICAgIGlmIChob3N0UmVmICE9IG51bGwgJiYgIWRvY0RhdGEuc3RhdGljQ29tcG9uZW50cy5oYXMoY2hpbGROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY21wRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkczogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGluc2VydFZOb2RlQW5ub3RhdGlvbnMoZG9jLCBjaGlsZE5vZGUsIGhvc3RSZWYuJHZub2RlJCwgZG9jRGF0YSwgY21wRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZVZOb2RlQW5ub3RhdGlvbnMoZG9jLCBjaGlsZE5vZGUsIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgaW5zZXJ0Vk5vZGVBbm5vdGF0aW9ucyA9IChkb2MsIGhvc3RFbG0sIHZub2RlLCBkb2NEYXRhLCBjbXBEYXRhKSA9PiB7XG4gICAgaWYgKHZub2RlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgaG9zdElkID0gKytkb2NEYXRhLmhvc3RJZHM7XG4gICAgICAgIGhvc3RFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVfSUQsIGhvc3RJZCk7XG4gICAgICAgIGlmIChob3N0RWxtWydzLWNyJ10gIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9zdEVsbVsncy1jciddLm5vZGVWYWx1ZSA9IGAke0NPTlRFTlRfUkVGX0lEfS4ke2hvc3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZS4kY2hpbGRyZW4kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcHRoID0gMDtcbiAgICAgICAgICAgIHZub2RlLiRjaGlsZHJlbiQuZm9yRWFjaCgodm5vZGVDaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpbnNlcnRDaGlsZFZOb2RlQW5ub3RhdGlvbnMoZG9jLCB2bm9kZUNoaWxkLCBjbXBEYXRhLCBob3N0SWQsIGRlcHRoLCBpbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdEVsbSAmJiB2bm9kZSAmJiB2bm9kZS4kZWxtJCAmJiAhaG9zdEVsbS5oYXNBdHRyaWJ1dGUoJ2MtaWQnKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gaG9zdEVsbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudENoaWxkTm9kZXMgPSBBcnJheS5mcm9tKHBhcmVudC5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gcGFyZW50Q2hpbGROb2Rlcy5maW5kKChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIE5PREVfVFlQRS5Db21tZW50Tm9kZSAqLyAmJiBub2RlWydzLXNyJ10pO1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50Q2hpbGROb2Rlcy5pbmRleE9mKGhvc3RFbG0pIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuJGVsbSQuc2V0QXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQsIGAke2NvbW1lbnRbJ3MtaG9zdC1pZCddfS4ke2NvbW1lbnRbJ3Mtbm9kZS1pZCddfS4wLiR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGluc2VydENoaWxkVk5vZGVBbm5vdGF0aW9ucyA9IChkb2MsIHZub2RlQ2hpbGQsIGNtcERhdGEsIGhvc3RJZCwgZGVwdGgsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgY2hpbGRFbG0gPSB2bm9kZUNoaWxkLiRlbG0kO1xuICAgIGlmIChjaGlsZEVsbSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9kZUlkID0gY21wRGF0YS5ub2RlSWRzKys7XG4gICAgY29uc3QgY2hpbGRJZCA9IGAke2hvc3RJZH0uJHtub2RlSWR9LiR7ZGVwdGh9LiR7aW5kZXh9YDtcbiAgICBjaGlsZEVsbVsncy1ob3N0LWlkJ10gPSBob3N0SWQ7XG4gICAgY2hpbGRFbG1bJ3Mtbm9kZS1pZCddID0gbm9kZUlkO1xuICAgIGlmIChjaGlsZEVsbS5ub2RlVHlwZSA9PT0gMSAvKiBOT0RFX1RZUEUuRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY2hpbGRFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQsIGNoaWxkSWQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZEVsbS5ub2RlVHlwZSA9PT0gMyAvKiBOT0RFX1RZUEUuVGV4dE5vZGUgKi8pIHtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNoaWxkRWxtLnBhcmVudE5vZGU7XG4gICAgICAgIGNvbnN0IG5vZGVOYW1lID0gcGFyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICAgICAgaWYgKG5vZGVOYW1lICE9PSAnU1RZTEUnICYmIG5vZGVOYW1lICE9PSAnU0NSSVBUJykge1xuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGVJZCA9IGAke1RFWFRfTk9ERV9JRH0uJHtjaGlsZElkfWA7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50QmVmb3JlVGV4dE5vZGUgPSBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0Tm9kZUlkKTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSwgY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoaWxkRWxtLm5vZGVUeXBlID09PSA4IC8qIE5PREVfVFlQRS5Db21tZW50Tm9kZSAqLykge1xuICAgICAgICBpZiAoY2hpbGRFbG1bJ3Mtc3InXSkge1xuICAgICAgICAgICAgY29uc3Qgc2xvdE5hbWUgPSBjaGlsZEVsbVsncy1zbiddIHx8ICcnO1xuICAgICAgICAgICAgY29uc3Qgc2xvdE5vZGVJZCA9IGAke1NMT1RfTk9ERV9JRH0uJHtjaGlsZElkfS4ke3Nsb3ROYW1lfWA7XG4gICAgICAgICAgICBjaGlsZEVsbS5ub2RlVmFsdWUgPSBzbG90Tm9kZUlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2bm9kZUNoaWxkLiRjaGlsZHJlbiQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjaGlsZERlcHRoID0gZGVwdGggKyAxO1xuICAgICAgICB2bm9kZUNoaWxkLiRjaGlsZHJlbiQuZm9yRWFjaCgodm5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpbnNlcnRDaGlsZFZOb2RlQW5ub3RhdGlvbnMoZG9jLCB2bm9kZSwgY21wRGF0YSwgaG9zdElkLCBjaGlsZERlcHRoLCBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBob3N0UmVmcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGdldEhvc3RSZWYgPSAocmVmKSA9PiBob3N0UmVmcy5nZXQocmVmKTtcbmNvbnN0IHJlZ2lzdGVySW5zdGFuY2UgPSAobGF6eUluc3RhbmNlLCBob3N0UmVmKSA9PiBob3N0UmVmcy5zZXQoKGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgPSBsYXp5SW5zdGFuY2UpLCBob3N0UmVmKTtcbmNvbnN0IHJlZ2lzdGVySG9zdCA9IChlbG0sIGNtcE1ldGEpID0+IHtcbiAgICBjb25zdCBob3N0UmVmID0ge1xuICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAkaG9zdEVsZW1lbnQkOiBlbG0sXG4gICAgICAgICRjbXBNZXRhJDogY21wTWV0YSxcbiAgICAgICAgJGluc3RhbmNlVmFsdWVzJDogbmV3IE1hcCgpLFxuICAgIH07XG4gICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgIGhvc3RSZWYuJHJlbmRlckNvdW50JCA9IDA7XG4gICAgfVxuICAgIGlmIChCVUlMRC5tZXRob2QgJiYgQlVJTEQubGF6eUxvYWQpIHtcbiAgICAgICAgaG9zdFJlZi4kb25JbnN0YW5jZVByb21pc2UkID0gbmV3IFByb21pc2UoKHIpID0+IChob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQgPSByKSk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgaG9zdFJlZi4kb25SZWFkeVByb21pc2UkID0gbmV3IFByb21pc2UoKHIpID0+IChob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQgPSByKSk7XG4gICAgICAgIGVsbVsncy1wJ10gPSBbXTtcbiAgICAgICAgZWxtWydzLXJjJ10gPSBbXTtcbiAgICB9XG4gICAgYWRkSG9zdEV2ZW50TGlzdGVuZXJzKGVsbSwgaG9zdFJlZiwgY21wTWV0YS4kbGlzdGVuZXJzJCwgZmFsc2UpO1xuICAgIHJldHVybiBob3N0UmVmcy5zZXQoZWxtLCBob3N0UmVmKTtcbn07XG5jb25zdCBpc01lbWJlckluRWxlbWVudCA9IChlbG0sIG1lbWJlck5hbWUpID0+IG1lbWJlck5hbWUgaW4gZWxtO1xuY29uc3QgY29uc29sZUVycm9yID0gKGUsIGVsKSA9PiAoY3VzdG9tRXJyb3IgfHwgY29uc29sZS5lcnJvcikoZSwgZWwpO1xuY29uc3QgU1RFTkNJTF9ERVZfTU9ERSA9IEJVSUxELmlzVGVzdGluZ1xuICAgID8gWydTVEVOQ0lMOiddIC8vIEUyRSB0ZXN0aW5nXG4gICAgOiBbXG4gICAgICAgICclY3N0ZW5jaWwnLFxuICAgICAgICAnY29sb3I6IHdoaXRlO2JhY2tncm91bmQ6IzRjNDdmZjtmb250LXdlaWdodDogYm9sZDsgZm9udC1zaXplOjEwcHg7IHBhZGRpbmc6MnB4IDZweDsgYm9yZGVyLXJhZGl1czogNXB4JyxcbiAgICBdO1xuY29uc3QgY29uc29sZURldkVycm9yID0gKC4uLm0pID0+IGNvbnNvbGUuZXJyb3IoLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG5jb25zdCBjb25zb2xlRGV2V2FybiA9ICguLi5tKSA9PiBjb25zb2xlLndhcm4oLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG5jb25zdCBjb25zb2xlRGV2SW5mbyA9ICguLi5tKSA9PiBjb25zb2xlLmluZm8oLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG5jb25zdCBzZXRFcnJvckhhbmRsZXIgPSAoaGFuZGxlcikgPT4gKGN1c3RvbUVycm9yID0gaGFuZGxlcik7XG5jb25zdCBjbXBNb2R1bGVzID0gLypAX19QVVJFX18qLyBuZXcgTWFwKCk7XG5jb25zdCBsb2FkTW9kdWxlID0gKGNtcE1ldGEsIGhvc3RSZWYsIGhtclZlcnNpb25JZCkgPT4ge1xuICAgIC8vIGxvYWRNb2R1bGVJbXBvcnRcbiAgICBjb25zdCBleHBvcnROYW1lID0gY21wTWV0YS4kdGFnTmFtZSQucmVwbGFjZSgvLS9nLCAnXycpO1xuICAgIGNvbnN0IGJ1bmRsZUlkID0gY21wTWV0YS4kbGF6eUJ1bmRsZUlkJDtcbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgdHlwZW9mIGJ1bmRsZUlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRyeWluZyB0byBsYXppbHkgbG9hZCBjb21wb25lbnQgPCR7Y21wTWV0YS4kdGFnTmFtZSR9PiB3aXRoIHN0eWxlIG1vZGUgXCIke2hvc3RSZWYuJG1vZGVOYW1lJH1cIiwgYnV0IGl0IGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBtb2R1bGUgPSAhQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQgPyBjbXBNb2R1bGVzLmdldChidW5kbGVJZCkgOiBmYWxzZTtcbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGVbZXhwb3J0TmFtZV07XG4gICAgfVxuICAgIC8qIV9fU1RFTkNJTF9TVEFUSUNfSU1QT1JUX1NXSVRDSF9fKi9cbiAgICByZXR1cm4gaW1wb3J0KFxuICAgIC8qIEB2aXRlLWlnbm9yZSAqL1xuICAgIC8qIHdlYnBhY2tJbmNsdWRlOiAvXFwuZW50cnlcXC5qcyQvICovXG4gICAgLyogd2VicGFja0V4Y2x1ZGU6IC9cXC5zeXN0ZW1cXC5lbnRyeVxcLmpzJC8gKi9cbiAgICAvKiB3ZWJwYWNrTW9kZTogXCJsYXp5XCIgKi9cbiAgICBgLi8ke2J1bmRsZUlkfS5lbnRyeS5qcyR7QlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQgJiYgaG1yVmVyc2lvbklkID8gJz9zLWhtcj0nICsgaG1yVmVyc2lvbklkIDogJyd9YCkudGhlbigoaW1wb3J0ZWRNb2R1bGUpID0+IHtcbiAgICAgICAgaWYgKCFCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgY21wTW9kdWxlcy5zZXQoYnVuZGxlSWQsIGltcG9ydGVkTW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1wb3J0ZWRNb2R1bGVbZXhwb3J0TmFtZV07XG4gICAgfSwgY29uc29sZUVycm9yKTtcbn07XG5jb25zdCBzdHlsZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXAoKTtcbmNvbnN0IG1vZGVSZXNvbHV0aW9uQ2hhaW4gPSBbXTtcbmNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG5jb25zdCBDU1MgPSBCVUlMRC5jc3NWYXJTaGltID8gd2luLkNTUyA6IG51bGw7XG5jb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQgfHwgeyBoZWFkOiB7fSB9O1xuY29uc3QgSCA9ICh3aW4uSFRNTEVsZW1lbnQgfHwgY2xhc3Mge1xufSk7XG5jb25zdCBwbHQgPSB7XG4gICAgJGZsYWdzJDogMCxcbiAgICAkcmVzb3VyY2VzVXJsJDogJycsXG4gICAgam1wOiAoaCkgPT4gaCgpLFxuICAgIHJhZjogKGgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShoKSxcbiAgICBhZWw6IChlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cykgPT4gZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRzKSxcbiAgICByZWw6IChlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cykgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRzKSxcbiAgICBjZTogKGV2ZW50TmFtZSwgb3B0cykgPT4gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgb3B0cyksXG59O1xuY29uc3Qgc2V0UGxhdGZvcm1IZWxwZXJzID0gKGhlbHBlcnMpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKHBsdCwgaGVscGVycyk7XG59O1xuY29uc3Qgc3VwcG9ydHNTaGFkb3cgPSBCVUlMRC5zaGFkb3dEb21TaGltICYmIEJVSUxELnNoYWRvd0RvbVxuICAgID8gLypAX19QVVJFX18qLyAoKCkgPT4gKGRvYy5oZWFkLmF0dGFjaFNoYWRvdyArICcnKS5pbmRleE9mKCdbbmF0aXZlJykgPiAtMSkoKVxuICAgIDogdHJ1ZTtcbmNvbnN0IHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zID0gLypAX19QVVJFX18qLyAoKCkgPT4ge1xuICAgIGxldCBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdlJywgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICByZXR1cm4gc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnM7XG59KSgpO1xuY29uc3QgcHJvbWlzZVJlc29sdmUgPSAodikgPT4gUHJvbWlzZS5yZXNvbHZlKHYpO1xuY29uc3Qgc3VwcG9ydHNDb25zdHJ1Y3RhYmxlU3R5bGVzaGVldHMgPSBCVUlMRC5jb25zdHJ1Y3RhYmxlQ1NTXG4gICAgPyAvKkBfX1BVUkVfXyovICgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBuZXcgQ1NTU3R5bGVTaGVldCgpLnJlcGxhY2VTeW5jID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pKClcbiAgICA6IGZhbHNlO1xuY29uc3QgcXVldWVEb21SZWFkcyA9IFtdO1xuY29uc3QgcXVldWVEb21Xcml0ZXMgPSBbXTtcbmNvbnN0IHF1ZXVlRG9tV3JpdGVzTG93ID0gW107XG5jb25zdCBxdWV1ZVRhc2sgPSAocXVldWUsIHdyaXRlKSA9PiAoY2IpID0+IHtcbiAgICBxdWV1ZS5wdXNoKGNiKTtcbiAgICBpZiAoIXF1ZXVlUGVuZGluZykge1xuICAgICAgICBxdWV1ZVBlbmRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAod3JpdGUgJiYgcGx0LiRmbGFncyQgJiA0IC8qIFBMQVRGT1JNX0ZMQUdTLnF1ZXVlU3luYyAqLykge1xuICAgICAgICAgICAgbmV4dFRpY2soZmx1c2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGx0LnJhZihmbHVzaCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgY29uc3VtZSA9IChxdWV1ZSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHF1ZXVlW2ldKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG59O1xuY29uc3QgY29uc3VtZVRpbWVvdXQgPSAocXVldWUsIHRpbWVvdXQpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IHRzID0gMDtcbiAgICB3aGlsZSAoaSA8IHF1ZXVlLmxlbmd0aCAmJiAodHMgPSBwZXJmb3JtYW5jZS5ub3coKSkgPCB0aW1lb3V0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBxdWV1ZVtpKytdKHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaSAhPT0gMCkge1xuICAgICAgICBxdWV1ZS5zcGxpY2UoMCwgaSk7XG4gICAgfVxufTtcbmNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICAgIGlmIChCVUlMRC5hc3luY1F1ZXVlKSB7XG4gICAgICAgIHF1ZXVlQ29uZ2VzdGlvbisrO1xuICAgIH1cbiAgICAvLyBhbHdheXMgZm9yY2UgYSBidW5jaCBvZiBtZWRpdW0gY2FsbGJhY2tzIHRvIHJ1biwgYnV0IHN0aWxsIGhhdmVcbiAgICAvLyBhIHRocm90dGxlIG9uIGhvdyBtYW55IGNhbiBydW4gaW4gYSBjZXJ0YWluIHRpbWVcbiAgICAvLyBET00gUkVBRFMhISFcbiAgICBjb25zdW1lKHF1ZXVlRG9tUmVhZHMpO1xuICAgIC8vIERPTSBXUklURVMhISFcbiAgICBpZiAoQlVJTEQuYXN5bmNRdWV1ZSkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gKHBsdC4kZmxhZ3MkICYgNiAvKiBQTEFURk9STV9GTEFHUy5xdWV1ZU1hc2sgKi8pID09PSAyIC8qIFBMQVRGT1JNX0ZMQUdTLmFwcExvYWRlZCAqL1xuICAgICAgICAgICAgPyBwZXJmb3JtYW5jZS5ub3coKSArIDE0ICogTWF0aC5jZWlsKHF1ZXVlQ29uZ2VzdGlvbiAqICgxLjAgLyAxMC4wKSlcbiAgICAgICAgICAgIDogSW5maW5pdHk7XG4gICAgICAgIGNvbnN1bWVUaW1lb3V0KHF1ZXVlRG9tV3JpdGVzLCB0aW1lb3V0KTtcbiAgICAgICAgY29uc3VtZVRpbWVvdXQocXVldWVEb21Xcml0ZXNMb3csIHRpbWVvdXQpO1xuICAgICAgICBpZiAocXVldWVEb21Xcml0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcXVldWVEb21Xcml0ZXNMb3cucHVzaCguLi5xdWV1ZURvbVdyaXRlcyk7XG4gICAgICAgICAgICBxdWV1ZURvbVdyaXRlcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocXVldWVQZW5kaW5nID0gcXVldWVEb21SZWFkcy5sZW5ndGggKyBxdWV1ZURvbVdyaXRlcy5sZW5ndGggKyBxdWV1ZURvbVdyaXRlc0xvdy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgLy8gc3RpbGwgbW9yZSB0byBkbyB5ZXQsIGJ1dCB3ZSd2ZSBydW4gb3V0IG9mIHRpbWVcbiAgICAgICAgICAgIC8vIGxldCdzIGxldCB0aGlzIHRoaW5nIGNvb2wgb2ZmIGFuZCB0cnkgYWdhaW4gaW4gdGhlIG5leHQgdGlja1xuICAgICAgICAgICAgcGx0LnJhZihmbHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZUNvbmdlc3Rpb24gPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdW1lKHF1ZXVlRG9tV3JpdGVzKTtcbiAgICAgICAgaWYgKChxdWV1ZVBlbmRpbmcgPSBxdWV1ZURvbVJlYWRzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAvLyBzdGlsbCBtb3JlIHRvIGRvIHlldCwgYnV0IHdlJ3ZlIHJ1biBvdXQgb2YgdGltZVxuICAgICAgICAgICAgLy8gbGV0J3MgbGV0IHRoaXMgdGhpbmcgY29vbCBvZmYgYW5kIHRyeSBhZ2FpbiBpbiB0aGUgbmV4dCB0aWNrXG4gICAgICAgICAgICBwbHQucmFmKGZsdXNoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBuZXh0VGljayA9IC8qQF9fUFVSRV9fKi8gKGNiKSA9PiBwcm9taXNlUmVzb2x2ZSgpLnRoZW4oY2IpO1xuY29uc3QgcmVhZFRhc2sgPSAvKkBfX1BVUkVfXyovIHF1ZXVlVGFzayhxdWV1ZURvbVJlYWRzLCBmYWxzZSk7XG5jb25zdCB3cml0ZVRhc2sgPSAvKkBfX1BVUkVfXyovIHF1ZXVlVGFzayhxdWV1ZURvbVdyaXRlcywgdHJ1ZSk7XG5leHBvcnQgeyBCVUlMRCwgRW52LCBOQU1FU1BBQ0UgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhJztcbmV4cG9ydCB7IEJ1aWxkLCBDU1MsIENvbnRleHQsIEZyYWdtZW50LCBILCBIIGFzIEhUTUxFbGVtZW50LCBIb3N0LCBTVEVOQ0lMX0RFVl9NT0RFLCBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMsIGJvb3RzdHJhcExhenksIGNtcE1vZHVsZXMsIGNvbm5lY3RlZENhbGxiYWNrLCBjb25zb2xlRGV2RXJyb3IsIGNvbnNvbGVEZXZJbmZvLCBjb25zb2xlRGV2V2FybiwgY29uc29sZUVycm9yLCBjcmVhdGVFdmVudCwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgZGlzY29ubmVjdGVkQ2FsbGJhY2ssIGRvYywgZm9yY2VNb2RlVXBkYXRlLCBmb3JjZVVwZGF0ZSwgZ2V0QXNzZXRQYXRoLCBnZXRDb25uZWN0LCBnZXRDb250ZXh0LCBnZXRFbGVtZW50LCBnZXRIb3N0UmVmLCBnZXRNb2RlLCBnZXRSZW5kZXJpbmdSZWYsIGdldFZhbHVlLCBoLCBpbnNlcnRWZG9tQW5ub3RhdGlvbnMsIGlzTWVtYmVySW5FbGVtZW50LCBsb2FkTW9kdWxlLCBtb2RlUmVzb2x1dGlvbkNoYWluLCBuZXh0VGljaywgcGFyc2VQcm9wZXJ0eVZhbHVlLCBwbHQsIHBvc3RVcGRhdGVDb21wb25lbnQsIHByb21pc2VSZXNvbHZlLCBwcm94eUNvbXBvbmVudCwgcHJveHlDdXN0b21FbGVtZW50LCByZWFkVGFzaywgcmVnaXN0ZXJIb3N0LCByZWdpc3Rlckluc3RhbmNlLCByZW5kZXJWZG9tLCBzZXRBc3NldFBhdGgsIHNldEVycm9ySGFuZGxlciwgc2V0TW9kZSwgc2V0Tm9uY2UsIHNldFBsYXRmb3JtSGVscGVycywgc2V0UGxhdGZvcm1PcHRpb25zLCBzZXRWYWx1ZSwgc3R5bGVzLCBzdXBwb3J0c0NvbnN0cnVjdGFibGVTdHlsZXNoZWV0cywgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMsIHN1cHBvcnRzU2hhZG93LCB3aW4sIHdyaXRlVGFzayB9O1xuIiwiLyohXG4qIGZvY3VzLXRyYXAgNy40LjNcbiogQGxpY2Vuc2UgTUlULCBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC9mb2N1cy10cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiovXG5pbXBvcnQgeyBpc0ZvY3VzYWJsZSwgdGFiYmFibGUsIGZvY3VzYWJsZSwgaXNUYWJiYWJsZSB9IGZyb20gJ3RhYmJhYmxlJztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbnZhciBhY3RpdmVGb2N1c1RyYXBzID0ge1xuICBhY3RpdmF0ZVRyYXA6IGZ1bmN0aW9uIGFjdGl2YXRlVHJhcCh0cmFwU3RhY2ssIHRyYXApIHtcbiAgICBpZiAodHJhcFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBhY3RpdmVUcmFwID0gdHJhcFN0YWNrW3RyYXBTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChhY3RpdmVUcmFwICE9PSB0cmFwKSB7XG4gICAgICAgIGFjdGl2ZVRyYXAucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRyYXBJbmRleCA9IHRyYXBTdGFjay5pbmRleE9mKHRyYXApO1xuICAgIGlmICh0cmFwSW5kZXggPT09IC0xKSB7XG4gICAgICB0cmFwU3RhY2sucHVzaCh0cmFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbW92ZSB0aGlzIGV4aXN0aW5nIHRyYXAgdG8gdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuICAgICAgdHJhcFN0YWNrLnNwbGljZSh0cmFwSW5kZXgsIDEpO1xuICAgICAgdHJhcFN0YWNrLnB1c2godHJhcCk7XG4gICAgfVxuICB9LFxuICBkZWFjdGl2YXRlVHJhcDogZnVuY3Rpb24gZGVhY3RpdmF0ZVRyYXAodHJhcFN0YWNrLCB0cmFwKSB7XG4gICAgdmFyIHRyYXBJbmRleCA9IHRyYXBTdGFjay5pbmRleE9mKHRyYXApO1xuICAgIGlmICh0cmFwSW5kZXggIT09IC0xKSB7XG4gICAgICB0cmFwU3RhY2suc3BsaWNlKHRyYXBJbmRleCwgMSk7XG4gICAgfVxuICAgIGlmICh0cmFwU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdHJhcFN0YWNrW3RyYXBTdGFjay5sZW5ndGggLSAxXS51bnBhdXNlKCk7XG4gICAgfVxuICB9XG59O1xudmFyIGlzU2VsZWN0YWJsZUlucHV0ID0gZnVuY3Rpb24gaXNTZWxlY3RhYmxlSW5wdXQobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIHR5cGVvZiBub2RlLnNlbGVjdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG52YXIgaXNFc2NhcGVFdmVudCA9IGZ1bmN0aW9uIGlzRXNjYXBlRXZlbnQoZSkge1xuICByZXR1cm4gZS5rZXkgPT09ICdFc2NhcGUnIHx8IGUua2V5ID09PSAnRXNjJyB8fCBlLmtleUNvZGUgPT09IDI3O1xufTtcbnZhciBpc1RhYkV2ZW50ID0gZnVuY3Rpb24gaXNUYWJFdmVudChlKSB7XG4gIHJldHVybiBlLmtleSA9PT0gJ1RhYicgfHwgZS5rZXlDb2RlID09PSA5O1xufTtcblxuLy8gY2hlY2tzIGZvciBUQUIgYnkgZGVmYXVsdFxudmFyIGlzS2V5Rm9yd2FyZCA9IGZ1bmN0aW9uIGlzS2V5Rm9yd2FyZChlKSB7XG4gIHJldHVybiBpc1RhYkV2ZW50KGUpICYmICFlLnNoaWZ0S2V5O1xufTtcblxuLy8gY2hlY2tzIGZvciBTSElGVCtUQUIgYnkgZGVmYXVsdFxudmFyIGlzS2V5QmFja3dhcmQgPSBmdW5jdGlvbiBpc0tleUJhY2t3YXJkKGUpIHtcbiAgcmV0dXJuIGlzVGFiRXZlbnQoZSkgJiYgZS5zaGlmdEtleTtcbn07XG52YXIgZGVsYXkgPSBmdW5jdGlvbiBkZWxheShmbikge1xuICByZXR1cm4gc2V0VGltZW91dChmbiwgMCk7XG59O1xuXG4vLyBBcnJheS5maW5kL2ZpbmRJbmRleCgpIGFyZSBub3Qgc3VwcG9ydGVkIG9uIElFOyB0aGlzIHJlcGxpY2F0ZXMgZW5vdWdoXG4vLyAgb2YgQXJyYXkuZmluZEluZGV4KCkgZm9yIG91ciBuZWVkc1xudmFyIGZpbmRJbmRleCA9IGZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIGZuKSB7XG4gIHZhciBpZHggPSAtMTtcbiAgYXJyLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgIGlmIChmbih2YWx1ZSkpIHtcbiAgICAgIGlkeCA9IGk7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIGJyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7IC8vIG5leHRcbiAgfSk7XG5cbiAgcmV0dXJuIGlkeDtcbn07XG5cbi8qKlxuICogR2V0IGFuIG9wdGlvbidzIHZhbHVlIHdoZW4gaXQgY291bGQgYmUgYSBwbGFpbiB2YWx1ZSwgb3IgYSBoYW5kbGVyIHRoYXQgcHJvdmlkZXNcbiAqICB0aGUgdmFsdWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIE9wdGlvbidzIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHsuLi4qfSBbcGFyYW1zXSBBbnkgcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBoYW5kbGVyLCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Kn0gVGhlIGB2YWx1ZWAsIG9yIHRoZSBoYW5kbGVyJ3MgcmV0dXJuZWQgdmFsdWUuXG4gKi9cbnZhciB2YWx1ZU9ySGFuZGxlciA9IGZ1bmN0aW9uIHZhbHVlT3JIYW5kbGVyKHZhbHVlKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBhcmFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLmFwcGx5KHZvaWQgMCwgcGFyYW1zKSA6IHZhbHVlO1xufTtcbnZhciBnZXRBY3R1YWxUYXJnZXQgPSBmdW5jdGlvbiBnZXRBY3R1YWxUYXJnZXQoZXZlbnQpIHtcbiAgLy8gTk9URTogSWYgdGhlIHRyYXAgaXMgX2luc2lkZV8gYSBzaGFkb3cgRE9NLCBldmVudC50YXJnZXQgd2lsbCBhbHdheXMgYmUgdGhlXG4gIC8vICBzaGFkb3cgaG9zdC4gSG93ZXZlciwgZXZlbnQudGFyZ2V0LmNvbXBvc2VkUGF0aCgpIHdpbGwgYmUgYW4gYXJyYXkgb2ZcbiAgLy8gIG5vZGVzIFwiY2xpY2tlZFwiIGZyb20gaW5uZXItbW9zdCAodGhlIGFjdHVhbCBlbGVtZW50IGluc2lkZSB0aGUgc2hhZG93KSB0b1xuICAvLyAgb3V0ZXItbW9zdCAodGhlIGhvc3QgSFRNTCBkb2N1bWVudCkuIElmIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2VkUGF0aCgpLFxuICAvLyAgdGhlbiB1c2UgaXRzIGZpcnN0IGVsZW1lbnQ7IG90aGVyd2lzZSwgZmFsbCBiYWNrIHRvIGV2ZW50LnRhcmdldCAoYW5kXG4gIC8vICB0aGlzIG9ubHkgd29ya3MgZm9yIGFuIF9vcGVuXyBzaGFkb3cgRE9NOyBvdGhlcndpc2UsXG4gIC8vICBjb21wb3NlZFBhdGgoKVswXSA9PT0gZXZlbnQudGFyZ2V0IGFsd2F5cykuXG4gIHJldHVybiBldmVudC50YXJnZXQuc2hhZG93Um9vdCAmJiB0eXBlb2YgZXZlbnQuY29tcG9zZWRQYXRoID09PSAnZnVuY3Rpb24nID8gZXZlbnQuY29tcG9zZWRQYXRoKClbMF0gOiBldmVudC50YXJnZXQ7XG59O1xuXG4vLyBOT1RFOiB0aGlzIG11c3QgYmUgX291dHNpZGVfIGBjcmVhdGVGb2N1c1RyYXAoKWAgdG8gbWFrZSBzdXJlIGFsbCB0cmFwcyBpbiB0aGlzXG4vLyAgY3VycmVudCBpbnN0YW5jZSB1c2UgdGhlIHNhbWUgc3RhY2sgaWYgYHVzZXJPcHRpb25zLnRyYXBTdGFja2AgaXNuJ3Qgc3BlY2lmaWVkXG52YXIgaW50ZXJuYWxUcmFwU3RhY2sgPSBbXTtcbnZhciBjcmVhdGVGb2N1c1RyYXAgPSBmdW5jdGlvbiBjcmVhdGVGb2N1c1RyYXAoZWxlbWVudHMsIHVzZXJPcHRpb25zKSB7XG4gIC8vIFNTUjogYSBsaXZlIHRyYXAgc2hvdWxkbid0IGJlIGNyZWF0ZWQgaW4gdGhpcyB0eXBlIG9mIGVudmlyb25tZW50IHNvIHRoaXNcbiAgLy8gIHNob3VsZCBiZSBzYWZlIGNvZGUgdG8gZXhlY3V0ZSBpZiB0aGUgYGRvY3VtZW50YCBvcHRpb24gaXNuJ3Qgc3BlY2lmaWVkXG4gIHZhciBkb2MgPSAodXNlck9wdGlvbnMgPT09IG51bGwgfHwgdXNlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXJPcHRpb25zLmRvY3VtZW50KSB8fCBkb2N1bWVudDtcbiAgdmFyIHRyYXBTdGFjayA9ICh1c2VyT3B0aW9ucyA9PT0gbnVsbCB8fCB1c2VyT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlck9wdGlvbnMudHJhcFN0YWNrKSB8fCBpbnRlcm5hbFRyYXBTdGFjaztcbiAgdmFyIGNvbmZpZyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTogdHJ1ZSxcbiAgICBlc2NhcGVEZWFjdGl2YXRlczogdHJ1ZSxcbiAgICBkZWxheUluaXRpYWxGb2N1czogdHJ1ZSxcbiAgICBpc0tleUZvcndhcmQ6IGlzS2V5Rm9yd2FyZCxcbiAgICBpc0tleUJhY2t3YXJkOiBpc0tleUJhY2t3YXJkXG4gIH0sIHVzZXJPcHRpb25zKTtcbiAgdmFyIHN0YXRlID0ge1xuICAgIC8vIGNvbnRhaW5lcnMgZ2l2ZW4gdG8gY3JlYXRlRm9jdXNUcmFwKClcbiAgICAvLyBAdHlwZSB7QXJyYXk8SFRNTEVsZW1lbnQ+fVxuICAgIGNvbnRhaW5lcnM6IFtdLFxuICAgIC8vIGxpc3Qgb2Ygb2JqZWN0cyBpZGVudGlmeWluZyB0YWJiYWJsZSBub2RlcyBpbiBgY29udGFpbmVyc2AgaW4gdGhlIHRyYXBcbiAgICAvLyBOT1RFOiBpdCdzIHBvc3NpYmxlIHRoYXQgYSBncm91cCBoYXMgbm8gdGFiYmFibGUgbm9kZXMgaWYgbm9kZXMgZ2V0IHJlbW92ZWQgd2hpbGUgdGhlIHRyYXBcbiAgICAvLyAgaXMgYWN0aXZlLCBidXQgdGhlIHRyYXAgc2hvdWxkIG5ldmVyIGdldCB0byBhIHN0YXRlIHdoZXJlIHRoZXJlIGlzbid0IGF0IGxlYXN0IG9uZSBncm91cFxuICAgIC8vICB3aXRoIGF0IGxlYXN0IG9uZSB0YWJiYWJsZSBub2RlIGluIGl0ICh0aGF0IHdvdWxkIGxlYWQgdG8gYW4gZXJyb3IgY29uZGl0aW9uIHRoYXQgd291bGRcbiAgICAvLyAgcmVzdWx0IGluIGFuIGVycm9yIGJlaW5nIHRocm93bilcbiAgICAvLyBAdHlwZSB7QXJyYXk8e1xuICAgIC8vICAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgICAvLyAgIHRhYmJhYmxlTm9kZXM6IEFycmF5PEhUTUxFbGVtZW50PiwgLy8gZW1wdHkgaWYgbm9uZVxuICAgIC8vICAgZm9jdXNhYmxlTm9kZXM6IEFycmF5PEhUTUxFbGVtZW50PiwgLy8gZW1wdHkgaWYgbm9uZVxuICAgIC8vICAgZmlyc3RUYWJiYWJsZU5vZGU6IEhUTUxFbGVtZW50fG51bGwsXG4gICAgLy8gICBsYXN0VGFiYmFibGVOb2RlOiBIVE1MRWxlbWVudHxudWxsLFxuICAgIC8vICAgbmV4dFRhYmJhYmxlTm9kZTogKG5vZGU6IEhUTUxFbGVtZW50LCBmb3J3YXJkOiBib29sZWFuKSA9PiBIVE1MRWxlbWVudHx1bmRlZmluZWRcbiAgICAvLyB9Pn1cbiAgICBjb250YWluZXJHcm91cHM6IFtdLFxuICAgIC8vIHNhbWUgb3JkZXIvbGVuZ3RoIGFzIGBjb250YWluZXJzYCBsaXN0XG5cbiAgICAvLyByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gYGNvbnRhaW5lckdyb3Vwc2AsIGJ1dCBvbmx5IHRob3NlIHRoYXQgYWN0dWFsbHkgaGF2ZVxuICAgIC8vICB0YWJiYWJsZSBub2RlcyBpbiB0aGVtXG4gICAgLy8gTk9URTogc2FtZSBvcmRlciBhcyBgY29udGFpbmVyc2AgYW5kIGBjb250YWluZXJHcm91cHNgLCBidXQgX19ub3QgbmVjZXNzYXJpbHlfX1xuICAgIC8vICB0aGUgc2FtZSBsZW5ndGhcbiAgICB0YWJiYWJsZUdyb3VwczogW10sXG4gICAgbm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uOiBudWxsLFxuICAgIG1vc3RSZWNlbnRseUZvY3VzZWROb2RlOiBudWxsLFxuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgcGF1c2VkOiBmYWxzZSxcbiAgICAvLyB0aW1lciBJRCBmb3Igd2hlbiBkZWxheUluaXRpYWxGb2N1cyBpcyB0cnVlIGFuZCBpbml0aWFsIGZvY3VzIGluIHRoaXMgdHJhcFxuICAgIC8vICBoYXMgYmVlbiBkZWxheWVkIGR1cmluZyBhY3RpdmF0aW9uXG4gICAgZGVsYXlJbml0aWFsRm9jdXNUaW1lcjogdW5kZWZpbmVkXG4gIH07XG4gIHZhciB0cmFwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1jb25zdCAtLSBzb21lIHByaXZhdGUgZnVuY3Rpb25zIHJlZmVyZW5jZSBpdCwgYW5kIGl0cyBtZXRob2RzIHJlZmVyZW5jZSBwcml2YXRlIGZ1bmN0aW9ucywgc28gd2UgbXVzdCBkZWNsYXJlIGhlcmUgYW5kIGRlZmluZSBsYXRlclxuXG4gIC8qKlxuICAgKiBHZXRzIGEgY29uZmlndXJhdGlvbiBvcHRpb24gdmFsdWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fHVuZGVmaW5lZH0gY29uZmlnT3ZlcnJpZGVPcHRpb25zIElmIHRydWUsIGFuZCBvcHRpb24gaXMgZGVmaW5lZCBpbiB0aGlzIHNldCxcbiAgICogIHZhbHVlIHdpbGwgYmUgdGFrZW4gZnJvbSB0aGlzIG9iamVjdC4gT3RoZXJ3aXNlLCB2YWx1ZSB3aWxsIGJlIHRha2VuIGZyb20gYmFzZSBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uTmFtZSBOYW1lIG9mIHRoZSBvcHRpb24gd2hvc2UgdmFsdWUgaXMgc291Z2h0LlxuICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IFtjb25maWdPcHRpb25OYW1lXSBOYW1lIG9mIG9wdGlvbiB0byB1c2UgX19pbnN0ZWFkIG9mX18gYG9wdGlvbk5hbWVgXG4gICAqICBJSUYgYGNvbmZpZ092ZXJyaWRlT3B0aW9uc2AgaXMgbm90IGRlZmluZWQuIE90aGVyd2lzZSwgYG9wdGlvbk5hbWVgIGlzIHVzZWQuXG4gICAqL1xuICB2YXIgZ2V0T3B0aW9uID0gZnVuY3Rpb24gZ2V0T3B0aW9uKGNvbmZpZ092ZXJyaWRlT3B0aW9ucywgb3B0aW9uTmFtZSwgY29uZmlnT3B0aW9uTmFtZSkge1xuICAgIHJldHVybiBjb25maWdPdmVycmlkZU9wdGlvbnMgJiYgY29uZmlnT3ZlcnJpZGVPcHRpb25zW29wdGlvbk5hbWVdICE9PSB1bmRlZmluZWQgPyBjb25maWdPdmVycmlkZU9wdGlvbnNbb3B0aW9uTmFtZV0gOiBjb25maWdbY29uZmlnT3B0aW9uTmFtZSB8fCBvcHRpb25OYW1lXTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBjb250YWluZXIgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBbZXZlbnRdXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEluZGV4IG9mIHRoZSBjb250YWluZXIgaW4gZWl0aGVyIGBzdGF0ZS5jb250YWluZXJzYCBvclxuICAgKiAgYHN0YXRlLmNvbnRhaW5lckdyb3Vwc2AgKHRoZSBvcmRlci9sZW5ndGggb2YgdGhlc2UgbGlzdHMgYXJlIHRoZSBzYW1lKTsgLTFcbiAgICogIGlmIHRoZSBlbGVtZW50IGlzbid0IGZvdW5kLlxuICAgKi9cbiAgdmFyIGZpbmRDb250YWluZXJJbmRleCA9IGZ1bmN0aW9uIGZpbmRDb250YWluZXJJbmRleChlbGVtZW50LCBldmVudCkge1xuICAgIHZhciBjb21wb3NlZFBhdGggPSB0eXBlb2YgKGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC5jb21wb3NlZFBhdGgpID09PSAnZnVuY3Rpb24nID8gZXZlbnQuY29tcG9zZWRQYXRoKCkgOiB1bmRlZmluZWQ7XG4gICAgLy8gTk9URTogc2VhcmNoIGBjb250YWluZXJHcm91cHNgIGJlY2F1c2UgaXQncyBwb3NzaWJsZSBhIGdyb3VwIGNvbnRhaW5zIG5vIHRhYmJhYmxlXG4gICAgLy8gIG5vZGVzLCBidXQgc3RpbGwgY29udGFpbnMgZm9jdXNhYmxlIG5vZGVzIChlLmcuIGlmIHRoZXkgYWxsIGhhdmUgYHRhYmluZGV4PS0xYClcbiAgICAvLyAgYW5kIHdlIHN0aWxsIG5lZWQgdG8gZmluZCB0aGUgZWxlbWVudCBpbiB0aGVyZVxuICAgIHJldHVybiBzdGF0ZS5jb250YWluZXJHcm91cHMuZmluZEluZGV4KGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gX3JlZi5jb250YWluZXIsXG4gICAgICAgIHRhYmJhYmxlTm9kZXMgPSBfcmVmLnRhYmJhYmxlTm9kZXM7XG4gICAgICByZXR1cm4gY29udGFpbmVyLmNvbnRhaW5zKGVsZW1lbnQpIHx8ICggLy8gZmFsbCBiYWNrIHRvIGV4cGxpY2l0IHRhYmJhYmxlIHNlYXJjaCB3aGljaCB3aWxsIHRha2UgaW50byBjb25zaWRlcmF0aW9uIGFueVxuICAgICAgLy8gIHdlYiBjb21wb25lbnRzIGlmIHRoZSBgdGFiYmFibGVPcHRpb25zLmdldFNoYWRvd1Jvb3RgIG9wdGlvbiB3YXMgdXNlZCBmb3JcbiAgICAgIC8vICB0aGUgdHJhcCwgZW5hYmxpbmcgc2hhZG93IERPTSBzdXBwb3J0IGluIHRhYmJhYmxlIChgTm9kZS5jb250YWlucygpYCBkb2Vzbid0XG4gICAgICAvLyAgbG9vayBpbnNpZGUgd2ViIGNvbXBvbmVudHMgZXZlbiBpZiBvcGVuKVxuICAgICAgY29tcG9zZWRQYXRoID09PSBudWxsIHx8IGNvbXBvc2VkUGF0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9zZWRQYXRoLmluY2x1ZGVzKGNvbnRhaW5lcikpIHx8IHRhYmJhYmxlTm9kZXMuZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSA9PT0gZWxlbWVudDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBub2RlIGZvciB0aGUgZ2l2ZW4gb3B0aW9uLCB3aGljaCBpcyBleHBlY3RlZCB0byBiZSBhbiBvcHRpb24gdGhhdFxuICAgKiAgY2FuIGJlIGVpdGhlciBhIERPTSBub2RlLCBhIHN0cmluZyB0aGF0IGlzIGEgc2VsZWN0b3IgdG8gZ2V0IGEgbm9kZSwgYGZhbHNlYFxuICAgKiAgKGlmIGEgbm9kZSBpcyBleHBsaWNpdGx5IE5PVCBnaXZlbiksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFueSBvZiB0aGVzZVxuICAgKiAgdmFsdWVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uTmFtZVxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkIHwgZmFsc2UgfCBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IFJldHVybnNcbiAgICogIGB1bmRlZmluZWRgIGlmIHRoZSBvcHRpb24gaXMgbm90IHNwZWNpZmllZDsgYGZhbHNlYCBpZiB0aGUgb3B0aW9uXG4gICAqICByZXNvbHZlZCB0byBgZmFsc2VgIChub2RlIGV4cGxpY2l0bHkgbm90IGdpdmVuKTsgb3RoZXJ3aXNlLCB0aGUgcmVzb2x2ZWRcbiAgICogIERPTSBub2RlLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG9wdGlvbiBpcyBzZXQsIG5vdCBgZmFsc2VgLCBhbmQgaXMgbm90LCBvciBkb2VzIG5vdFxuICAgKiAgcmVzb2x2ZSB0byBhIG5vZGUuXG4gICAqL1xuICB2YXIgZ2V0Tm9kZUZvck9wdGlvbiA9IGZ1bmN0aW9uIGdldE5vZGVGb3JPcHRpb24ob3B0aW9uTmFtZSkge1xuICAgIHZhciBvcHRpb25WYWx1ZSA9IGNvbmZpZ1tvcHRpb25OYW1lXTtcbiAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHBhcmFtc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cbiAgICAgIG9wdGlvblZhbHVlID0gb3B0aW9uVmFsdWUuYXBwbHkodm9pZCAwLCBwYXJhbXMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9uVmFsdWUgPT09IHRydWUpIHtcbiAgICAgIG9wdGlvblZhbHVlID0gdW5kZWZpbmVkOyAvLyB1c2UgZGVmYXVsdCB2YWx1ZVxuICAgIH1cblxuICAgIGlmICghb3B0aW9uVmFsdWUpIHtcbiAgICAgIGlmIChvcHRpb25WYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvblZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9uVmFsdWU7XG4gICAgICB9XG4gICAgICAvLyBlbHNlLCBlbXB0eSBzdHJpbmcgKGludmFsaWQpLCBudWxsIChpbnZhbGlkKSwgMCAoaW52YWxpZClcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYFwiLmNvbmNhdChvcHRpb25OYW1lLCBcImAgd2FzIHNwZWNpZmllZCBidXQgd2FzIG5vdCBhIG5vZGUsIG9yIGRpZCBub3QgcmV0dXJuIGEgbm9kZVwiKSk7XG4gICAgfVxuICAgIHZhciBub2RlID0gb3B0aW9uVmFsdWU7IC8vIGNvdWxkIGJlIEhUTUxFbGVtZW50LCBTVkdFbGVtZW50LCBvciBub24tZW1wdHkgc3RyaW5nIGF0IHRoaXMgcG9pbnRcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBub2RlID0gZG9jLnF1ZXJ5U2VsZWN0b3Iob3B0aW9uVmFsdWUpOyAvLyByZXNvbHZlIHRvIG5vZGUsIG9yIG51bGwgaWYgZmFpbHNcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiYCBhcyBzZWxlY3RvciByZWZlcnMgdG8gbm8ga25vd24gbm9kZVwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICB2YXIgZ2V0SW5pdGlhbEZvY3VzTm9kZSA9IGZ1bmN0aW9uIGdldEluaXRpYWxGb2N1c05vZGUoKSB7XG4gICAgdmFyIG5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKCdpbml0aWFsRm9jdXMnKTtcblxuICAgIC8vIGZhbHNlIGV4cGxpY2l0bHkgaW5kaWNhdGVzIHdlIHdhbnQgbm8gaW5pdGlhbEZvY3VzIGF0IGFsbFxuICAgIGlmIChub2RlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkIHx8ICFpc0ZvY3VzYWJsZShub2RlLCBjb25maWcudGFiYmFibGVPcHRpb25zKSkge1xuICAgICAgLy8gb3B0aW9uIG5vdCBzcGVjaWZpZWQgbm9yIGZvY3VzYWJsZTogdXNlIGZhbGxiYWNrIG9wdGlvbnNcbiAgICAgIGlmIChmaW5kQ29udGFpbmVySW5kZXgoZG9jLmFjdGl2ZUVsZW1lbnQpID49IDApIHtcbiAgICAgICAgbm9kZSA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZpcnN0VGFiYmFibGVHcm91cCA9IHN0YXRlLnRhYmJhYmxlR3JvdXBzWzBdO1xuICAgICAgICB2YXIgZmlyc3RUYWJiYWJsZU5vZGUgPSBmaXJzdFRhYmJhYmxlR3JvdXAgJiYgZmlyc3RUYWJiYWJsZUdyb3VwLmZpcnN0VGFiYmFibGVOb2RlO1xuXG4gICAgICAgIC8vIE5PVEU6IGBmYWxsYmFja0ZvY3VzYCBvcHRpb24gZnVuY3Rpb24gY2Fubm90IHJldHVybiBgZmFsc2VgIChub3Qgc3VwcG9ydGVkKVxuICAgICAgICBub2RlID0gZmlyc3RUYWJiYWJsZU5vZGUgfHwgZ2V0Tm9kZUZvck9wdGlvbignZmFsbGJhY2tGb2N1cycpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBmb2N1cy10cmFwIG5lZWRzIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGZvY3VzYWJsZSBlbGVtZW50Jyk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICB2YXIgdXBkYXRlVGFiYmFibGVOb2RlcyA9IGZ1bmN0aW9uIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKSB7XG4gICAgc3RhdGUuY29udGFpbmVyR3JvdXBzID0gc3RhdGUuY29udGFpbmVycy5tYXAoZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgdmFyIHRhYmJhYmxlTm9kZXMgPSB0YWJiYWJsZShjb250YWluZXIsIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpO1xuXG4gICAgICAvLyBOT1RFOiBpZiB3ZSBoYXZlIHRhYmJhYmxlIG5vZGVzLCB3ZSBtdXN0IGhhdmUgZm9jdXNhYmxlIG5vZGVzOyBmb2N1c2FibGUgbm9kZXNcbiAgICAgIC8vICBhcmUgYSBzdXBlcnNldCBvZiB0YWJiYWJsZSBub2Rlc1xuICAgICAgdmFyIGZvY3VzYWJsZU5vZGVzID0gZm9jdXNhYmxlKGNvbnRhaW5lciwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgdGFiYmFibGVOb2RlczogdGFiYmFibGVOb2RlcyxcbiAgICAgICAgZm9jdXNhYmxlTm9kZXM6IGZvY3VzYWJsZU5vZGVzLFxuICAgICAgICBmaXJzdFRhYmJhYmxlTm9kZTogdGFiYmFibGVOb2Rlcy5sZW5ndGggPiAwID8gdGFiYmFibGVOb2Rlc1swXSA6IG51bGwsXG4gICAgICAgIGxhc3RUYWJiYWJsZU5vZGU6IHRhYmJhYmxlTm9kZXMubGVuZ3RoID4gMCA/IHRhYmJhYmxlTm9kZXNbdGFiYmFibGVOb2Rlcy5sZW5ndGggLSAxXSA6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kcyB0aGUgX190YWJiYWJsZV9fIG5vZGUgdGhhdCBmb2xsb3dzIHRoZSBnaXZlbiBub2RlIGluIHRoZSBzcGVjaWZpZWQgZGlyZWN0aW9uLFxuICAgICAgICAgKiAgaW4gdGhpcyBjb250YWluZXIsIGlmIGFueS5cbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3J3YXJkXSBUcnVlIGlmIGdvaW5nIGluIGZvcndhcmQgdGFiIG9yZGVyOyBmYWxzZSBpZiBnb2luZ1xuICAgICAgICAgKiAgaW4gcmV2ZXJzZS5cbiAgICAgICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fHVuZGVmaW5lZH0gVGhlIG5leHQgdGFiYmFibGUgbm9kZSwgaWYgYW55LlxuICAgICAgICAgKi9cbiAgICAgICAgbmV4dFRhYmJhYmxlTm9kZTogZnVuY3Rpb24gbmV4dFRhYmJhYmxlTm9kZShub2RlKSB7XG4gICAgICAgICAgdmFyIGZvcndhcmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICAgICAgLy8gTk9URTogSWYgdGFiaW5kZXggaXMgcG9zaXRpdmUgKGluIG9yZGVyIHRvIG1hbmlwdWxhdGUgdGhlIHRhYiBvcmRlciBzZXBhcmF0ZVxuICAgICAgICAgIC8vICBmcm9tIHRoZSBET00gb3JkZXIpLCB0aGlzIF9fd2lsbCBub3Qgd29ya19fIGJlY2F1c2UgdGhlIGxpc3Qgb2YgZm9jdXNhYmxlTm9kZXMsXG4gICAgICAgICAgLy8gIHdoaWxlIGl0IGNvbnRhaW5zIHRhYmJhYmxlIG5vZGVzLCBkb2VzIG5vdCBzb3J0IGl0cyBub2RlcyBpbiBhbnkgb3JkZXIgb3RoZXJcbiAgICAgICAgICAvLyAgdGhhbiBET00gb3JkZXIsIGJlY2F1c2UgaXQgY2FuJ3Q6IFdoZXJlIHdvdWxkIHlvdSBwbGFjZSBmb2N1c2FibGUgKGJ1dCBub3RcbiAgICAgICAgICAvLyAgdGFiYmFibGUpIG5vZGVzIGluIHRoYXQgb3JkZXI/IFRoZXkgaGF2ZSBubyBvcmRlciwgYmVjYXVzZSB0aGV5IGFyZW4ndCB0YWJiYWxlLi4uXG4gICAgICAgICAgLy8gU3VwcG9ydCBmb3IgcG9zaXRpdmUgdGFiaW5kZXggaXMgYWxyZWFkeSBicm9rZW4gYW5kIGhhcmQgdG8gbWFuYWdlIChwb3NzaWJseVxuICAgICAgICAgIC8vICBub3Qgc3VwcG9ydGFibGUsIFRCRCksIHNvIHRoaXMgaXNuJ3QgZ29pbmcgdG8gbWFrZSB0aGluZ3Mgd29yc2UgdGhhbiB0aGV5XG4gICAgICAgICAgLy8gIGFscmVhZHkgYXJlLCBhbmQgYXQgbGVhc3QgbWFrZXMgdGhpbmdzIGJldHRlciBmb3IgdGhlIG1ham9yaXR5IG9mIGNhc2VzIHdoZXJlXG4gICAgICAgICAgLy8gIHRhYmluZGV4IGlzIGVpdGhlciAwL3Vuc2V0IG9yIG5lZ2F0aXZlLlxuICAgICAgICAgIC8vIEZZSSwgcG9zaXRpdmUgdGFiaW5kZXggaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL2ZvY3VzLXRyYXAvaXNzdWVzLzM3NVxuICAgICAgICAgIHZhciBub2RlSWR4ID0gZm9jdXNhYmxlTm9kZXMuZmluZEluZGV4KGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gbiA9PT0gbm9kZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobm9kZUlkeCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9jdXNhYmxlTm9kZXMuc2xpY2Uobm9kZUlkeCArIDEpLmZpbmQoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzVGFiYmFibGUobiwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZvY3VzYWJsZU5vZGVzLnNsaWNlKDAsIG5vZGVJZHgpLnJldmVyc2UoKS5maW5kKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNUYWJiYWJsZShuLCBjb25maWcudGFiYmFibGVPcHRpb25zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBzdGF0ZS50YWJiYWJsZUdyb3VwcyA9IHN0YXRlLmNvbnRhaW5lckdyb3Vwcy5maWx0ZXIoZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICByZXR1cm4gZ3JvdXAudGFiYmFibGVOb2Rlcy5sZW5ndGggPiAwO1xuICAgIH0pO1xuXG4gICAgLy8gdGhyb3cgaWYgbm8gZ3JvdXBzIGhhdmUgdGFiYmFibGUgbm9kZXMgYW5kIHdlIGRvbid0IGhhdmUgYSBmYWxsYmFjayBmb2N1cyBub2RlIGVpdGhlclxuICAgIGlmIChzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggPD0gMCAmJiAhZ2V0Tm9kZUZvck9wdGlvbignZmFsbGJhY2tGb2N1cycpIC8vIHJldHVybmluZyBmYWxzZSBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIG9wdGlvblxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIGZvY3VzLXRyYXAgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBjb250YWluZXIgd2l0aCBhdCBsZWFzdCBvbmUgdGFiYmFibGUgbm9kZSBpbiBpdCBhdCBhbGwgdGltZXMnKTtcbiAgICB9XG4gIH07XG4gIHZhciB0cnlGb2N1cyA9IGZ1bmN0aW9uIHRyeUZvY3VzKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGRvYy5hY3RpdmVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbm9kZSB8fCAhbm9kZS5mb2N1cykge1xuICAgICAgdHJ5Rm9jdXMoZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbm9kZS5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiAhIWNvbmZpZy5wcmV2ZW50U2Nyb2xsXG4gICAgfSk7XG4gICAgc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgPSBub2RlO1xuICAgIGlmIChpc1NlbGVjdGFibGVJbnB1dChub2RlKSkge1xuICAgICAgbm9kZS5zZWxlY3QoKTtcbiAgICB9XG4gIH07XG4gIHZhciBnZXRSZXR1cm5Gb2N1c05vZGUgPSBmdW5jdGlvbiBnZXRSZXR1cm5Gb2N1c05vZGUocHJldmlvdXNBY3RpdmVFbGVtZW50KSB7XG4gICAgdmFyIG5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKCdzZXRSZXR1cm5Gb2N1cycsIHByZXZpb3VzQWN0aXZlRWxlbWVudCk7XG4gICAgcmV0dXJuIG5vZGUgPyBub2RlIDogbm9kZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHByZXZpb3VzQWN0aXZlRWxlbWVudDtcbiAgfTtcblxuICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgb24gbW91c2Vkb3duIGFuZCB0b3VjaHN0YXJ0IGluc3RlYWQgb2YgY2xpY2tcbiAgLy8gc28gdGhhdCBpdCBwcmVjZWRlcyB0aGUgZm9jdXMgZXZlbnQuXG4gIHZhciBjaGVja1BvaW50ZXJEb3duID0gZnVuY3Rpb24gY2hlY2tQb2ludGVyRG93bihlKSB7XG4gICAgdmFyIHRhcmdldCA9IGdldEFjdHVhbFRhcmdldChlKTtcbiAgICBpZiAoZmluZENvbnRhaW5lckluZGV4KHRhcmdldCwgZSkgPj0gMCkge1xuICAgICAgLy8gYWxsb3cgdGhlIGNsaWNrIHNpbmNlIGl0IG9jdXJyZWQgaW5zaWRlIHRoZSB0cmFwXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZU9ySGFuZGxlcihjb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMsIGUpKSB7XG4gICAgICAvLyBpbW1lZGlhdGVseSBkZWFjdGl2YXRlIHRoZSB0cmFwXG4gICAgICB0cmFwLmRlYWN0aXZhdGUoe1xuICAgICAgICAvLyBOT1RFOiBieSBzZXR0aW5nIGByZXR1cm5Gb2N1czogZmFsc2VgLCBkZWFjdGl2YXRlKCkgd2lsbCBkbyBub3RoaW5nLFxuICAgICAgICAvLyAgd2hpY2ggd2lsbCByZXN1bHQgaW4gdGhlIG91dHNpZGUgY2xpY2sgc2V0dGluZyBmb2N1cyB0byB0aGUgbm9kZVxuICAgICAgICAvLyAgdGhhdCB3YXMgY2xpY2tlZCAoYW5kIGlmIG5vdCBmb2N1c2FibGUsIHRvIFwibm90aGluZ1wiKTsgYnkgc2V0dGluZ1xuICAgICAgICAvLyAgYHJldHVybkZvY3VzOiB0cnVlYCwgd2UnbGwgYXR0ZW1wdCB0byByZS1mb2N1cyB0aGUgbm9kZSBvcmlnaW5hbGx5LWZvY3VzZWRcbiAgICAgICAgLy8gIG9uIGFjdGl2YXRpb24gKG9yIHRoZSBjb25maWd1cmVkIGBzZXRSZXR1cm5Gb2N1c2Agbm9kZSksIHdoZXRoZXIgdGhlXG4gICAgICAgIC8vICBvdXRzaWRlIGNsaWNrIHdhcyBvbiBhIGZvY3VzYWJsZSBub2RlIG9yIG5vdFxuICAgICAgICByZXR1cm5Gb2N1czogY29uZmlnLnJldHVybkZvY3VzT25EZWFjdGl2YXRlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIG5lZWRlZCBmb3IgbW9iaWxlIGRldmljZXMuXG4gICAgLy8gKElmIHdlJ2xsIG9ubHkgbGV0IGBjbGlja2AgZXZlbnRzIHRocm91Z2gsXG4gICAgLy8gdGhlbiBvbiBtb2JpbGUgdGhleSB3aWxsIGJlIGJsb2NrZWQgYW55d2F5cyBpZiBgdG91Y2hzdGFydGAgaXMgYmxvY2tlZC4pXG4gICAgaWYgKHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5hbGxvd091dHNpZGVDbGljaywgZSkpIHtcbiAgICAgIC8vIGFsbG93IHRoZSBjbGljayBvdXRzaWRlIHRoZSB0cmFwIHRvIHRha2UgcGxhY2VcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UsIHByZXZlbnQgdGhlIGNsaWNrXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIC8vIEluIGNhc2UgZm9jdXMgZXNjYXBlcyB0aGUgdHJhcCBmb3Igc29tZSBzdHJhbmdlIHJlYXNvbiwgcHVsbCBpdCBiYWNrIGluLlxuICB2YXIgY2hlY2tGb2N1c0luID0gZnVuY3Rpb24gY2hlY2tGb2N1c0luKGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0QWN0dWFsVGFyZ2V0KGUpO1xuICAgIHZhciB0YXJnZXRDb250YWluZWQgPSBmaW5kQ29udGFpbmVySW5kZXgodGFyZ2V0LCBlKSA+PSAwO1xuXG4gICAgLy8gSW4gRmlyZWZveCB3aGVuIHlvdSBUYWIgb3V0IG9mIGFuIGlmcmFtZSB0aGUgRG9jdW1lbnQgaXMgYnJpZWZseSBmb2N1c2VkLlxuICAgIGlmICh0YXJnZXRDb250YWluZWQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIGlmICh0YXJnZXRDb250YWluZWQpIHtcbiAgICAgICAgc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzY2FwZWQhIHB1bGwgaXQgYmFjayBpbiB0byB3aGVyZSBpdCBqdXN0IGxlZnRcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB0cnlGb2N1cyhzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSB8fCBnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIaWphY2sga2V5IG5hdiBldmVudHMgb24gdGhlIGZpcnN0IGFuZCBsYXN0IGZvY3VzYWJsZSBub2RlcyBvZiB0aGUgdHJhcCxcbiAgLy8gaW4gb3JkZXIgdG8gcHJldmVudCBmb2N1cyBmcm9tIGVzY2FwaW5nLiBJZiBpdCBlc2NhcGVzIGZvciBldmVuIGFcbiAgLy8gbW9tZW50IGl0IGNhbiBlbmQgdXAgc2Nyb2xsaW5nIHRoZSBwYWdlIGFuZCBjYXVzaW5nIGNvbmZ1c2lvbiBzbyB3ZVxuICAvLyBraW5kIG9mIG5lZWQgdG8gY2FwdHVyZSB0aGUgYWN0aW9uIGF0IHRoZSBrZXlkb3duIHBoYXNlLlxuICB2YXIgY2hlY2tLZXlOYXYgPSBmdW5jdGlvbiBjaGVja0tleU5hdihldmVudCkge1xuICAgIHZhciBpc0JhY2t3YXJkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0QWN0dWFsVGFyZ2V0KGV2ZW50KTtcbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgdmFyIGRlc3RpbmF0aW9uTm9kZSA9IG51bGw7XG4gICAgaWYgKHN0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgdGFyZ2V0IGlzIGFjdHVhbGx5IGNvbnRhaW5lZCBpbiBhIGdyb3VwXG4gICAgICAvLyBOT1RFOiB0aGUgdGFyZ2V0IG1heSBhbHNvIGJlIHRoZSBjb250YWluZXIgaXRzZWxmIGlmIGl0J3MgZm9jdXNhYmxlXG4gICAgICAvLyAgd2l0aCB0YWJJbmRleD0nLTEnIGFuZCB3YXMgZ2l2ZW4gaW5pdGlhbCBmb2N1c1xuICAgICAgdmFyIGNvbnRhaW5lckluZGV4ID0gZmluZENvbnRhaW5lckluZGV4KHRhcmdldCwgZXZlbnQpO1xuICAgICAgdmFyIGNvbnRhaW5lckdyb3VwID0gY29udGFpbmVySW5kZXggPj0gMCA/IHN0YXRlLmNvbnRhaW5lckdyb3Vwc1tjb250YWluZXJJbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY29udGFpbmVySW5kZXggPCAwKSB7XG4gICAgICAgIC8vIHRhcmdldCBub3QgZm91bmQgaW4gYW55IGdyb3VwOiBxdWl0ZSBwb3NzaWJsZSBmb2N1cyBoYXMgZXNjYXBlZCB0aGUgdHJhcCxcbiAgICAgICAgLy8gIHNvIGJyaW5nIGl0IGJhY2sgaW50by4uLlxuICAgICAgICBpZiAoaXNCYWNrd2FyZCkge1xuICAgICAgICAgIC8vIC4uLnRoZSBsYXN0IG5vZGUgaW4gdGhlIGxhc3QgZ3JvdXBcbiAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBzdGF0ZS50YWJiYWJsZUdyb3Vwc1tzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggLSAxXS5sYXN0VGFiYmFibGVOb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIC4uLnRoZSBmaXJzdCBub2RlIGluIHRoZSBmaXJzdCBncm91cFxuICAgICAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IHN0YXRlLnRhYmJhYmxlR3JvdXBzWzBdLmZpcnN0VGFiYmFibGVOb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgICAgLy8gUkVWRVJTRVxuXG4gICAgICAgIC8vIGlzIHRoZSB0YXJnZXQgdGhlIGZpcnN0IHRhYmJhYmxlIG5vZGUgaW4gYSBncm91cD9cbiAgICAgICAgdmFyIHN0YXJ0T2ZHcm91cEluZGV4ID0gZmluZEluZGV4KHN0YXRlLnRhYmJhYmxlR3JvdXBzLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICB2YXIgZmlyc3RUYWJiYWJsZU5vZGUgPSBfcmVmMi5maXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0ID09PSBmaXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGFydE9mR3JvdXBJbmRleCA8IDAgJiYgKGNvbnRhaW5lckdyb3VwLmNvbnRhaW5lciA9PT0gdGFyZ2V0IHx8IGlzRm9jdXNhYmxlKHRhcmdldCwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucykgJiYgIWlzVGFiYmFibGUodGFyZ2V0LCBjb25maWcudGFiYmFibGVPcHRpb25zKSAmJiAhY29udGFpbmVyR3JvdXAubmV4dFRhYmJhYmxlTm9kZSh0YXJnZXQsIGZhbHNlKSkpIHtcbiAgICAgICAgICAvLyBhbiBleGNlcHRpb24gY2FzZSB3aGVyZSB0aGUgdGFyZ2V0IGlzIGVpdGhlciB0aGUgY29udGFpbmVyIGl0c2VsZiwgb3JcbiAgICAgICAgICAvLyAgYSBub24tdGFiYmFibGUgbm9kZSB0aGF0IHdhcyBnaXZlbiBmb2N1cyAoaS5lLiB0YWJpbmRleCBpcyBuZWdhdGl2ZVxuICAgICAgICAgIC8vICBhbmQgdXNlciBjbGlja2VkIG9uIGl0IG9yIG5vZGUgd2FzIHByb2dyYW1tYXRpY2FsbHkgZ2l2ZW4gZm9jdXMpXG4gICAgICAgICAgLy8gIGFuZCBpcyBub3QgZm9sbG93ZWQgYnkgYW55IG90aGVyIHRhYmJhYmxlIG5vZGUsIGluIHdoaWNoXG4gICAgICAgICAgLy8gIGNhc2UsIHdlIHNob3VsZCBoYW5kbGUgc2hpZnQrdGFiIGFzIGlmIGZvY3VzIHdlcmUgb24gdGhlIGNvbnRhaW5lcidzXG4gICAgICAgICAgLy8gIGZpcnN0IHRhYmJhYmxlIG5vZGUsIGFuZCBnbyB0byB0aGUgbGFzdCB0YWJiYWJsZSBub2RlIG9mIHRoZSBMQVNUIGdyb3VwXG4gICAgICAgICAgc3RhcnRPZkdyb3VwSW5kZXggPSBjb250YWluZXJJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRPZkdyb3VwSW5kZXggPj0gMCkge1xuICAgICAgICAgIC8vIFlFUzogdGhlbiBzaGlmdCt0YWIgc2hvdWxkIGdvIHRvIHRoZSBsYXN0IHRhYmJhYmxlIG5vZGUgaW4gdGhlXG4gICAgICAgICAgLy8gIHByZXZpb3VzIGdyb3VwIChhbmQgd3JhcCBhcm91bmQgdG8gdGhlIGxhc3QgdGFiYmFibGUgbm9kZSBvZlxuICAgICAgICAgIC8vICB0aGUgTEFTVCBncm91cCBpZiBpdCdzIHRoZSBmaXJzdCB0YWJiYWJsZSBub2RlIG9mIHRoZSBGSVJTVCBncm91cClcbiAgICAgICAgICB2YXIgZGVzdGluYXRpb25Hcm91cEluZGV4ID0gc3RhcnRPZkdyb3VwSW5kZXggPT09IDAgPyBzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggLSAxIDogc3RhcnRPZkdyb3VwSW5kZXggLSAxO1xuICAgICAgICAgIHZhciBkZXN0aW5hdGlvbkdyb3VwID0gc3RhdGUudGFiYmFibGVHcm91cHNbZGVzdGluYXRpb25Hcm91cEluZGV4XTtcbiAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBkZXN0aW5hdGlvbkdyb3VwLmxhc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzVGFiRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgLy8gdXNlciBtdXN0IGhhdmUgY3VzdG9taXplZCB0aGUgbmF2IGtleXMgc28gd2UgaGF2ZSB0byBtb3ZlIGZvY3VzIG1hbnVhbGx5IF93aXRoaW5fXG4gICAgICAgICAgLy8gIHRoZSBhY3RpdmUgZ3JvdXA6IGRvIHRoaXMgYmFzZWQgb24gdGhlIG9yZGVyIGRldGVybWluZWQgYnkgdGFiYmFibGUoKVxuICAgICAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IGNvbnRhaW5lckdyb3VwLm5leHRUYWJiYWJsZU5vZGUodGFyZ2V0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZPUldBUkRcblxuICAgICAgICAvLyBpcyB0aGUgdGFyZ2V0IHRoZSBsYXN0IHRhYmJhYmxlIG5vZGUgaW4gYSBncm91cD9cbiAgICAgICAgdmFyIGxhc3RPZkdyb3VwSW5kZXggPSBmaW5kSW5kZXgoc3RhdGUudGFiYmFibGVHcm91cHMsIGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICAgIHZhciBsYXN0VGFiYmFibGVOb2RlID0gX3JlZjMubGFzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0ID09PSBsYXN0VGFiYmFibGVOb2RlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxhc3RPZkdyb3VwSW5kZXggPCAwICYmIChjb250YWluZXJHcm91cC5jb250YWluZXIgPT09IHRhcmdldCB8fCBpc0ZvY3VzYWJsZSh0YXJnZXQsIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpICYmICFpc1RhYmJhYmxlKHRhcmdldCwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucykgJiYgIWNvbnRhaW5lckdyb3VwLm5leHRUYWJiYWJsZU5vZGUodGFyZ2V0KSkpIHtcbiAgICAgICAgICAvLyBhbiBleGNlcHRpb24gY2FzZSB3aGVyZSB0aGUgdGFyZ2V0IGlzIHRoZSBjb250YWluZXIgaXRzZWxmLCBvclxuICAgICAgICAgIC8vICBhIG5vbi10YWJiYWJsZSBub2RlIHRoYXQgd2FzIGdpdmVuIGZvY3VzIChpLmUuIHRhYmluZGV4IGlzIG5lZ2F0aXZlXG4gICAgICAgICAgLy8gIGFuZCB1c2VyIGNsaWNrZWQgb24gaXQgb3Igbm9kZSB3YXMgcHJvZ3JhbW1hdGljYWxseSBnaXZlbiBmb2N1cylcbiAgICAgICAgICAvLyAgYW5kIGlzIG5vdCBmb2xsb3dlZCBieSBhbnkgb3RoZXIgdGFiYmFibGUgbm9kZSwgaW4gd2hpY2hcbiAgICAgICAgICAvLyAgY2FzZSwgd2Ugc2hvdWxkIGhhbmRsZSB0YWIgYXMgaWYgZm9jdXMgd2VyZSBvbiB0aGUgY29udGFpbmVyJ3NcbiAgICAgICAgICAvLyAgbGFzdCB0YWJiYWJsZSBub2RlLCBhbmQgZ28gdG8gdGhlIGZpcnN0IHRhYmJhYmxlIG5vZGUgb2YgdGhlIEZJUlNUIGdyb3VwXG4gICAgICAgICAgbGFzdE9mR3JvdXBJbmRleCA9IGNvbnRhaW5lckluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0T2ZHcm91cEluZGV4ID49IDApIHtcbiAgICAgICAgICAvLyBZRVM6IHRoZW4gdGFiIHNob3VsZCBnbyB0byB0aGUgZmlyc3QgdGFiYmFibGUgbm9kZSBpbiB0aGUgbmV4dFxuICAgICAgICAgIC8vICBncm91cCAoYW5kIHdyYXAgYXJvdW5kIHRvIHRoZSBmaXJzdCB0YWJiYWJsZSBub2RlIG9mIHRoZSBGSVJTVFxuICAgICAgICAgIC8vICBncm91cCBpZiBpdCdzIHRoZSBsYXN0IHRhYmJhYmxlIG5vZGUgb2YgdGhlIExBU1QgZ3JvdXApXG4gICAgICAgICAgdmFyIF9kZXN0aW5hdGlvbkdyb3VwSW5kZXggPSBsYXN0T2ZHcm91cEluZGV4ID09PSBzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggLSAxID8gMCA6IGxhc3RPZkdyb3VwSW5kZXggKyAxO1xuICAgICAgICAgIHZhciBfZGVzdGluYXRpb25Hcm91cCA9IHN0YXRlLnRhYmJhYmxlR3JvdXBzW19kZXN0aW5hdGlvbkdyb3VwSW5kZXhdO1xuICAgICAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IF9kZXN0aW5hdGlvbkdyb3VwLmZpcnN0VGFiYmFibGVOb2RlO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc1RhYkV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgIC8vIHVzZXIgbXVzdCBoYXZlIGN1c3RvbWl6ZWQgdGhlIG5hdiBrZXlzIHNvIHdlIGhhdmUgdG8gbW92ZSBmb2N1cyBtYW51YWxseSBfd2l0aGluX1xuICAgICAgICAgIC8vICB0aGUgYWN0aXZlIGdyb3VwOiBkbyB0aGlzIGJhc2VkIG9uIHRoZSBvcmRlciBkZXRlcm1pbmVkIGJ5IHRhYmJhYmxlKClcbiAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBjb250YWluZXJHcm91cC5uZXh0VGFiYmFibGVOb2RlKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gZ3JvdXBzIGF2YWlsYWJsZVxuICAgICAgLy8gTk9URTogdGhlIGZhbGxiYWNrRm9jdXMgb3B0aW9uIGRvZXMgbm90IHN1cHBvcnQgcmV0dXJuaW5nIGZhbHNlIHRvIG9wdC1vdXRcbiAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IGdldE5vZGVGb3JPcHRpb24oJ2ZhbGxiYWNrRm9jdXMnKTtcbiAgICB9XG4gICAgaWYgKGRlc3RpbmF0aW9uTm9kZSkge1xuICAgICAgaWYgKGlzVGFiRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIC8vIHNpbmNlIHRhYiBuYXRpdmVseSBtb3ZlcyBmb2N1cywgd2Ugd291bGRuJ3QgaGF2ZSBhIGRlc3RpbmF0aW9uIG5vZGUgdW5sZXNzIHdlXG4gICAgICAgIC8vICB3ZXJlIG9uIHRoZSBlZGdlIG9mIGEgY29udGFpbmVyIGFuZCBoYWQgdG8gbW92ZSB0byB0aGUgbmV4dC9wcmV2aW91cyBlZGdlLCBpblxuICAgICAgICAvLyAgd2hpY2ggY2FzZSB3ZSB3YW50IHRvIHByZXZlbnQgZGVmYXVsdCB0byBrZWVwIHRoZSBicm93c2VyIGZyb20gbW92aW5nIGZvY3VzXG4gICAgICAgIC8vICB0byB3aGVyZSBpdCBub3JtYWxseSB3b3VsZFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdHJ5Rm9jdXMoZGVzdGluYXRpb25Ob2RlKTtcbiAgICB9XG4gICAgLy8gZWxzZSwgbGV0IHRoZSBicm93c2VyIHRha2UgY2FyZSBvZiBbc2hpZnQrXXRhYiBhbmQgbW92ZSB0aGUgZm9jdXNcbiAgfTtcblxuICB2YXIgY2hlY2tLZXkgPSBmdW5jdGlvbiBjaGVja0tleShldmVudCkge1xuICAgIGlmIChpc0VzY2FwZUV2ZW50KGV2ZW50KSAmJiB2YWx1ZU9ySGFuZGxlcihjb25maWcuZXNjYXBlRGVhY3RpdmF0ZXMsIGV2ZW50KSAhPT0gZmFsc2UpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0cmFwLmRlYWN0aXZhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5pc0tleUZvcndhcmQoZXZlbnQpIHx8IGNvbmZpZy5pc0tleUJhY2t3YXJkKGV2ZW50KSkge1xuICAgICAgY2hlY2tLZXlOYXYoZXZlbnQsIGNvbmZpZy5pc0tleUJhY2t3YXJkKGV2ZW50KSk7XG4gICAgfVxuICB9O1xuICB2YXIgY2hlY2tDbGljayA9IGZ1bmN0aW9uIGNoZWNrQ2xpY2soZSkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRBY3R1YWxUYXJnZXQoZSk7XG4gICAgaWYgKGZpbmRDb250YWluZXJJbmRleCh0YXJnZXQsIGUpID49IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcywgZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5hbGxvd091dHNpZGVDbGljaywgZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIH07XG5cbiAgLy9cbiAgLy8gRVZFTlQgTElTVEVORVJTXG4gIC8vXG5cbiAgdmFyIGFkZExpc3RlbmVycyA9IGZ1bmN0aW9uIGFkZExpc3RlbmVycygpIHtcbiAgICBpZiAoIXN0YXRlLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZXJlIGNhbiBiZSBvbmx5IG9uZSBsaXN0ZW5pbmcgZm9jdXMgdHJhcCBhdCBhIHRpbWVcbiAgICBhY3RpdmVGb2N1c1RyYXBzLmFjdGl2YXRlVHJhcCh0cmFwU3RhY2ssIHRyYXApO1xuXG4gICAgLy8gRGVsYXkgZW5zdXJlcyB0aGF0IHRoZSBmb2N1c2VkIGVsZW1lbnQgZG9lc24ndCBjYXB0dXJlIHRoZSBldmVudFxuICAgIC8vIHRoYXQgY2F1c2VkIHRoZSBmb2N1cyB0cmFwIGFjdGl2YXRpb24uXG4gICAgc3RhdGUuZGVsYXlJbml0aWFsRm9jdXNUaW1lciA9IGNvbmZpZy5kZWxheUluaXRpYWxGb2N1cyA/IGRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeUZvY3VzKGdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gICAgfSkgOiB0cnlGb2N1cyhnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgY2hlY2tGb2N1c0luLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjaGVja0NsaWNrLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNoZWNrS2V5LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhcDtcbiAgfTtcbiAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBpZiAoIXN0YXRlLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGNoZWNrRm9jdXNJbiwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH07XG5cbiAgLy9cbiAgLy8gTVVUQVRJT04gT0JTRVJWRVJcbiAgLy9cblxuICB2YXIgY2hlY2tEb21SZW1vdmFsID0gZnVuY3Rpb24gY2hlY2tEb21SZW1vdmFsKG11dGF0aW9ucykge1xuICAgIHZhciBpc0ZvY3VzZWROb2RlUmVtb3ZlZCA9IG11dGF0aW9ucy5zb21lKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgdmFyIHJlbW92ZWROb2RlcyA9IEFycmF5LmZyb20obXV0YXRpb24ucmVtb3ZlZE5vZGVzKTtcbiAgICAgIHJldHVybiByZW1vdmVkTm9kZXMuc29tZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSA9PT0gc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIElmIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBpcyByZW1vdmVkIHRoZW4gYnJvd3NlcnMgd2lsbCBtb3ZlIGZvY3VzIHRvIHRoZVxuICAgIC8vIDxib2R5PiBlbGVtZW50LiBJZiB0aGlzIGhhcHBlbnMsIHRyeSB0byBtb3ZlIGZvY3VzIGJhY2sgaW50byB0aGUgdHJhcC5cbiAgICBpZiAoaXNGb2N1c2VkTm9kZVJlbW92ZWQpIHtcbiAgICAgIHRyeUZvY3VzKGdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIC0gaWYgc3VwcG9ydGVkIC0gdG8gZGV0ZWN0IGlmIGZvY3VzZWQgbm9kZSBpcyByZW1vdmVkXG4gIC8vIGZyb20gdGhlIERPTS5cbiAgdmFyIG11dGF0aW9uT2JzZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93ID8gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2hlY2tEb21SZW1vdmFsKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHVwZGF0ZU9ic2VydmVkTm9kZXMgPSBmdW5jdGlvbiB1cGRhdGVPYnNlcnZlZE5vZGVzKCkge1xuICAgIGlmICghbXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBpZiAoc3RhdGUuYWN0aXZlICYmICFzdGF0ZS5wYXVzZWQpIHtcbiAgICAgIHN0YXRlLmNvbnRhaW5lcnMubWFwKGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lciwge1xuICAgICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vXG4gIC8vIFRSQVAgREVGSU5JVElPTlxuICAvL1xuXG4gIHRyYXAgPSB7XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5hY3RpdmU7XG4gICAgfSxcbiAgICBnZXQgcGF1c2VkKCkge1xuICAgICAgcmV0dXJuIHN0YXRlLnBhdXNlZDtcbiAgICB9LFxuICAgIGFjdGl2YXRlOiBmdW5jdGlvbiBhY3RpdmF0ZShhY3RpdmF0ZU9wdGlvbnMpIHtcbiAgICAgIGlmIChzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgb25BY3RpdmF0ZSA9IGdldE9wdGlvbihhY3RpdmF0ZU9wdGlvbnMsICdvbkFjdGl2YXRlJyk7XG4gICAgICB2YXIgb25Qb3N0QWN0aXZhdGUgPSBnZXRPcHRpb24oYWN0aXZhdGVPcHRpb25zLCAnb25Qb3N0QWN0aXZhdGUnKTtcbiAgICAgIHZhciBjaGVja0NhbkZvY3VzVHJhcCA9IGdldE9wdGlvbihhY3RpdmF0ZU9wdGlvbnMsICdjaGVja0NhbkZvY3VzVHJhcCcpO1xuICAgICAgaWYgKCFjaGVja0NhbkZvY3VzVHJhcCkge1xuICAgICAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gICAgICBzdGF0ZS5ub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24gPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICAgIG9uQWN0aXZhdGUgPT09IG51bGwgfHwgb25BY3RpdmF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25BY3RpdmF0ZSgpO1xuICAgICAgdmFyIGZpbmlzaEFjdGl2YXRpb24gPSBmdW5jdGlvbiBmaW5pc2hBY3RpdmF0aW9uKCkge1xuICAgICAgICBpZiAoY2hlY2tDYW5Gb2N1c1RyYXApIHtcbiAgICAgICAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkTGlzdGVuZXJzKCk7XG4gICAgICAgIHVwZGF0ZU9ic2VydmVkTm9kZXMoKTtcbiAgICAgICAgb25Qb3N0QWN0aXZhdGUgPT09IG51bGwgfHwgb25Qb3N0QWN0aXZhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUG9zdEFjdGl2YXRlKCk7XG4gICAgICB9O1xuICAgICAgaWYgKGNoZWNrQ2FuRm9jdXNUcmFwKSB7XG4gICAgICAgIGNoZWNrQ2FuRm9jdXNUcmFwKHN0YXRlLmNvbnRhaW5lcnMuY29uY2F0KCkpLnRoZW4oZmluaXNoQWN0aXZhdGlvbiwgZmluaXNoQWN0aXZhdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZmluaXNoQWN0aXZhdGlvbigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkZWFjdGl2YXRlOiBmdW5jdGlvbiBkZWFjdGl2YXRlKGRlYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgICBpZiAoIXN0YXRlLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICBvbkRlYWN0aXZhdGU6IGNvbmZpZy5vbkRlYWN0aXZhdGUsXG4gICAgICAgIG9uUG9zdERlYWN0aXZhdGU6IGNvbmZpZy5vblBvc3REZWFjdGl2YXRlLFxuICAgICAgICBjaGVja0NhblJldHVybkZvY3VzOiBjb25maWcuY2hlY2tDYW5SZXR1cm5Gb2N1c1xuICAgICAgfSwgZGVhY3RpdmF0ZU9wdGlvbnMpO1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLmRlbGF5SW5pdGlhbEZvY3VzVGltZXIpOyAvLyBub29wIGlmIHVuZGVmaW5lZFxuICAgICAgc3RhdGUuZGVsYXlJbml0aWFsRm9jdXNUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgc3RhdGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZU9ic2VydmVkTm9kZXMoKTtcbiAgICAgIGFjdGl2ZUZvY3VzVHJhcHMuZGVhY3RpdmF0ZVRyYXAodHJhcFN0YWNrLCB0cmFwKTtcbiAgICAgIHZhciBvbkRlYWN0aXZhdGUgPSBnZXRPcHRpb24ob3B0aW9ucywgJ29uRGVhY3RpdmF0ZScpO1xuICAgICAgdmFyIG9uUG9zdERlYWN0aXZhdGUgPSBnZXRPcHRpb24ob3B0aW9ucywgJ29uUG9zdERlYWN0aXZhdGUnKTtcbiAgICAgIHZhciBjaGVja0NhblJldHVybkZvY3VzID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdjaGVja0NhblJldHVybkZvY3VzJyk7XG4gICAgICB2YXIgcmV0dXJuRm9jdXMgPSBnZXRPcHRpb24ob3B0aW9ucywgJ3JldHVybkZvY3VzJywgJ3JldHVybkZvY3VzT25EZWFjdGl2YXRlJyk7XG4gICAgICBvbkRlYWN0aXZhdGUgPT09IG51bGwgfHwgb25EZWFjdGl2YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkRlYWN0aXZhdGUoKTtcbiAgICAgIHZhciBmaW5pc2hEZWFjdGl2YXRpb24gPSBmdW5jdGlvbiBmaW5pc2hEZWFjdGl2YXRpb24oKSB7XG4gICAgICAgIGRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRm9jdXMpIHtcbiAgICAgICAgICAgIHRyeUZvY3VzKGdldFJldHVybkZvY3VzTm9kZShzdGF0ZS5ub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb25Qb3N0RGVhY3RpdmF0ZSA9PT0gbnVsbCB8fCBvblBvc3REZWFjdGl2YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblBvc3REZWFjdGl2YXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmIChyZXR1cm5Gb2N1cyAmJiBjaGVja0NhblJldHVybkZvY3VzKSB7XG4gICAgICAgIGNoZWNrQ2FuUmV0dXJuRm9jdXMoZ2V0UmV0dXJuRm9jdXNOb2RlKHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbikpLnRoZW4oZmluaXNoRGVhY3RpdmF0aW9uLCBmaW5pc2hEZWFjdGl2YXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGZpbmlzaERlYWN0aXZhdGlvbigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UocGF1c2VPcHRpb25zKSB7XG4gICAgICBpZiAoc3RhdGUucGF1c2VkIHx8ICFzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgb25QYXVzZSA9IGdldE9wdGlvbihwYXVzZU9wdGlvbnMsICdvblBhdXNlJyk7XG4gICAgICB2YXIgb25Qb3N0UGF1c2UgPSBnZXRPcHRpb24ocGF1c2VPcHRpb25zLCAnb25Qb3N0UGF1c2UnKTtcbiAgICAgIHN0YXRlLnBhdXNlZCA9IHRydWU7XG4gICAgICBvblBhdXNlID09PSBudWxsIHx8IG9uUGF1c2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUGF1c2UoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgdXBkYXRlT2JzZXJ2ZWROb2RlcygpO1xuICAgICAgb25Qb3N0UGF1c2UgPT09IG51bGwgfHwgb25Qb3N0UGF1c2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUG9zdFBhdXNlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHVucGF1c2U6IGZ1bmN0aW9uIHVucGF1c2UodW5wYXVzZU9wdGlvbnMpIHtcbiAgICAgIGlmICghc3RhdGUucGF1c2VkIHx8ICFzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgb25VbnBhdXNlID0gZ2V0T3B0aW9uKHVucGF1c2VPcHRpb25zLCAnb25VbnBhdXNlJyk7XG4gICAgICB2YXIgb25Qb3N0VW5wYXVzZSA9IGdldE9wdGlvbih1bnBhdXNlT3B0aW9ucywgJ29uUG9zdFVucGF1c2UnKTtcbiAgICAgIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgb25VbnBhdXNlID09PSBudWxsIHx8IG9uVW5wYXVzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25VbnBhdXNlKCk7XG4gICAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgICAgIHVwZGF0ZU9ic2VydmVkTm9kZXMoKTtcbiAgICAgIG9uUG9zdFVucGF1c2UgPT09IG51bGwgfHwgb25Qb3N0VW5wYXVzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Qb3N0VW5wYXVzZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB1cGRhdGVDb250YWluZXJFbGVtZW50czogZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyRWxlbWVudHMoY29udGFpbmVyRWxlbWVudHMpIHtcbiAgICAgIHZhciBlbGVtZW50c0FzQXJyYXkgPSBbXS5jb25jYXQoY29udGFpbmVyRWxlbWVudHMpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHN0YXRlLmNvbnRhaW5lcnMgPSBlbGVtZW50c0FzQXJyYXkubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgPyBkb2MucXVlcnlTZWxlY3RvcihlbGVtZW50KSA6IGVsZW1lbnQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgfVxuICAgICAgdXBkYXRlT2JzZXJ2ZWROb2RlcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIC8vIGluaXRpYWxpemUgY29udGFpbmVyIGVsZW1lbnRzXG4gIHRyYXAudXBkYXRlQ29udGFpbmVyRWxlbWVudHMoZWxlbWVudHMpO1xuICByZXR1cm4gdHJhcDtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUZvY3VzVHJhcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtdHJhcC5lc20uanMubWFwXG4iLCIvKiFcbiogdGFiYmFibGUgNi4xLjJcbiogQGxpY2Vuc2UgTUlULCBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC90YWJiYWJsZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xuLy8gTk9URTogc2VwYXJhdGUgYDpub3QoKWAgc2VsZWN0b3JzIGhhcyBicm9hZGVyIGJyb3dzZXIgc3VwcG9ydCB0aGFuIHRoZSBuZXdlclxuLy8gIGA6bm90KFtpbmVydF0sIFtpbmVydF0gKilgIChGZWIgMjAyMylcbi8vIENBUkVGVUw6IEpTRG9tIGRvZXMgbm90IHN1cHBvcnQgYDpub3QoW2luZXJ0XSAqKWAgYXMgYSBzZWxlY3RvcjsgdXNpbmcgaXQgY2F1c2VzXG4vLyAgdGhlIGVudGlyZSBxdWVyeSB0byBmYWlsLCByZXN1bHRpbmcgaW4gbm8gbm9kZXMgZm91bmQsIHdoaWNoIHdpbGwgYnJlYWsgYSBsb3Rcbi8vICBvZiB0aGluZ3MuLi4gc28gd2UgaGF2ZSB0byByZWx5IG9uIEpTIHRvIGlkZW50aWZ5IG5vZGVzIGluc2lkZSBhbiBpbmVydCBjb250YWluZXJcbnZhciBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbJ2lucHV0Om5vdChbaW5lcnRdKScsICdzZWxlY3Q6bm90KFtpbmVydF0pJywgJ3RleHRhcmVhOm5vdChbaW5lcnRdKScsICdhW2hyZWZdOm5vdChbaW5lcnRdKScsICdidXR0b246bm90KFtpbmVydF0pJywgJ1t0YWJpbmRleF06bm90KHNsb3QpOm5vdChbaW5lcnRdKScsICdhdWRpb1tjb250cm9sc106bm90KFtpbmVydF0pJywgJ3ZpZGVvW2NvbnRyb2xzXTpub3QoW2luZXJ0XSknLCAnW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSk6bm90KFtpbmVydF0pJywgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlOm5vdChbaW5lcnRdKScsICdkZXRhaWxzOm5vdChbaW5lcnRdKSddO1xudmFyIGNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovY2FuZGlkYXRlU2VsZWN0b3JzLmpvaW4oJywnKTtcbnZhciBOb0VsZW1lbnQgPSB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCc7XG52YXIgbWF0Y2hlcyA9IE5vRWxlbWVudCA/IGZ1bmN0aW9uICgpIHt9IDogRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG52YXIgZ2V0Um9vdE5vZGUgPSAhTm9FbGVtZW50ICYmIEVsZW1lbnQucHJvdG90eXBlLmdldFJvb3ROb2RlID8gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JGdldFJvb3ROb2RlO1xuICByZXR1cm4gZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2VsZW1lbnQkZ2V0Um9vdE5vZGUgPSBlbGVtZW50LmdldFJvb3ROb2RlKSA9PT0gbnVsbCB8fCBfZWxlbWVudCRnZXRSb290Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VsZW1lbnQkZ2V0Um9vdE5vZGUuY2FsbChlbGVtZW50KTtcbn0gOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBub2RlIGlzIGluZXJ0IG9yIGluIGFuIGluZXJ0IGFuY2VzdG9yLlxuICogQHBhcmFtIHtFbGVtZW50fSBbbm9kZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xvb2tVcF0gSWYgdHJ1ZSBhbmQgYG5vZGVgIGlzIG5vdCBpbmVydCwgbG9va3MgdXAgYXQgYW5jZXN0b3JzIHRvXG4gKiAgc2VlIGlmIGFueSBvZiB0aGVtIGFyZSBpbmVydC4gSWYgZmFsc2UsIG9ubHkgYG5vZGVgIGl0c2VsZiBpcyBjb25zaWRlcmVkLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgaW5lcnQgaXRzZWxmIG9yIGJ5IHdheSBvZiBiZWluZyBpbiBhbiBpbmVydCBhbmNlc3Rvci5cbiAqICBGYWxzZSBpZiBgbm9kZWAgaXMgZmFsc3kuXG4gKi9cbnZhciBpc0luZXJ0ID0gZnVuY3Rpb24gaXNJbmVydChub2RlLCBsb29rVXApIHtcbiAgdmFyIF9ub2RlJGdldEF0dHJpYnV0ZTtcbiAgaWYgKGxvb2tVcCA9PT0gdm9pZCAwKSB7XG4gICAgbG9va1VwID0gdHJ1ZTtcbiAgfVxuICAvLyBDQVJFRlVMOiBKU0RvbSBkb2VzIG5vdCBzdXBwb3J0IGluZXJ0IGF0IGFsbCwgc28gd2UgY2FuJ3QgdXNlIHRoZSBgSFRNTEVsZW1lbnQuaW5lcnRgXG4gIC8vICBKUyBBUEkgcHJvcGVydHk7IHdlIGhhdmUgdG8gY2hlY2sgdGhlIGF0dHJpYnV0ZSwgd2hpY2ggY2FuIGVpdGhlciBiZSBlbXB0eSBvciAndHJ1ZSc7XG4gIC8vICBpZiBpdCdzIGBudWxsYCAobm90IHNwZWNpZmllZCkgb3IgJ2ZhbHNlJywgaXQncyBhbiBhY3RpdmUgZWxlbWVudFxuICB2YXIgaW5lcnRBdHQgPSBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbm9kZSRnZXRBdHRyaWJ1dGUgPSBub2RlLmdldEF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX25vZGUkZ2V0QXR0cmlidXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRnZXRBdHRyaWJ1dGUuY2FsbChub2RlLCAnaW5lcnQnKTtcbiAgdmFyIGluZXJ0ID0gaW5lcnRBdHQgPT09ICcnIHx8IGluZXJ0QXR0ID09PSAndHJ1ZSc7XG5cbiAgLy8gTk9URTogdGhpcyBjb3VsZCBhbHNvIGJlIGhhbmRsZWQgd2l0aCBgbm9kZS5tYXRjaGVzKCdbaW5lcnRdLCA6aXMoW2luZXJ0XSAqKScpYFxuICAvLyAgaWYgaXQgd2VyZW4ndCBmb3IgYG1hdGNoZXMoKWAgbm90IGJlaW5nIGEgZnVuY3Rpb24gb24gc2hhZG93IHJvb3RzOyB0aGUgZm9sbG93aW5nXG4gIC8vICBjb2RlIHdvcmtzIGZvciBhbnkga2luZCBvZiBub2RlXG4gIC8vIENBUkVGVUw6IEpTRG9tIGRvZXMgbm90IGFwcGVhciB0byBzdXBwb3J0IGNlcnRhaW4gc2VsZWN0b3JzIGxpa2UgYDpub3QoW2luZXJ0XSAqKWBcbiAgLy8gIHNvIGl0IGxpa2VseSB3b3VsZCBub3Qgc3VwcG9ydCBgOmlzKFtpbmVydF0gKilgIGVpdGhlci4uLlxuICB2YXIgcmVzdWx0ID0gaW5lcnQgfHwgbG9va1VwICYmIG5vZGUgJiYgaXNJbmVydChub2RlLnBhcmVudE5vZGUpOyAvLyByZWN1cnNpdmVcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgbm9kZSdzIGNvbnRlbnQgaXMgZWRpdGFibGUuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtub2RlXVxuICogQHJldHVybnMgVHJ1ZSBpZiBpdCdzIGNvbnRlbnQtZWRpdGFibGU7IGZhbHNlIGlmIGl0J3Mgbm90IG9yIGBub2RlYCBpcyBmYWxzeS5cbiAqL1xudmFyIGlzQ29udGVudEVkaXRhYmxlID0gZnVuY3Rpb24gaXNDb250ZW50RWRpdGFibGUobm9kZSkge1xuICB2YXIgX25vZGUkZ2V0QXR0cmlidXRlMjtcbiAgLy8gQ0FSRUZVTDogSlNEb20gZG9lcyBub3Qgc3VwcG9ydCB0aGUgYEhUTUxFbGVtZW50LmlzQ29udGVudEVkaXRhYmxlYCBBUEkgc28gd2UgaGF2ZVxuICAvLyAgdG8gdXNlIHRoZSBhdHRyaWJ1dGUgZGlyZWN0bHkgdG8gY2hlY2sgZm9yIHRoaXMsIHdoaWNoIGNhbiBlaXRoZXIgYmUgZW1wdHkgb3IgJ3RydWUnO1xuICAvLyAgaWYgaXQncyBgbnVsbGAgKG5vdCBzcGVjaWZpZWQpIG9yICdmYWxzZScsIGl0J3MgYSBub24tZWRpdGFibGUgZWxlbWVudFxuICB2YXIgYXR0VmFsdWUgPSBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbm9kZSRnZXRBdHRyaWJ1dGUyID0gbm9kZS5nZXRBdHRyaWJ1dGUpID09PSBudWxsIHx8IF9ub2RlJGdldEF0dHJpYnV0ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGdldEF0dHJpYnV0ZTIuY2FsbChub2RlLCAnY29udGVudGVkaXRhYmxlJyk7XG4gIHJldHVybiBhdHRWYWx1ZSA9PT0gJycgfHwgYXR0VmFsdWUgPT09ICd0cnVlJztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBjb250YWluZXIgdG8gY2hlY2sgaW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIHRvIGNoZWNrXG4gKiBAcGFyYW0geyhub2RlOiBFbGVtZW50KSA9PiBib29sZWFufSBmaWx0ZXIgZmlsdGVyIGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50W119XG4gKi9cbnZhciBnZXRDYW5kaWRhdGVzID0gZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlcyhlbCwgaW5jbHVkZUNvbnRhaW5lciwgZmlsdGVyKSB7XG4gIC8vIGV2ZW4gaWYgYGluY2x1ZGVDb250YWluZXI9ZmFsc2VgLCB3ZSBzdGlsbCBoYXZlIHRvIGNoZWNrIGl0IGZvciBpbmVydG5lc3MgYmVjYXVzZVxuICAvLyAgaWYgaXQncyBpbmVydCwgYWxsIGl0cyBjaGlsZHJlbiBhcmUgaW5lcnRcbiAgaWYgKGlzSW5lcnQoZWwpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBjYW5kaWRhdGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2FuZGlkYXRlU2VsZWN0b3IpKTtcbiAgaWYgKGluY2x1ZGVDb250YWluZXIgJiYgbWF0Y2hlcy5jYWxsKGVsLCBjYW5kaWRhdGVTZWxlY3RvcikpIHtcbiAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICB9XG4gIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcihmaWx0ZXIpO1xuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIEdldFNoYWRvd1Jvb3RcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCB0byBjaGVjayBmb3Igc2hhZG93IHJvb3RcbiAqIEByZXR1cm5zIHtTaGFkb3dSb290fGJvb2xlYW59IFNoYWRvd1Jvb3QgaWYgYXZhaWxhYmxlIG9yIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHNoYWRvd1Jvb3QgaXMgYXR0YWNoZWQgYnV0IG5vdCBhdmFpbGFibGUuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU2hhZG93Um9vdEZpbHRlclxuICogQHBhcmFtIHtFbGVtZW50fSBzaGFkb3dIb3N0Tm9kZSB0aGUgZWxlbWVudCB3aGljaCBjb250YWlucyBzaGFkb3cgY29udGVudFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgYSBzaGFkb3cgcm9vdCBjb3VsZCBwb3RlbnRpYWxseSBjb250YWluIHZhbGlkIGNhbmRpZGF0ZXMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDYW5kaWRhdGVTY29wZVxuICogQHByb3BlcnR5IHtFbGVtZW50fSBzY29wZVBhcmVudCBjb250YWlucyBpbm5lciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge0VsZW1lbnRbXX0gY2FuZGlkYXRlcyBsaXN0IG9mIGNhbmRpZGF0ZXMgZm91bmQgaW4gdGhlIHNjb3BlIHBhcmVudFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSXRlcmF0aXZlT3B0aW9uc1xuICogQHByb3BlcnR5IHtHZXRTaGFkb3dSb290fGJvb2xlYW59IGdldFNoYWRvd1Jvb3QgdHJ1ZSBpZiBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkOyBmYWxzeSBpZiBub3Q7XG4gKiAgaWYgYSBmdW5jdGlvbiwgaW1wbGllcyBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkIGFuZCBlaXRoZXIgcmV0dXJucyB0aGUgc2hhZG93IHJvb3Qgb2YgYW4gZWxlbWVudFxuICogIG9yIGEgYm9vbGVhbiBzdGF0aW5nIGlmIGl0IGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgcm9vdFxuICogQHByb3BlcnR5IHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZsYXR0ZW4gaWYgdHJ1ZSB0aGVuIHJlc3VsdCB3aWxsIGZsYXR0ZW4gYW55IENhbmRpZGF0ZVNjb3BlIGludG8gdGhlIHJldHVybmVkIGxpc3RcbiAqIEBwcm9wZXJ0eSB7U2hhZG93Um9vdEZpbHRlcn0gc2hhZG93Um9vdEZpbHRlciBmaWx0ZXIgc2hhZG93IHJvb3RzO1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50W119IGVsZW1lbnRzIGxpc3Qgb2YgZWxlbWVudCBjb250YWluZXJzIHRvIG1hdGNoIGNhbmRpZGF0ZXMgZnJvbVxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgbGlzdCB0byBjaGVja1xuICogQHBhcmFtIHtJdGVyYXRpdmVPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlU2NvcGU+fVxuICovXG52YXIgZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5ID0gZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KGVsZW1lbnRzLCBpbmNsdWRlQ29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHZhciBjYW5kaWRhdGVzID0gW107XG4gIHZhciBlbGVtZW50c1RvQ2hlY2sgPSBBcnJheS5mcm9tKGVsZW1lbnRzKTtcbiAgd2hpbGUgKGVsZW1lbnRzVG9DaGVjay5sZW5ndGgpIHtcbiAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzVG9DaGVjay5zaGlmdCgpO1xuICAgIGlmIChpc0luZXJ0KGVsZW1lbnQsIGZhbHNlKSkge1xuICAgICAgLy8gbm8gbmVlZCB0byBsb29rIHVwIHNpbmNlIHdlJ3JlIGRyaWxsaW5nIGRvd25cbiAgICAgIC8vIGFueXRoaW5nIGluc2lkZSB0aGlzIGNvbnRhaW5lciB3aWxsIGFsc28gYmUgaW5lcnRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnU0xPVCcpIHtcbiAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNsb3Qgc2NvcGUgKHNsb3QgaXRzZWxmIGNhbm5vdCBiZSBmb2N1c2FibGUpXG4gICAgICB2YXIgYXNzaWduZWQgPSBlbGVtZW50LmFzc2lnbmVkRWxlbWVudHMoKTtcbiAgICAgIHZhciBjb250ZW50ID0gYXNzaWduZWQubGVuZ3RoID8gYXNzaWduZWQgOiBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgdmFyIG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoY29udGVudCwgdHJ1ZSwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaC5hcHBseShjYW5kaWRhdGVzLCBuZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgc2NvcGVQYXJlbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgY2FuZGlkYXRlczogbmVzdGVkQ2FuZGlkYXRlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2hlY2sgY2FuZGlkYXRlIGVsZW1lbnRcbiAgICAgIHZhciB2YWxpZENhbmRpZGF0ZSA9IG1hdGNoZXMuY2FsbChlbGVtZW50LCBjYW5kaWRhdGVTZWxlY3Rvcik7XG4gICAgICBpZiAodmFsaWRDYW5kaWRhdGUgJiYgb3B0aW9ucy5maWx0ZXIoZWxlbWVudCkgJiYgKGluY2x1ZGVDb250YWluZXIgfHwgIWVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKSkge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBzaGFkb3cgY29udGVudCBpZiBwb3NzaWJsZVxuICAgICAgdmFyIHNoYWRvd1Jvb3QgPSBlbGVtZW50LnNoYWRvd1Jvb3QgfHxcbiAgICAgIC8vIGNoZWNrIGZvciBhbiB1bmRpc2Nsb3NlZCBzaGFkb3dcbiAgICAgIHR5cGVvZiBvcHRpb25zLmdldFNoYWRvd1Jvb3QgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5nZXRTaGFkb3dSb290KGVsZW1lbnQpO1xuXG4gICAgICAvLyBubyBpbmVydCBsb29rIHVwIGJlY2F1c2Ugd2UncmUgYWxyZWFkeSBkcmlsbGluZyBkb3duIGFuZCBjaGVja2luZyBmb3IgaW5lcnRuZXNzXG4gICAgICAvLyAgb24gdGhlIHdheSBkb3duLCBzbyBhbGwgY29udGFpbmVycyB0byB0aGlzIHJvb3Qgbm9kZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW5cbiAgICAgIC8vICB2ZXR0ZWQgYXMgbm9uLWluZXJ0XG4gICAgICB2YXIgdmFsaWRTaGFkb3dSb290ID0gIWlzSW5lcnQoc2hhZG93Um9vdCwgZmFsc2UpICYmICghb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyIHx8IG9wdGlvbnMuc2hhZG93Um9vdEZpbHRlcihlbGVtZW50KSk7XG4gICAgICBpZiAoc2hhZG93Um9vdCAmJiB2YWxpZFNoYWRvd1Jvb3QpIHtcbiAgICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2NvcGUgSUlGIGEgc2hhZG93IHJvb3Qgbm9kZSB3YXMgZ2l2ZW47IG90aGVyd2lzZSwgYW4gdW5kaXNjbG9zZWRcbiAgICAgICAgLy8gIHNoYWRvdyBleGlzdHMsIHNvIGxvb2sgYXQgbGlnaHQgZG9tIGNoaWxkcmVuIGFzIGZhbGxiYWNrIEJVVCBjcmVhdGUgYSBzY29wZSBmb3IgYW55XG4gICAgICAgIC8vICBjaGlsZCBjYW5kaWRhdGVzIGZvdW5kIGJlY2F1c2UgdGhleSdyZSBsaWtlbHkgc2xvdHRlZCBlbGVtZW50cyAoZWxlbWVudHMgdGhhdCBhcmVcbiAgICAgICAgLy8gIGNoaWxkcmVuIG9mIHRoZSB3ZWIgY29tcG9uZW50IGVsZW1lbnQgKHdoaWNoIGhhcyB0aGUgc2hhZG93KSwgaW4gdGhlIGxpZ2h0IGRvbSwgYnV0XG4gICAgICAgIC8vICBzbG90dGVkIHNvbWV3aGVyZSBfaW5zaWRlXyB0aGUgdW5kaXNjbG9zZWQgc2hhZG93KSAtLSB0aGUgc2NvcGUgaXMgY3JlYXRlZCBiZWxvdyxcbiAgICAgICAgLy8gIF9hZnRlcl8gd2UgcmV0dXJuIGZyb20gdGhpcyByZWN1cnNpdmUgY2FsbFxuICAgICAgICB2YXIgX25lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoc2hhZG93Um9vdCA9PT0gdHJ1ZSA/IGVsZW1lbnQuY2hpbGRyZW4gOiBzaGFkb3dSb290LmNoaWxkcmVuLCB0cnVlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaC5hcHBseShjYW5kaWRhdGVzLCBfbmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3BlUGFyZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgY2FuZGlkYXRlczogX25lc3RlZENhbmRpZGF0ZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlcmUncyBub3Qgc2hhZG93IHNvIGp1c3QgZGlnIGludG8gdGhlIGVsZW1lbnQncyAobGlnaHQgZG9tKSBjaGlsZHJlblxuICAgICAgICAvLyAgX193aXRob3V0X18gZ2l2aW5nIHRoZSBlbGVtZW50IHNwZWNpYWwgc2NvcGUgdHJlYXRtZW50XG4gICAgICAgIGVsZW1lbnRzVG9DaGVjay51bnNoaWZ0LmFwcGx5KGVsZW1lbnRzVG9DaGVjaywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcbnZhciBnZXRUYWJpbmRleCA9IGZ1bmN0aW9uIGdldFRhYmluZGV4KG5vZGUsIGlzU2NvcGUpIHtcbiAgaWYgKG5vZGUudGFiSW5kZXggPCAwKSB7XG4gICAgLy8gaW4gQ2hyb21lLCA8ZGV0YWlscy8+LCA8YXVkaW8gY29udHJvbHMvPiBhbmQgPHZpZGVvIGNvbnRyb2xzLz4gZWxlbWVudHMgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgLTEgd2hlbiB0aGUgJ3RhYmluZGV4JyBhdHRyaWJ1dGUgaXNuJ3Qgc3BlY2lmaWVkIGluIHRoZSBET00sXG4gICAgLy8geWV0IHRoZXkgYXJlIHN0aWxsIHBhcnQgb2YgdGhlIHJlZ3VsYXIgdGFiIG9yZGVyOyBpbiBGRiwgdGhleSBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAwOyBzaW5jZSBDaHJvbWUgc3RpbGwgcHV0cyB0aG9zZSBlbGVtZW50cyBpbiB0aGUgcmVndWxhciB0YWJcbiAgICAvLyBvcmRlciwgY29uc2lkZXIgdGhlaXIgdGFiIGluZGV4IHRvIGJlIDAuXG4gICAgLy8gQWxzbyBicm93c2VycyBkbyBub3QgcmV0dXJuIGB0YWJJbmRleGAgY29ycmVjdGx5IGZvciBjb250ZW50RWRpdGFibGUgbm9kZXM7XG4gICAgLy8gc28gaWYgdGhleSBkb24ndCBoYXZlIGEgdGFiaW5kZXggYXR0cmlidXRlIHNwZWNpZmljYWxseSBzZXQsIGFzc3VtZSBpdCdzIDAuXG4gICAgLy9cbiAgICAvLyBpc1Njb3BlIGlzIHBvc2l0aXZlIGZvciBjdXN0b20gZWxlbWVudCB3aXRoIHNoYWRvdyByb290IG9yIHNsb3QgdGhhdCBieSBkZWZhdWx0XG4gICAgLy8gaGF2ZSB0YWJJbmRleCAtMSwgYnV0IG5lZWQgdG8gYmUgc29ydGVkIGJ5IGRvY3VtZW50IG9yZGVyIGluIG9yZGVyIGZvciB0aGVpclxuICAgIC8vIGNvbnRlbnQgdG8gYmUgaW5zZXJ0ZWQgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb25cbiAgICBpZiAoKGlzU2NvcGUgfHwgL14oQVVESU98VklERU98REVUQUlMUykkLy50ZXN0KG5vZGUudGFnTmFtZSkgfHwgaXNDb250ZW50RWRpdGFibGUobm9kZSkpICYmIGlzTmFOKHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGUudGFiSW5kZXg7XG59O1xudmFyIHNvcnRPcmRlcmVkVGFiYmFibGVzID0gZnVuY3Rpb24gc29ydE9yZGVyZWRUYWJiYWJsZXMoYSwgYikge1xuICByZXR1cm4gYS50YWJJbmRleCA9PT0gYi50YWJJbmRleCA/IGEuZG9jdW1lbnRPcmRlciAtIGIuZG9jdW1lbnRPcmRlciA6IGEudGFiSW5kZXggLSBiLnRhYkluZGV4O1xufTtcbnZhciBpc0lucHV0ID0gZnVuY3Rpb24gaXNJbnB1dChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdJTlBVVCc7XG59O1xudmFyIGlzSGlkZGVuSW5wdXQgPSBmdW5jdGlvbiBpc0hpZGRlbklucHV0KG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAnaGlkZGVuJztcbn07XG52YXIgaXNEZXRhaWxzV2l0aFN1bW1hcnkgPSBmdW5jdGlvbiBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB7XG4gIHZhciByID0gbm9kZS50YWdOYW1lID09PSAnREVUQUlMUycgJiYgQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG5vZGUuY2hpbGRyZW4pLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLnRhZ05hbWUgPT09ICdTVU1NQVJZJztcbiAgfSk7XG4gIHJldHVybiByO1xufTtcbnZhciBnZXRDaGVja2VkUmFkaW8gPSBmdW5jdGlvbiBnZXRDaGVja2VkUmFkaW8obm9kZXMsIGZvcm0pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkICYmIG5vZGVzW2ldLmZvcm0gPT09IGZvcm0pIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbn07XG52YXIgaXNUYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gaXNUYWJiYWJsZVJhZGlvKG5vZGUpIHtcbiAgaWYgKCFub2RlLm5hbWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgcmFkaW9TY29wZSA9IG5vZGUuZm9ybSB8fCBnZXRSb290Tm9kZShub2RlKTtcbiAgdmFyIHF1ZXJ5UmFkaW9zID0gZnVuY3Rpb24gcXVlcnlSYWRpb3MobmFtZSkge1xuICAgIHJldHVybiByYWRpb1Njb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJyk7XG4gIH07XG4gIHZhciByYWRpb1NldDtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuQ1NTICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkNTUy5lc2NhcGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKHdpbmRvdy5DU1MuZXNjYXBlKG5vZGUubmFtZSkpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKG5vZGUubmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcignTG9va3MgbGlrZSB5b3UgaGF2ZSBhIHJhZGlvIGJ1dHRvbiB3aXRoIGEgbmFtZSBhdHRyaWJ1dGUgY29udGFpbmluZyBpbnZhbGlkIENTUyBzZWxlY3RvciBjaGFyYWN0ZXJzIGFuZCBuZWVkIHRoZSBDU1MuZXNjYXBlIHBvbHlmaWxsOiAlcycsIGVyci5tZXNzYWdlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdmFyIGNoZWNrZWQgPSBnZXRDaGVja2VkUmFkaW8ocmFkaW9TZXQsIG5vZGUuZm9ybSk7XG4gIHJldHVybiAhY2hlY2tlZCB8fCBjaGVja2VkID09PSBub2RlO1xufTtcbnZhciBpc1JhZGlvID0gZnVuY3Rpb24gaXNSYWRpbyhub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ3JhZGlvJztcbn07XG52YXIgaXNOb25UYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHtcbiAgcmV0dXJuIGlzUmFkaW8obm9kZSkgJiYgIWlzVGFiYmFibGVSYWRpbyhub2RlKTtcbn07XG5cbi8vIGRldGVybWluZXMgaWYgYSBub2RlIGlzIHVsdGltYXRlbHkgYXR0YWNoZWQgdG8gdGhlIHdpbmRvdydzIGRvY3VtZW50XG52YXIgaXNOb2RlQXR0YWNoZWQgPSBmdW5jdGlvbiBpc05vZGVBdHRhY2hlZChub2RlKSB7XG4gIHZhciBfbm9kZVJvb3Q7XG4gIC8vIFRoZSByb290IG5vZGUgaXMgdGhlIHNoYWRvdyByb290IGlmIHRoZSBub2RlIGlzIGluIGEgc2hhZG93IERPTTsgc29tZSBkb2N1bWVudCBvdGhlcndpc2VcbiAgLy8gIChidXQgTk9UIF90aGVfIGRvY3VtZW50OyBzZWUgc2Vjb25kICdJZicgY29tbWVudCBiZWxvdyBmb3IgbW9yZSkuXG4gIC8vIElmIHJvb3ROb2RlIGlzIHNoYWRvdyByb290LCBpdCdsbCBoYXZlIGEgaG9zdCwgd2hpY2ggaXMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHNoYWRvd1xuICAvLyAgaXMgYXR0YWNoZWQsIGFuZCB0aGUgb25lIHdlIG5lZWQgdG8gY2hlY2sgaWYgaXQncyBpbiB0aGUgZG9jdW1lbnQgb3Igbm90IChiZWNhdXNlIHRoZVxuICAvLyAgc2hhZG93LCBhbmQgYWxsIG5vZGVzIGl0IGNvbnRhaW5zLCBpcyBuZXZlciBjb25zaWRlcmVkIGluIHRoZSBkb2N1bWVudCBzaW5jZSBzaGFkb3dzXG4gIC8vICBiZWhhdmUgbGlrZSBzZWxmLWNvbnRhaW5lZCBET01zOyBidXQgaWYgdGhlIHNoYWRvdydzIEhPU1QsIHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50LFxuICAvLyAgaXMgaGlkZGVuLCBvciBpcyBub3QgaW4gdGhlIGRvY3VtZW50IGl0c2VsZiBidXQgaXMgZGV0YWNoZWQsIGl0IHdpbGwgYWZmZWN0IHRoZSBzaGFkb3cnc1xuICAvLyAgdmlzaWJpbGl0eSwgaW5jbHVkaW5nIGFsbCB0aGUgbm9kZXMgaXQgY29udGFpbnMpLiBUaGUgaG9zdCBjb3VsZCBiZSBhbnkgbm9ybWFsIG5vZGUsXG4gIC8vICBvciBhIGN1c3RvbSBlbGVtZW50IChpLmUuIHdlYiBjb21wb25lbnQpLiBFaXRoZXIgd2F5LCB0aGF0J3MgdGhlIG9uZSB0aGF0IGlzIGNvbnNpZGVyZWRcbiAgLy8gIHBhcnQgb2YgdGhlIGRvY3VtZW50LCBub3QgdGhlIHNoYWRvdyByb290LCBub3IgYW55IG9mIGl0cyBjaGlsZHJlbiAoaS5lLiB0aGUgbm9kZSBiZWluZ1xuICAvLyAgdGVzdGVkKS5cbiAgLy8gVG8gZnVydGhlciBjb21wbGljYXRlIHRoaW5ncywgd2UgaGF2ZSB0byBsb29rIGFsbCB0aGUgd2F5IHVwIHVudGlsIHdlIGZpbmQgYSBzaGFkb3cgSE9TVFxuICAvLyAgdGhhdCBpcyBhdHRhY2hlZCAob3IgZmluZCBub25lKSBiZWNhdXNlIHRoZSBub2RlIG1pZ2h0IGJlIGluIG5lc3RlZCBzaGFkb3dzLi4uXG4gIC8vIElmIHJvb3ROb2RlIGlzIG5vdCBhIHNoYWRvdyByb290LCBpdCB3b24ndCBoYXZlIGEgaG9zdCwgYW5kIHNvIHJvb3ROb2RlIHNob3VsZCBiZSB0aGVcbiAgLy8gIGRvY3VtZW50IChwZXIgdGhlIGRvY3MpIGFuZCB3aGlsZSBpdCdzIGEgRG9jdW1lbnQtdHlwZSBvYmplY3QsIHRoYXQgZG9jdW1lbnQgZG9lcyBub3RcbiAgLy8gIGFwcGVhciB0byBiZSB0aGUgc2FtZSBhcyB0aGUgbm9kZSdzIGBvd25lckRvY3VtZW50YCBmb3Igc29tZSByZWFzb24sIHNvIGl0J3Mgc2FmZXJcbiAgLy8gIHRvIGlnbm9yZSB0aGUgcm9vdE5vZGUgYXQgdGhpcyBwb2ludCwgYW5kIHVzZSBgbm9kZS5vd25lckRvY3VtZW50YC4gT3RoZXJ3aXNlLFxuICAvLyAgdXNpbmcgYHJvb3ROb2RlLmNvbnRhaW5zKG5vZGUpYCB3aWxsIF9hbHdheXNfIGJlIHRydWUgd2UnbGwgZ2V0IGZhbHNlLXBvc2l0aXZlcyB3aGVuXG4gIC8vICBub2RlIGlzIGFjdHVhbGx5IGRldGFjaGVkLlxuICAvLyBOT1RFOiBJZiBgbm9kZVJvb3RIb3N0YCBvciBgbm9kZWAgaGFwcGVucyB0byBiZSB0aGUgYGRvY3VtZW50YCBpdHNlbGYgKHdoaWNoIGlzIHBvc3NpYmxlXG4gIC8vICBpZiBhIHRhYmJhYmxlL2ZvY3VzYWJsZSBub2RlIHdhcyBxdWlja2x5IGFkZGVkIHRvIHRoZSBET00sIGZvY3VzZWQsIGFuZCB0aGVuIHJlbW92ZWRcbiAgLy8gIGZyb20gdGhlIERPTSBhcyBpbiBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC9mb2N1cy10cmFwLXJlYWN0L2lzc3Vlcy85MDUpLCB0aGVuXG4gIC8vICBgb3duZXJEb2N1bWVudGAgd2lsbCBiZSBgbnVsbGAsIGhlbmNlIHRoZSBvcHRpb25hbCBjaGFpbmluZyBvbiBpdC5cbiAgdmFyIG5vZGVSb290ID0gbm9kZSAmJiBnZXRSb290Tm9kZShub2RlKTtcbiAgdmFyIG5vZGVSb290SG9zdCA9IChfbm9kZVJvb3QgPSBub2RlUm9vdCkgPT09IG51bGwgfHwgX25vZGVSb290ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZVJvb3QuaG9zdDtcblxuICAvLyBpbiBzb21lIGNhc2VzLCBhIGRldGFjaGVkIG5vZGUgd2lsbCByZXR1cm4gaXRzZWxmIGFzIHRoZSByb290IGluc3RlYWQgb2YgYSBkb2N1bWVudCBvclxuICAvLyAgc2hhZG93IHJvb3Qgb2JqZWN0LCBpbiB3aGljaCBjYXNlLCB3ZSBzaG91bGRuJ3QgdHJ5IHRvIGxvb2sgZnVydGhlciB1cCB0aGUgaG9zdCBjaGFpblxuICB2YXIgYXR0YWNoZWQgPSBmYWxzZTtcbiAgaWYgKG5vZGVSb290ICYmIG5vZGVSb290ICE9PSBub2RlKSB7XG4gICAgdmFyIF9ub2RlUm9vdEhvc3QsIF9ub2RlUm9vdEhvc3Qkb3duZXJEbywgX25vZGUkb3duZXJEb2N1bWVudDtcbiAgICBhdHRhY2hlZCA9ICEhKChfbm9kZVJvb3RIb3N0ID0gbm9kZVJvb3RIb3N0KSAhPT0gbnVsbCAmJiBfbm9kZVJvb3RIb3N0ICE9PSB2b2lkIDAgJiYgKF9ub2RlUm9vdEhvc3Qkb3duZXJEbyA9IF9ub2RlUm9vdEhvc3Qub3duZXJEb2N1bWVudCkgIT09IG51bGwgJiYgX25vZGVSb290SG9zdCRvd25lckRvICE9PSB2b2lkIDAgJiYgX25vZGVSb290SG9zdCRvd25lckRvLmNvbnRhaW5zKG5vZGVSb290SG9zdCkgfHwgbm9kZSAhPT0gbnVsbCAmJiBub2RlICE9PSB2b2lkIDAgJiYgKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9ub2RlJG93bmVyRG9jdW1lbnQgIT09IHZvaWQgMCAmJiBfbm9kZSRvd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGUpKTtcbiAgICB3aGlsZSAoIWF0dGFjaGVkICYmIG5vZGVSb290SG9zdCkge1xuICAgICAgdmFyIF9ub2RlUm9vdDIsIF9ub2RlUm9vdEhvc3QyLCBfbm9kZVJvb3RIb3N0MiRvd25lckQ7XG4gICAgICAvLyBzaW5jZSBpdCdzIG5vdCBhdHRhY2hlZCBhbmQgd2UgaGF2ZSBhIHJvb3QgaG9zdCwgdGhlIG5vZGUgTVVTVCBiZSBpbiBhIG5lc3RlZCBzaGFkb3cgRE9NLFxuICAgICAgLy8gIHdoaWNoIG1lYW5zIHdlIG5lZWQgdG8gZ2V0IHRoZSBob3N0J3MgaG9zdCBhbmQgY2hlY2sgaWYgdGhhdCBwYXJlbnQgaG9zdCBpcyBjb250YWluZWRcbiAgICAgIC8vICBpbiAoaS5lLiBhdHRhY2hlZCB0bykgdGhlIGRvY3VtZW50XG4gICAgICBub2RlUm9vdCA9IGdldFJvb3ROb2RlKG5vZGVSb290SG9zdCk7XG4gICAgICBub2RlUm9vdEhvc3QgPSAoX25vZGVSb290MiA9IG5vZGVSb290KSA9PT0gbnVsbCB8fCBfbm9kZVJvb3QyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZVJvb3QyLmhvc3Q7XG4gICAgICBhdHRhY2hlZCA9ICEhKChfbm9kZVJvb3RIb3N0MiA9IG5vZGVSb290SG9zdCkgIT09IG51bGwgJiYgX25vZGVSb290SG9zdDIgIT09IHZvaWQgMCAmJiAoX25vZGVSb290SG9zdDIkb3duZXJEID0gX25vZGVSb290SG9zdDIub3duZXJEb2N1bWVudCkgIT09IG51bGwgJiYgX25vZGVSb290SG9zdDIkb3duZXJEICE9PSB2b2lkIDAgJiYgX25vZGVSb290SG9zdDIkb3duZXJELmNvbnRhaW5zKG5vZGVSb290SG9zdCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXR0YWNoZWQ7XG59O1xudmFyIGlzWmVyb0FyZWEgPSBmdW5jdGlvbiBpc1plcm9BcmVhKG5vZGUpIHtcbiAgdmFyIF9ub2RlJGdldEJvdW5kaW5nQ2xpZSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgd2lkdGggPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUud2lkdGgsXG4gICAgaGVpZ2h0ID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLmhlaWdodDtcbiAgcmV0dXJuIHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMDtcbn07XG52YXIgaXNIaWRkZW4gPSBmdW5jdGlvbiBpc0hpZGRlbihub2RlLCBfcmVmKSB7XG4gIHZhciBkaXNwbGF5Q2hlY2sgPSBfcmVmLmRpc3BsYXlDaGVjayxcbiAgICBnZXRTaGFkb3dSb290ID0gX3JlZi5nZXRTaGFkb3dSb290O1xuICAvLyBOT1RFOiB2aXNpYmlsaXR5IHdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgbm9kZSBpcyBkZXRhY2hlZCBmcm9tIHRoZSBkb2N1bWVudFxuICAvLyAgKHNlZSBub3RlcyBhYm91dCB0aGlzIGZ1cnRoZXIgZG93biksIHdoaWNoIG1lYW5zIHdlIHdpbGwgY29uc2lkZXIgaXQgdmlzaWJsZVxuICAvLyAgKHRoaXMgaXMgbGVnYWN5IGJlaGF2aW9yIGZyb20gYSB2ZXJ5IGxvbmcgd2F5IGJhY2spXG4gIC8vIE5PVEU6IHdlIGNoZWNrIHRoaXMgcmVnYXJkbGVzcyBvZiBgZGlzcGxheUNoZWNrPVwibm9uZVwiYCBiZWNhdXNlIHRoaXMgaXMgYVxuICAvLyAgX3Zpc2liaWxpdHlfIGNoZWNrLCBub3QgYSBfZGlzcGxheV8gY2hlY2tcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUobm9kZSkudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaXNEaXJlY3RTdW1tYXJ5ID0gbWF0Y2hlcy5jYWxsKG5vZGUsICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScpO1xuICB2YXIgbm9kZVVuZGVyRGV0YWlscyA9IGlzRGlyZWN0U3VtbWFyeSA/IG5vZGUucGFyZW50RWxlbWVudCA6IG5vZGU7XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZVVuZGVyRGV0YWlscywgJ2RldGFpbHM6bm90KFtvcGVuXSkgKicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFkaXNwbGF5Q2hlY2sgfHwgZGlzcGxheUNoZWNrID09PSAnZnVsbCcgfHwgZGlzcGxheUNoZWNrID09PSAnbGVnYWN5LWZ1bGwnKSB7XG4gICAgaWYgKHR5cGVvZiBnZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBmaWd1cmUgb3V0IGlmIHdlIHNob3VsZCBjb25zaWRlciB0aGUgbm9kZSB0byBiZSBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgYW5kIHVzZSB0aGVcbiAgICAgIC8vICAnbm9uLXplcm8tYXJlYScgZmFsbGJhY2tcbiAgICAgIHZhciBvcmlnaW5hbE5vZGUgPSBub2RlO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHZhciByb290Tm9kZSA9IGdldFJvb3ROb2RlKG5vZGUpO1xuICAgICAgICBpZiAocGFyZW50RWxlbWVudCAmJiAhcGFyZW50RWxlbWVudC5zaGFkb3dSb290ICYmIGdldFNoYWRvd1Jvb3QocGFyZW50RWxlbWVudCkgPT09IHRydWUgLy8gY2hlY2sgaWYgdGhlcmUncyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3dcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gbm9kZSBoYXMgYW4gdW5kaXNjbG9zZWQgc2hhZG93IHdoaWNoIG1lYW5zIHdlIGNhbiBvbmx5IHRyZWF0IGl0IGFzIGEgYmxhY2sgYm94LCBzbyB3ZVxuICAgICAgICAgIC8vICBmYWxsIGJhY2sgdG8gYSBub24temVyby1hcmVhIHRlc3RcbiAgICAgICAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgc2xvdFxuICAgICAgICAgIG5vZGUgPSBub2RlLmFzc2lnbmVkU2xvdDtcbiAgICAgICAgfSBlbHNlIGlmICghcGFyZW50RWxlbWVudCAmJiByb290Tm9kZSAhPT0gbm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgLy8gY3Jvc3Mgc2hhZG93IGJvdW5kYXJ5XG4gICAgICAgICAgbm9kZSA9IHJvb3ROb2RlLmhvc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaXRlcmF0ZSB1cCBub3JtYWwgZG9tXG4gICAgICAgICAgbm9kZSA9IHBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUgPSBvcmlnaW5hbE5vZGU7XG4gICAgfVxuICAgIC8vIGVsc2UsIGBnZXRTaGFkb3dSb290YCBtaWdodCBiZSB0cnVlLCBidXQgYWxsIHRoYXQgZG9lcyBpcyBlbmFibGUgc2hhZG93IERPTSBzdXBwb3J0XG4gICAgLy8gIChpLmUuIGl0IGRvZXMgbm90IGFsc28gcHJlc3VtZSB0aGF0IGFsbCBub2RlcyBtaWdodCBoYXZlIHVuZGlzY2xvc2VkIHNoYWRvd3MpOyBvclxuICAgIC8vICBpdCBtaWdodCBiZSBhIGZhbHN5IHZhbHVlLCB3aGljaCBtZWFucyBzaGFkb3cgRE9NIHN1cHBvcnQgaXMgZGlzYWJsZWRcblxuICAgIC8vIFNpbmNlIHdlIGRpZG4ndCBmaW5kIGl0IHNpdHRpbmcgaW4gYW4gdW5kaXNjbG9zZWQgc2hhZG93IChvciBzaGFkb3dzIGFyZSBkaXNhYmxlZClcbiAgICAvLyAgbm93IHdlIGNhbiBqdXN0IHRlc3QgdG8gc2VlIGlmIGl0IHdvdWxkIG5vcm1hbGx5IGJlIHZpc2libGUgb3Igbm90LCBwcm92aWRlZCBpdCdzXG4gICAgLy8gIGF0dGFjaGVkIHRvIHRoZSBtYWluIGRvY3VtZW50LlxuICAgIC8vIE5PVEU6IFdlIG11c3QgY29uc2lkZXIgY2FzZSB3aGVyZSBub2RlIGlzIGluc2lkZSBhIHNoYWRvdyBET00gYW5kIGdpdmVuIGRpcmVjdGx5IHRvXG4gICAgLy8gIGBpc1RhYmJhYmxlKClgIG9yIGBpc0ZvY3VzYWJsZSgpYCAtLSByZWdhcmRsZXNzIG9mIGBnZXRTaGFkb3dSb290YCBvcHRpb24gc2V0dGluZy5cblxuICAgIGlmIChpc05vZGVBdHRhY2hlZChub2RlKSkge1xuICAgICAgLy8gdGhpcyB3b3JrcyB3aGVyZXZlciB0aGUgbm9kZSBpczogaWYgdGhlcmUncyBhdCBsZWFzdCBvbmUgY2xpZW50IHJlY3QsIGl0J3NcbiAgICAgIC8vICBzb21laG93IGRpc3BsYXllZDsgaXQgYWxzbyBjb3ZlcnMgdGhlIENTUyAnZGlzcGxheTogY29udGVudHMnIGNhc2Ugd2hlcmUgdGhlXG4gICAgICAvLyAgbm9kZSBpdHNlbGYgaXMgaGlkZGVuIGluIHBsYWNlIG9mIGl0cyBjb250ZW50czsgYW5kIHRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2hcbiAgICAgIC8vICB1cCB0aGUgaGllcmFyY2h5IGVpdGhlclxuICAgICAgcmV0dXJuICFub2RlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIEVsc2UsIHRoZSBub2RlIGlzbid0IGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhlIGBnZXRDbGllbnRSZWN0cygpYFxuICAgIC8vICBBUEkgd2lsbCBfX2Fsd2F5c19fIHJldHVybiB6ZXJvIHJlY3RzICh0aGlzIGNhbiBoYXBwZW4sIGZvciBleGFtcGxlLCBpZiBSZWFjdFxuICAgIC8vICBpcyB1c2VkIHRvIHJlbmRlciBub2RlcyBvbnRvIGEgZGV0YWNoZWQgdHJlZSwgYXMgY29uZmlybWVkIGluIHRoaXMgdGhyZWFkOlxuICAgIC8vICBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzkxMTcjaXNzdWVjb21tZW50LTI4NDIyODg3MClcbiAgICAvL1xuICAgIC8vIEl0IGFsc28gbWVhbnMgdGhhdCBldmVuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLmRpc3BsYXkgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAvLyAgYmVjYXVzZSBzdHlsZXMgYXJlIG9ubHkgY29tcHV0ZWQgZm9yIG5vZGVzIHRoYXQgYXJlIGluIHRoZSBkb2N1bWVudC5cbiAgICAvL1xuICAgIC8vIE5PVEU6IFRISVMgSEFTIEJFRU4gVEhFIENBU0UgRk9SIFlFQVJTLiBJdCBpcyBub3QgbmV3LCBub3IgaXMgaXQgY2F1c2VkIGJ5IHRhYmJhYmxlXG4gICAgLy8gIHNvbWVob3cuIFRob3VnaCBpdCB3YXMgbmV2ZXIgc3RhdGVkIG9mZmljaWFsbHksIGFueW9uZSB3aG8gaGFzIGV2ZXIgdXNlZCB0YWJiYWJsZVxuICAgIC8vICBBUElzIG9uIG5vZGVzIGluIGRldGFjaGVkIGNvbnRhaW5lcnMgaGFzIGFjdHVhbGx5IGltcGxpY2l0bHkgdXNlZCB0YWJiYWJsZSBpbiB3aGF0XG4gICAgLy8gIHdhcyBsYXRlciAoYXMgb2YgdjUuMi4wIG9uIEFwciA5LCAyMDIxKSBjYWxsZWQgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgbW9kZSAtLSBlc3NlbnRpYWxseVxuICAgIC8vICBjb25zaWRlcmluZyBfX2V2ZXJ5dGhpbmdfXyB0byBiZSB2aXNpYmxlIGJlY2F1c2Ugb2YgdGhlIGlubmFiaWxpdHkgdG8gZGV0ZXJtaW5lIHN0eWxlcy5cbiAgICAvL1xuICAgIC8vIHY2LjAuMDogQXMgb2YgdGhpcyBtYWpvciByZWxlYXNlLCB0aGUgZGVmYXVsdCAnZnVsbCcgb3B0aW9uIF9fbm8gbG9uZ2VyIHRyZWF0cyBkZXRhY2hlZFxuICAgIC8vICBub2RlcyBhcyB2aXNpYmxlIHdpdGggdGhlICdub25lJyBmYWxsYmFjay5fX1xuICAgIGlmIChkaXNwbGF5Q2hlY2sgIT09ICdsZWdhY3ktZnVsbCcpIHtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBoaWRkZW5cbiAgICB9XG4gICAgLy8gZWxzZSwgZmFsbGJhY2sgdG8gJ25vbmUnIG1vZGUgYW5kIGNvbnNpZGVyIHRoZSBub2RlIHZpc2libGVcbiAgfSBlbHNlIGlmIChkaXNwbGF5Q2hlY2sgPT09ICdub24temVyby1hcmVhJykge1xuICAgIC8vIE5PVEU6IEV2ZW4gdGhvdWdoIHRoaXMgdGVzdHMgdGhhdCB0aGUgbm9kZSdzIGNsaWVudCByZWN0IGlzIG5vbi16ZXJvIHRvIGRldGVybWluZVxuICAgIC8vICB3aGV0aGVyIGl0J3MgZGlzcGxheWVkLCBhbmQgdGhhdCBhIGRldGFjaGVkIG5vZGUgd2lsbCBfX2Fsd2F5c19fIGhhdmUgYSB6ZXJvLWFyZWFcbiAgICAvLyAgY2xpZW50IHJlY3QsIHdlIGRvbid0IHNwZWNpYWwtY2FzZSBmb3Igd2hldGhlciB0aGUgbm9kZSBpcyBhdHRhY2hlZCBvciBub3QuIEluXG4gICAgLy8gIHRoaXMgbW9kZSwgd2UgZG8gd2FudCB0byBjb25zaWRlciBub2RlcyB0aGF0IGhhdmUgYSB6ZXJvIGFyZWEgdG8gYmUgaGlkZGVuIGF0IGFsbFxuICAgIC8vICB0aW1lcywgYW5kIHRoYXQgaW5jbHVkZXMgYXR0YWNoZWQgb3Igbm90LlxuICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xuICB9XG5cbiAgLy8gdmlzaWJsZSwgYXMgZmFyIGFzIHdlIGNhbiB0ZWxsLCBvciBwZXIgY3VycmVudCBgZGlzcGxheUNoZWNrPW5vbmVgIG1vZGUsIHdlIGFzc3VtZVxuICAvLyAgaXQncyB2aXNpYmxlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIGZvcm0gZmllbGRzIChuZXN0ZWQpIGluc2lkZSBhIGRpc2FibGVkIGZpZWxkc2V0IGFyZSBub3QgZm9jdXNhYmxlL3RhYmJhYmxlXG4vLyAgdW5sZXNzIHRoZXkgYXJlIGluIHRoZSBfZmlyc3RfIDxsZWdlbmQ+IGVsZW1lbnQgb2YgdGhlIHRvcC1tb3N0IGRpc2FibGVkXG4vLyAgZmllbGRzZXRcbnZhciBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0ID0gZnVuY3Rpb24gaXNEaXNhYmxlZEZyb21GaWVsZHNldChub2RlKSB7XG4gIGlmICgvXihJTlBVVHxCVVRUT058U0VMRUNUfFRFWFRBUkVBKSQvLnRlc3Qobm9kZS50YWdOYW1lKSkge1xuICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIC8vIGNoZWNrIGlmIGBub2RlYCBpcyBjb250YWluZWQgaW4gYSBkaXNhYmxlZCA8ZmllbGRzZXQ+XG4gICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChwYXJlbnROb2RlLnRhZ05hbWUgPT09ICdGSUVMRFNFVCcgJiYgcGFyZW50Tm9kZS5kaXNhYmxlZCkge1xuICAgICAgICAvLyBsb29rIGZvciB0aGUgZmlyc3QgPGxlZ2VuZD4gYW1vbmcgdGhlIGNoaWxkcmVuIG9mIHRoZSBkaXNhYmxlZCA8ZmllbGRzZXQ+XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IHBhcmVudE5vZGUuY2hpbGRyZW4uaXRlbShpKTtcbiAgICAgICAgICAvLyB3aGVuIHRoZSBmaXJzdCA8bGVnZW5kPiAoaW4gZG9jdW1lbnQgb3JkZXIpIGlzIGZvdW5kXG4gICAgICAgICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09ICdMRUdFTkQnKSB7XG4gICAgICAgICAgICAvLyBpZiBpdHMgcGFyZW50IDxmaWVsZHNldD4gaXMgbm90IG5lc3RlZCBpbiBhbm90aGVyIGRpc2FibGVkIDxmaWVsZHNldD4sXG4gICAgICAgICAgICAvLyByZXR1cm4gd2hldGhlciBgbm9kZWAgaXMgYSBkZXNjZW5kYW50IG9mIGl0cyBmaXJzdCA8bGVnZW5kPlxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChwYXJlbnROb2RlLCAnZmllbGRzZXRbZGlzYWJsZWRdIConKSA/IHRydWUgOiAhY2hpbGQuY29udGFpbnMobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkaXNhYmxlZCA8ZmllbGRzZXQ+IGNvbnRhaW5pbmcgYG5vZGVgIGhhcyBubyA8bGVnZW5kPlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gZWxzZSwgbm9kZSdzIHRhYmJhYmxlL2ZvY3VzYWJsZSBzdGF0ZSBzaG91bGQgbm90IGJlIGFmZmVjdGVkIGJ5IGEgZmllbGRzZXQnc1xuICAvLyAgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUgPSBmdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpIHtcbiAgaWYgKG5vZGUuZGlzYWJsZWQgfHxcbiAgLy8gd2UgbXVzdCBkbyBhbiBpbmVydCBsb29rIHVwIHRvIGZpbHRlciBvdXQgYW55IGVsZW1lbnRzIGluc2lkZSBhbiBpbmVydCBhbmNlc3RvclxuICAvLyAgYmVjYXVzZSB3ZSdyZSBsaW1pdGVkIGluIHRoZSB0eXBlIG9mIHNlbGVjdG9ycyB3ZSBjYW4gdXNlIGluIEpTRG9tIChzZWUgcmVsYXRlZFxuICAvLyAgbm90ZSByZWxhdGVkIHRvIGBjYW5kaWRhdGVTZWxlY3RvcnNgKVxuICBpc0luZXJ0KG5vZGUpIHx8IGlzSGlkZGVuSW5wdXQobm9kZSkgfHwgaXNIaWRkZW4obm9kZSwgb3B0aW9ucykgfHxcbiAgLy8gRm9yIGEgZGV0YWlscyBlbGVtZW50IHdpdGggYSBzdW1tYXJ5LCB0aGUgc3VtbWFyeSBlbGVtZW50IGdldHMgdGhlIGZvY3VzXG4gIGlzRGV0YWlsc1dpdGhTdW1tYXJ5KG5vZGUpIHx8IGlzRGlzYWJsZWRGcm9tRmllbGRzZXQobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKSB7XG4gIGlmIChpc05vblRhYmJhYmxlUmFkaW8obm9kZSkgfHwgZ2V0VGFiaW5kZXgobm9kZSkgPCAwIHx8ICFpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlID0gZnVuY3Rpb24gaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZShzaGFkb3dIb3N0Tm9kZSkge1xuICB2YXIgdGFiSW5kZXggPSBwYXJzZUludChzaGFkb3dIb3N0Tm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKTtcbiAgaWYgKGlzTmFOKHRhYkluZGV4KSB8fCB0YWJJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSWYgYSBjdXN0b20gZWxlbWVudCBoYXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgdGFiaW5kZXgsXG4gIC8vIGJyb3dzZXJzIHdpbGwgbm90IGFsbG93IHRhYiB0YXJnZXRpbmcgc2FpZCBlbGVtZW50J3MgY2hpbGRyZW4uXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48RWxlbWVudHxDYW5kaWRhdGVTY29wZT59IGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIEVsZW1lbnRbXVxuICovXG52YXIgc29ydEJ5T3JkZXIgPSBmdW5jdGlvbiBzb3J0QnlPcmRlcihjYW5kaWRhdGVzKSB7XG4gIHZhciByZWd1bGFyVGFiYmFibGVzID0gW107XG4gIHZhciBvcmRlcmVkVGFiYmFibGVzID0gW107XG4gIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIHZhciBpc1Njb3BlID0gISFpdGVtLnNjb3BlUGFyZW50O1xuICAgIHZhciBlbGVtZW50ID0gaXNTY29wZSA/IGl0ZW0uc2NvcGVQYXJlbnQgOiBpdGVtO1xuICAgIHZhciBjYW5kaWRhdGVUYWJpbmRleCA9IGdldFRhYmluZGV4KGVsZW1lbnQsIGlzU2NvcGUpO1xuICAgIHZhciBlbGVtZW50cyA9IGlzU2NvcGUgPyBzb3J0QnlPcmRlcihpdGVtLmNhbmRpZGF0ZXMpIDogZWxlbWVudDtcbiAgICBpZiAoY2FuZGlkYXRlVGFiaW5kZXggPT09IDApIHtcbiAgICAgIGlzU2NvcGUgPyByZWd1bGFyVGFiYmFibGVzLnB1c2guYXBwbHkocmVndWxhclRhYmJhYmxlcywgZWxlbWVudHMpIDogcmVndWxhclRhYmJhYmxlcy5wdXNoKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxuICAgICAgICB0YWJJbmRleDogY2FuZGlkYXRlVGFiaW5kZXgsXG4gICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgIGlzU2NvcGU6IGlzU2NvcGUsXG4gICAgICAgIGNvbnRlbnQ6IGVsZW1lbnRzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3JkZXJlZFRhYmJhYmxlcy5zb3J0KHNvcnRPcmRlcmVkVGFiYmFibGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc29ydGFibGUpIHtcbiAgICBzb3J0YWJsZS5pc1Njb3BlID8gYWNjLnB1c2guYXBwbHkoYWNjLCBzb3J0YWJsZS5jb250ZW50KSA6IGFjYy5wdXNoKHNvcnRhYmxlLmNvbnRlbnQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKS5jb25jYXQocmVndWxhclRhYmJhYmxlcyk7XG59O1xudmFyIHRhYmJhYmxlID0gZnVuY3Rpb24gdGFiYmFibGUoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBjYW5kaWRhdGVzO1xuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShbZWxdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucyksXG4gICAgICBmbGF0dGVuOiBmYWxzZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcbiAgICAgIHNoYWRvd1Jvb3RGaWx0ZXI6IGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhlbCwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKSk7XG4gIH1cbiAgcmV0dXJuIHNvcnRCeU9yZGVyKGNhbmRpZGF0ZXMpO1xufTtcbnZhciBmb2N1c2FibGUgPSBmdW5jdGlvbiBmb2N1c2FibGUoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBjYW5kaWRhdGVzO1xuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShbZWxdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKGVsLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKSk7XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xudmFyIGlzVGFiYmFibGUgPSBmdW5jdGlvbiBpc1RhYmJhYmxlKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICB9XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgY2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlKG9wdGlvbnMsIG5vZGUpO1xufTtcbnZhciBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqL2NhbmRpZGF0ZVNlbGVjdG9ycy5jb25jYXQoJ2lmcmFtZScpLmpvaW4oJywnKTtcbnZhciBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIGlzRm9jdXNhYmxlKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICB9XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmV4cG9ydCB7IGZvY3VzYWJsZSwgaXNGb2N1c2FibGUsIGlzVGFiYmFibGUsIHRhYmJhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuZnVuY3Rpb24gZShlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKTplPz9udWxsfWZ1bmN0aW9uIG4oZSl7Zm9yKDtlLmhhc0NoaWxkTm9kZXMoKTspZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpfWZ1bmN0aW9uIHQoZSxuKXtjb25zdCB0PW4ucGFyZW50Tm9kZTt0JiYodC5sYXN0Q2hpbGQ9PT1uP3QuYXBwZW5kQ2hpbGQoZSk6dC5pbnNlcnRCZWZvcmUoZSxuLm5leHRTaWJsaW5nKSl9ZnVuY3Rpb24gbyhlLG4pe2NvbnN0IHQ9bi5wYXJlbnROb2RlO3QmJnQuaW5zZXJ0QmVmb3JlKGUsbil9ZnVuY3Rpb24gaShlLG4pe2Zvcig7Oyl7Y29uc3QgdD1lLmZpcnN0Q2hpbGQ7aWYoIXQpYnJlYWs7bi5hcHBlbmRDaGlsZCh0KX19ZnVuY3Rpb24gcihlKXtlLnBhcmVudE5vZGUmJmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX1jb25zdCBsPVwiZnVuY3Rpb25cIj09dHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3Q/KGUsbik9PmUuY2xvc2VzdChuKTooZSxuKT0+e2xldCB0PWU7ZG97aWYodC5tYXRjaGVzKG4pKXJldHVybiB0O3Q9dC5wYXJlbnRFbGVtZW50fXdoaWxlKG51bGwhPT10JiYxPT09dC5ub2RlVHlwZSk7cmV0dXJuIG51bGx9O2V4cG9ydHtlIGFzIGJ5SWQsbCBhcyBjbG9zZXN0LG4gYXMgZW1wdHksdCBhcyBpbnNlcnRBZnRlcixvIGFzIGluc2VydEJlZm9yZSxyIGFzIHJlbW92ZSxpIGFzIHJlcGFyZW50fTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5jb25zdCB0PVwicmFuZG9tVVVJRFwiaW4gY3J5cHRvO2Z1bmN0aW9uIG4oKXtpZih0KXJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpO2NvbnN0IG49Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDE2QXJyYXkoOCkpO25bM109NDA5NSZuWzNdfDE2Mzg0LG5bNF09MTYzODMmbls0XXwzMjc2ODtjb25zdCByPXQ9Pm5bdF0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDQsXCIwXCIpO3JldHVybiByKDApK3IoMSkrXCItXCIrcigyKStcIi1cIityKDMpK1wiLVwiK3IoNCkrXCItXCIrcig1KStyKDYpK3IoNyl9ZnVuY3Rpb24gcigpe3JldHVybmB7JHtuKCl9fWB9ZXhwb3J0e3IgYXMgZ2VuZXJhdGVCcmFjZWRVVUlELG4gYXMgZ2VuZXJhdGVVVUlEfTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnR7XyBhcyBzfWZyb21cIi4uL2NodW5rcy90c2xpYi5lczYuanNcIjtpbXBvcnR7cHJvcGVydHkgYXMgZX1mcm9tXCIuLi9jb3JlL2FjY2Vzc29yU3VwcG9ydC9kZWNvcmF0b3JzL3Byb3BlcnR5LmpzXCI7aW1wb3J0XCIuLi9jb3JlL2FjY2Vzc29yU3VwcG9ydC9lbnN1cmVUeXBlLmpzXCI7aW1wb3J0XCIuLi9jb3JlL2FycmF5VXRpbHMuanNcIjtpbXBvcnRcIi4uL2NvcmUvaGFzLmpzXCI7aW1wb3J0e3N1YmNsYXNzIGFzIHR9ZnJvbVwiLi4vY29yZS9hY2Nlc3NvclN1cHBvcnQvZGVjb3JhdG9ycy9zdWJjbGFzcy5qc1wiO2ltcG9ydHtzdWJzdGl0dXRlIGFzIHJ9ZnJvbVwiLi4vaW50bC9zdWJzdGl0dXRlLmpzXCI7aW1wb3J0IG8gZnJvbVwiLi4vd2lkZ2V0cy9XaWRnZXQuanNcIjtpbXBvcnR7c3RvcmVOb2RlIGFzIGl9ZnJvbVwiLi4vd2lkZ2V0cy9zdXBwb3J0L3dpZGdldFV0aWxzLmpzXCI7aW1wb3J0e21lc3NhZ2VCdW5kbGUgYXMgbn1mcm9tXCIuLi93aWRnZXRzL3N1cHBvcnQvZGVjb3JhdG9ycy9tZXNzYWdlQnVuZGxlLmpzXCI7aW1wb3J0e3RzeCBhcyB1fWZyb21cIi4uL3dpZGdldHMvc3VwcG9ydC9qc3hGYWN0b3J5LmpzXCI7Y29uc3QgYT1cImVzcmktaWRlbnRpdHktZm9ybVwiLHA9e2Jhc2U6YSxncm91cDpgJHthfV9fZ3JvdXBgLGxhYmVsOmAke2F9X19sYWJlbGAsZm9vdGVyOmAke2F9X19mb290ZXJgLGVzcmlJbnB1dDpcImVzcmktaW5wdXRcIixlc3JpQnV0dG9uOlwiZXNyaS1idXR0b25cIixlc3JpQnV0dG9uU2Vjb25kYXJ5OlwiZXNyaS1idXR0b24tLXNlY29uZGFyeVwifSxsPVwiQXJjR0lTIE9ubGluZVwiO2xldCBkPWNsYXNzIGV4dGVuZHMgb3tjb25zdHJ1Y3RvcihzLGUpe3N1cGVyKHMsZSksdGhpcy5fdXNlcm5hbWVJbnB1dE5vZGU9bnVsbCx0aGlzLl9wYXNzd29yZElucHV0Tm9kZT1udWxsLHRoaXMuc2lnbmluZ0luPSExLHRoaXMuc2VydmVyPW51bGwsdGhpcy5yZXNvdXJjZT1udWxsLHRoaXMuZXJyb3I9bnVsbCx0aGlzLm9BdXRoUHJvbXB0PSExfXJlbmRlcigpe2NvbnN0e2Vycm9yOnMsc2VydmVyOmUscmVzb3VyY2U6dCxzaWduaW5nSW46byxvQXV0aFByb21wdDpuLG1lc3NhZ2VzOmF9PXRoaXMsZD11KFwiZGl2XCIse2NsYXNzOnAuZ3JvdXB9LHIobj9hLm9BdXRoSW5mbzphLmluZm8se3NlcnZlcjplJiYvXFwuYXJjZ2lzXFwuY29tL2kudGVzdChlKT9sOmUscmVzb3VyY2U6YCgke3R8fGEubGJsSXRlbX0pYH0pKSxjPW4/bnVsbDp1KFwiZGl2XCIse2NsYXNzOnAuZ3JvdXAsa2V5OlwidXNlcm5hbWVcIn0sdShcImxhYmVsXCIse2NsYXNzOnAubGFiZWx9LGEubGJsVXNlcix1KFwiaW5wdXRcIix7dmFsdWU6XCJcIixyZXF1aXJlZDohMCxhdXRvY29tcGxldGU6XCJvZmZcIixzcGVsbGNoZWNrOiExLHR5cGU6XCJ0ZXh0XCIsYmluZDp0aGlzLGFmdGVyQ3JlYXRlOmksXCJkYXRhLW5vZGUtcmVmXCI6XCJfdXNlcm5hbWVJbnB1dE5vZGVcIixjbGFzczpwLmVzcmlJbnB1dH0pKSksbT1uP251bGw6dShcImRpdlwiLHtjbGFzczpwLmdyb3VwLGtleTpcInBhc3N3b3JkXCJ9LHUoXCJsYWJlbFwiLHtjbGFzczpwLmxhYmVsfSxhLmxibFB3ZCx1KFwiaW5wdXRcIix7dmFsdWU6XCJcIixyZXF1aXJlZDohMCx0eXBlOlwicGFzc3dvcmRcIixiaW5kOnRoaXMsYWZ0ZXJDcmVhdGU6aSxcImRhdGEtbm9kZS1yZWZcIjpcIl9wYXNzd29yZElucHV0Tm9kZVwiLGNsYXNzOnAuZXNyaUlucHV0fSkpKSxoPXUoXCJkaXZcIix7Y2xhc3M6dGhpcy5jbGFzc2VzKHAuZ3JvdXAscC5mb290ZXIpfSx1KFwiaW5wdXRcIix7dHlwZTpcInN1Ym1pdFwiLGRpc2FibGVkOiEhbyx2YWx1ZTpvP2EubGJsU2lnbmluZzphLmxibE9rLGNsYXNzOnAuZXNyaUJ1dHRvbn0pLHUoXCJpbnB1dFwiLHt0eXBlOlwiYnV0dG9uXCIsdmFsdWU6YS5sYmxDYW5jZWwsYmluZDp0aGlzLG9uY2xpY2s6dGhpcy5fY2FuY2VsLGNsYXNzOnRoaXMuY2xhc3NlcyhwLmVzcmlCdXR0b24scC5lc3JpQnV0dG9uU2Vjb25kYXJ5KX0pKSxiPXM/dShcImRpdlwiLG51bGwscy5kZXRhaWxzJiZzLmRldGFpbHMuaHR0cFN0YXR1cz9hLmludmFsaWRVc2VyOmEubm9BdXRoU2VydmljZSk6bnVsbDtyZXR1cm4gdShcImZvcm1cIix7Y2xhc3M6cC5iYXNlLGJpbmQ6dGhpcyxvbnN1Ym1pdDp0aGlzLl9zdWJtaXR9LGQsYixjLG0saCl9X2NhbmNlbCgpe3RoaXMuX3NldChcInNpZ25pbmdJblwiLCExKSx0aGlzLl91c2VybmFtZUlucHV0Tm9kZSYmKHRoaXMuX3VzZXJuYW1lSW5wdXROb2RlLnZhbHVlPVwiXCIpLHRoaXMuX3Bhc3N3b3JkSW5wdXROb2RlJiYodGhpcy5fcGFzc3dvcmRJbnB1dE5vZGUudmFsdWU9XCJcIiksdGhpcy5lbWl0KFwiY2FuY2VsXCIpfV9zdWJtaXQocyl7cy5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuX3NldChcInNpZ25pbmdJblwiLCEwKTtjb25zdCBlPXRoaXMub0F1dGhQcm9tcHQ/e306e3VzZXJuYW1lOnRoaXMuX3VzZXJuYW1lSW5wdXROb2RlJiZ0aGlzLl91c2VybmFtZUlucHV0Tm9kZS52YWx1ZSxwYXNzd29yZDp0aGlzLl9wYXNzd29yZElucHV0Tm9kZSYmdGhpcy5fcGFzc3dvcmRJbnB1dE5vZGUudmFsdWV9O3RoaXMuZW1pdChcInN1Ym1pdFwiLGUpfX07cyhbZSgpLG4oXCJlc3JpL2lkZW50aXR5L3Q5bi9pZGVudGl0eVwiKV0sZC5wcm90b3R5cGUsXCJtZXNzYWdlc1wiLHZvaWQgMCkscyhbZSgpXSxkLnByb3RvdHlwZSxcInNpZ25pbmdJblwiLHZvaWQgMCkscyhbZSgpXSxkLnByb3RvdHlwZSxcInNlcnZlclwiLHZvaWQgMCkscyhbZSgpXSxkLnByb3RvdHlwZSxcInJlc291cmNlXCIsdm9pZCAwKSxzKFtlKCldLGQucHJvdG90eXBlLFwiZXJyb3JcIix2b2lkIDApLHMoW2UoKV0sZC5wcm90b3R5cGUsXCJvQXV0aFByb21wdFwiLHZvaWQgMCksZD1zKFt0KFwiZXNyaS5pZGVudGl0eS5JZGVudGl0eUZvcm1cIildLGQpO2NvbnN0IGM9ZDtleHBvcnR7YyBhcyBkZWZhdWx0fTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnR7c2V0SWQgYXMgZX1mcm9tXCIuLi9rZXJuZWwuanNcIjtpbXBvcnR7SWRlbnRpdHlNYW5hZ2VyQmFzZSBhcyB0fWZyb21cIi4vSWRlbnRpdHlNYW5hZ2VyQmFzZS5qc1wiO2NsYXNzIHIgZXh0ZW5kcyB0e31yLnByb3RvdHlwZS5kZWNsYXJlZENsYXNzPVwiZXNyaS5pZGVudGl0eS5JZGVudGl0eU1hbmFnZXJcIjtjb25zdCBzPW5ldyByO2Uocyk7ZXhwb3J0e3MgYXMgZGVmYXVsdH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e18gYXMgZX1mcm9tXCIuLi9jaHVua3MvdHNsaWIuZXM2LmpzXCI7aW1wb3J0IHQgZnJvbVwiLi4vY29uZmlnLmpzXCI7aW1wb3J0e2lkIGFzIHJ9ZnJvbVwiLi4va2VybmVsLmpzXCI7aW1wb3J0IHMgZnJvbVwiLi4vcmVxdWVzdC5qc1wiO2ltcG9ydCBpIGZyb21cIi4uL2NvcmUvRXJyb3IuanNcIjtpbXBvcnQgbyBmcm9tXCIuLi9jb3JlL0V2ZW50ZWQuanNcIjtpbXBvcnR7b24gYXMgbn1mcm9tXCIuLi9jb3JlL2V2ZW50cy5qc1wiO2ltcG9ydHtmaXhKc29uIGFzIGF9ZnJvbVwiLi4vY29yZS9sYW5nLmpzXCI7aW1wb3J0e2dldERlZXBWYWx1ZSBhcyBofWZyb21cIi4uL2NvcmUvb2JqZWN0LmpzXCI7aW1wb3J0e2NyZWF0ZVJlc29sdmVyIGFzIGwsb25BYm9ydCBhcyBjLGlzQWJvcnRlZCBhcyBkfWZyb21cIi4uL2NvcmUvcHJvbWlzZVV0aWxzLmpzXCI7aW1wb3J0e3dhdGNoIGFzIHV9ZnJvbVwiLi4vY29yZS9yZWFjdGl2ZVV0aWxzLmpzXCI7aW1wb3J0e3VybFRvT2JqZWN0IGFzIHAsaGFzU2FtZU9yaWdpbiBhcyBfLFVybCBhcyBmLHF1ZXJ5VG9PYmplY3QgYXMgZyxiYXNlNjRVcmxFbmNvZGUgYXMgbSxvYmplY3RUb1F1ZXJ5IGFzIHYsbm9ybWFsaXplIGFzIFMsZ2V0UHJveHlSdWxlIGFzIHcsbWFrZUFic29sdXRlIGFzIEksYWRkUXVlcnlQYXJhbWV0ZXJzIGFzIEF9ZnJvbVwiLi4vY29yZS91cmxVdGlscy5qc1wiO2ltcG9ydHtwcm9wZXJ0eSBhcyBrfWZyb21cIi4uL2NvcmUvYWNjZXNzb3JTdXBwb3J0L2RlY29yYXRvcnMvcHJvcGVydHkuanNcIjtpbXBvcnRcIi4uL2NvcmUvYWNjZXNzb3JTdXBwb3J0L2Vuc3VyZVR5cGUuanNcIjtpbXBvcnR7c3ViY2xhc3MgYXMgeX1mcm9tXCIuLi9jb3JlL2FjY2Vzc29yU3VwcG9ydC9kZWNvcmF0b3JzL3N1YmNsYXNzLmpzXCI7aW1wb3J0IFUgZnJvbVwiLi9JZGVudGl0eUZvcm0uanNcIjtpbXBvcnQgVCBmcm9tXCIuL0lkZW50aXR5TW9kYWwuanNcIjtpbXBvcnQgeCBmcm9tXCIuL09BdXRoQ3JlZGVudGlhbC5qc1wiO2ltcG9ydCBPIGZyb21cIi4vT0F1dGhJbmZvLmpzXCI7aW1wb3J0IFAgZnJvbVwiLi9TZXJ2ZXJJbmZvLmpzXCI7aW1wb3J0e2lzU2VjdXJlUHJveHlTZXJ2aWNlIGFzIFJ9ZnJvbVwiLi4vcG9ydGFsL3N1cHBvcnQvdXJsVXRpbHMuanNcIjtjb25zdCBDPXt9LGI9ZT0+e2NvbnN0IHQ9bmV3IGYoZS5vd25pbmdTeXN0ZW1VcmwpLmhvc3Qscj1uZXcgZihlLnNlcnZlcikuaG9zdCxzPS8uK1xcLmFyY2dpc1xcLmNvbSQvaTtyZXR1cm4gcy50ZXN0KHQpJiZzLnRlc3Qocil9LEQ9KGUsdCk9PiEhKGIoZSkmJnQmJnQuc29tZSgodD0+dC50ZXN0KGUuc2VydmVyKSkpKTtsZXQgcT1udWxsLGo9bnVsbDt0cnl7cT13aW5kb3cubG9jYWxTdG9yYWdlLGo9d2luZG93LnNlc3Npb25TdG9yYWdlfWNhdGNoe31jbGFzcyBFIGV4dGVuZHMgb3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5fcG9ydGFsQ29uZmlnPWdsb2JhbFRoaXMuZXNyaUdlb3dDb25maWcsdGhpcy5zZXJ2ZXJJbmZvcz1bXSx0aGlzLm9BdXRoSW5mb3M9W10sdGhpcy5jcmVkZW50aWFscz1bXSx0aGlzLl9zb1JlcXM9W10sdGhpcy5feG9SZXFzPVtdLHRoaXMuX3BvcnRhbHM9W10sdGhpcy5fZGVmYXVsdE9BdXRoSW5mbz1udWxsLHRoaXMuX2RlZmF1bHRUb2tlblZhbGlkaXR5PTYwLHRoaXMuZGlhbG9nPW51bGwsdGhpcy5mb3JtQ29uc3RydWN0b3I9VSx0aGlzLnRva2VuVmFsaWRpdHk9bnVsbCx0aGlzLm5vcm1hbGl6ZVdlYlRpZXJBdXRoPSExLHRoaXMuX2FwcE9yaWdpbj1cIm51bGxcIiE9PXdpbmRvdy5vcmlnaW4/d2luZG93Lm9yaWdpbjp3aW5kb3cubG9jYXRpb24ub3JpZ2luLHRoaXMuX2FwcFVybE9iaj1wKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSx0aGlzLl9idXN5PW51bGwsdGhpcy5fcmVqZWN0T25QZXJzaXN0ZWRQYWdlU2hvdz0hMSx0aGlzLl9vQXV0aExvY2F0aW9uUGFyYW1zPW51bGwsdGhpcy5fZ3dUb2tlblVybD1cIi9zaGFyaW5nL3Jlc3QvZ2VuZXJhdGVUb2tlblwiLHRoaXMuX2Fnc1Jlc3Q9XCIvcmVzdC9zZXJ2aWNlc1wiLHRoaXMuX2Fnc1BvcnRhbD0vXFwvc2hhcmluZyhcXC98JCkvaSx0aGlzLl9hZ3NBZG1pbj0vKGh0dHBzPzpcXC9cXC9bXlxcL10rXFwvW15cXC9dKylcXC9hZG1pblxcLz8oXFwvLiopPyQvaSx0aGlzLl9hZG1pblN2Y3M9L1xcL3Jlc3RcXC9hZG1pblxcL3NlcnZpY2VzKFxcL3wkKS9pLHRoaXMuX2d3RG9tYWlucz1be3JlZ2V4Oi9eaHR0cHM/OlxcL1xcL3d3d1xcLmFyY2dpc1xcLmNvbS9pLGN1c3RvbUJhc2VVcmw6XCJtYXBzLmFyY2dpcy5jb21cIix0b2tlblNlcnZpY2VVcmw6XCJodHRwczovL3d3dy5hcmNnaXMuY29tL3NoYXJpbmcvcmVzdC9nZW5lcmF0ZVRva2VuXCJ9LHtyZWdleDovXmh0dHBzPzpcXC9cXC8oPzpkZXZ8W2EtelxcZC1dK1xcLm1hcHNkZXYpXFwuYXJjZ2lzXFwuY29tL2ksY3VzdG9tQmFzZVVybDpcIm1hcHNkZXYuYXJjZ2lzLmNvbVwiLHRva2VuU2VydmljZVVybDpcImh0dHBzOi8vZGV2LmFyY2dpcy5jb20vc2hhcmluZy9yZXN0L2dlbmVyYXRlVG9rZW5cIn0se3JlZ2V4Oi9eaHR0cHM/OlxcL1xcLyg/OmRldmV4dHxbYS16XFxkLV0rXFwubWFwc2RldmV4dClcXC5hcmNnaXNcXC5jb20vaSxjdXN0b21CYXNlVXJsOlwibWFwc2RldmV4dC5hcmNnaXMuY29tXCIsdG9rZW5TZXJ2aWNlVXJsOlwiaHR0cHM6Ly9kZXZleHQuYXJjZ2lzLmNvbS9zaGFyaW5nL3Jlc3QvZ2VuZXJhdGVUb2tlblwifSx7cmVnZXg6L15odHRwcz86XFwvXFwvKD86cWFleHR8W2EtelxcZC1dK1xcLm1hcHNxYSlcXC5hcmNnaXNcXC5jb20vaSxjdXN0b21CYXNlVXJsOlwibWFwc3FhLmFyY2dpcy5jb21cIix0b2tlblNlcnZpY2VVcmw6XCJodHRwczovL3FhZXh0LmFyY2dpcy5jb20vc2hhcmluZy9yZXN0L2dlbmVyYXRlVG9rZW5cIn0se3JlZ2V4Oi9eaHR0cHM/OlxcL1xcL1thLXpcXGQtXStcXC5tYXBzXFwuYXJjZ2lzXFwuY29tL2ksY3VzdG9tQmFzZVVybDpcIm1hcHMuYXJjZ2lzLmNvbVwiLHRva2VuU2VydmljZVVybDpcImh0dHBzOi8vd3d3LmFyY2dpcy5jb20vc2hhcmluZy9yZXN0L2dlbmVyYXRlVG9rZW5cIn1dLHRoaXMuX2xlZ2FjeUZlZD1bXSx0aGlzLl9yZWdleFNEaXJVcmw9L2h0dHAuK1xcL3Jlc3RcXC9zZXJ2aWNlc1xcLz8vZ2ksdGhpcy5fcmVnZXhTZXJ2ZXJUeXBlPS8oXFwvKEZlYXR1cmVTZXJ2ZXJ8R1BTZXJ2ZXJ8R2VvRGF0YVNlcnZlcnxHZW9jb2RlU2VydmVyfEdlb2VucmljaG1lbnRTZXJ2ZXJ8R2VvbWV0cnlTZXJ2ZXJ8R2xvYmVTZXJ2ZXJ8SW1hZ2VTZXJ2ZXJ8S25vd2xlZGdlR3JhcGhTZXJ2ZXJ8TWFwU2VydmVyfE1pc3Npb25TZXJ2ZXJ8TW9iaWxlU2VydmVyfE5BU2VydmVyfE5ldHdvcmtEaWFncmFtU2VydmVyfE9HQ0ZlYXR1cmVTZXJ2ZXJ8UGFyY2VsRmFicmljU2VydmVyfFJlbGF0aW9uYWxDYXRhbG9nU2VydmVyfFNjZW5lU2VydmVyfFN0cmVhbVNlcnZlcnxVdGlsaXR5TmV0d29ya1NlcnZlcnxWYWxpZGF0aW9uU2VydmVyfFZlY3RvclRpbGVTZXJ2ZXJ8VmVyc2lvbk1hbmFnZW1lbnRTZXJ2ZXJ8VmlkZW9TZXJ2ZXIpKS4qL2dpLHRoaXMuX2d3VXNlcj0vaHR0cC4rXFwvdXNlcnNcXC8oW15cXC9dKylcXC8/LiovaSx0aGlzLl9nd0l0ZW09L2h0dHAuK1xcL2l0ZW1zXFwvKFteXFwvXSspXFwvPy4qL2ksdGhpcy5fZ3dHcm91cD0vaHR0cC4rXFwvZ3JvdXBzXFwvKFteXFwvXSspXFwvPy4qL2ksdGhpcy5fcmVQb3J0YWxUb2tlblN2Yz0vXFwvc2hhcmluZyhcXC9yZXN0KT9cXC9nZW5lcmF0ZXRva2VuL2ksdGhpcy5fY3JlYXRlRGVmYXVsdE9BdXRoSW5mbz0hMCx0aGlzLl9oYXNUZXN0ZWRJZkFwcElzT25Qb3J0YWw9ITEsdGhpcy5fZ2V0T0F1dGhMb2NhdGlvblBhcmFtcygpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIiwoZT0+e3RoaXMuX3BhZ2VTaG93SGFuZGxlcihlKX0pKX1yZWdpc3RlclNlcnZlcnMoZSl7Y29uc3QgdD10aGlzLnNlcnZlckluZm9zO3Q/KGU9ZS5maWx0ZXIoKGU9PiF0aGlzLmZpbmRTZXJ2ZXJJbmZvKGUuc2VydmVyKSkpLHRoaXMuc2VydmVySW5mb3M9dC5jb25jYXQoZSkpOnRoaXMuc2VydmVySW5mb3M9ZSxlLmZvckVhY2goKGU9PntlLm93bmluZ1N5c3RlbVVybCYmdGhpcy5fcG9ydGFscy5wdXNoKGUub3duaW5nU3lzdGVtVXJsKSxlLmhhc1BvcnRhbCYmdGhpcy5fcG9ydGFscy5wdXNoKGUuc2VydmVyKX0pKX1yZWdpc3Rlck9BdXRoSW5mb3MoZSl7Y29uc3QgdD10aGlzLm9BdXRoSW5mb3M7aWYodCl7Zm9yKGNvbnN0IHIgb2YgZSl7Y29uc3QgZT10aGlzLmZpbmRPQXV0aEluZm8oci5wb3J0YWxVcmwpO2UmJnQuc3BsaWNlKHQuaW5kZXhPZihlKSwxKX10aGlzLm9BdXRoSW5mb3M9dC5jb25jYXQoZSl9ZWxzZSB0aGlzLm9BdXRoSW5mb3M9ZX1yZWdpc3RlclRva2VuKGUpe2U9ey4uLmV9O2NvbnN0IHQ9dGhpcy5fc2FuaXRpemVVcmwoZS5zZXJ2ZXIpLHI9dGhpcy5faXNTZXJ2ZXJSc3JjKHQpO2xldCBzLGk9dGhpcy5maW5kU2VydmVySW5mbyh0KSxvPSEwO2l8fChpPW5ldyBQLGkuc2VydmVyPXRoaXMuX2dldFNlcnZlckluc3RhbmNlUm9vdCh0KSxyP2kuaGFzU2VydmVyPSEwOihpLnRva2VuU2VydmljZVVybD10aGlzLl9nZXRUb2tlblN2Y1VybCh0KSxpLmhhc1BvcnRhbD0hMCksdGhpcy5yZWdpc3RlclNlcnZlcnMoW2ldKSkscz10aGlzLl9maW5kQ3JlZGVudGlhbCh0KSxzPyhkZWxldGUgZS5zZXJ2ZXIsT2JqZWN0LmFzc2lnbihzLGUpLG89ITEpOihzPW5ldyBMKHt1c2VySWQ6ZS51c2VySWQsc2VydmVyOmkuc2VydmVyLHRva2VuOmUudG9rZW4sZXhwaXJlczplLmV4cGlyZXMsc3NsOmUuc3NsLHNjb3BlOnI/XCJzZXJ2ZXJcIjpcInBvcnRhbFwifSkscy5yZXNvdXJjZXM9W3RdLHRoaXMuY3JlZGVudGlhbHMucHVzaChzKSkscy5lbWl0VG9rZW5DaGFuZ2UoITEpLG98fHMucmVmcmVzaFNlcnZlclRva2VucygpfXRvSlNPTigpe3JldHVybiBhKHtzZXJ2ZXJJbmZvczp0aGlzLnNlcnZlckluZm9zLm1hcCgoZT0+ZS50b0pTT04oKSkpLG9BdXRoSW5mb3M6dGhpcy5vQXV0aEluZm9zLm1hcCgoZT0+ZS50b0pTT04oKSkpLGNyZWRlbnRpYWxzOnRoaXMuY3JlZGVudGlhbHMubWFwKChlPT5lLnRvSlNPTigpKSl9KX1pbml0aWFsaXplKGUpe2lmKCFlKXJldHVybjtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9SlNPTi5wYXJzZShlKSk7Y29uc3QgdD1lLnNlcnZlckluZm9zLHI9ZS5vQXV0aEluZm9zLHM9ZS5jcmVkZW50aWFscztpZih0KXtjb25zdCBlPVtdO3QuZm9yRWFjaCgodD0+e3Quc2VydmVyJiZ0LnRva2VuU2VydmljZVVybCYmZS5wdXNoKHQuZGVjbGFyZWRDbGFzcz90Om5ldyBQKHQpKX0pKSxlLmxlbmd0aCYmdGhpcy5yZWdpc3RlclNlcnZlcnMoZSl9aWYocil7Y29uc3QgZT1bXTtyLmZvckVhY2goKHQ9Pnt0LmFwcElkJiZlLnB1c2godC5kZWNsYXJlZENsYXNzP3Q6bmV3IE8odCkpfSkpLGUubGVuZ3RoJiZ0aGlzLnJlZ2lzdGVyT0F1dGhJbmZvcyhlKX1zJiZzLmZvckVhY2goKGU9PntlLnNlcnZlciYmZS50b2tlbiYmZS5leHBpcmVzJiZlLmV4cGlyZXM+RGF0ZS5ub3coKSYmKChlPWUuZGVjbGFyZWRDbGFzcz9lOm5ldyBMKGUpKS5lbWl0VG9rZW5DaGFuZ2UoKSx0aGlzLmNyZWRlbnRpYWxzLnB1c2goZSkpfSkpfWZpbmRTZXJ2ZXJJbmZvKGUpe2xldCB0O2U9dGhpcy5fc2FuaXRpemVVcmwoZSk7Zm9yKGNvbnN0IHIgb2YgdGhpcy5zZXJ2ZXJJbmZvcylpZih0aGlzLl9oYXNTYW1lU2VydmVySW5zdGFuY2Uoci5zZXJ2ZXIsZSkpe3Q9cjticmVha31yZXR1cm4gdH1maW5kT0F1dGhJbmZvKGUpe2xldCB0O2U9dGhpcy5fc2FuaXRpemVVcmwoZSk7Zm9yKGNvbnN0IHIgb2YgdGhpcy5vQXV0aEluZm9zKWlmKHRoaXMuX2hhc1NhbWVTZXJ2ZXJJbnN0YW5jZShyLnBvcnRhbFVybCxlKSl7dD1yO2JyZWFrfXJldHVybiB0fWZpbmRDcmVkZW50aWFsKGUsdCl7aWYoIWUpcmV0dXJuO2xldCByO2U9dGhpcy5fc2FuaXRpemVVcmwoZSk7Y29uc3Qgcz10aGlzLl9pc1NlcnZlclJzcmMoZSk/XCJzZXJ2ZXJcIjpcInBvcnRhbFwiO2lmKHQpe2Zvcihjb25zdCBpIG9mIHRoaXMuY3JlZGVudGlhbHMpaWYodGhpcy5faGFzU2FtZVNlcnZlckluc3RhbmNlKGkuc2VydmVyLGUpJiZ0PT09aS51c2VySWQmJmkuc2NvcGU9PT1zKXtyPWk7YnJlYWt9fWVsc2UgZm9yKGNvbnN0IGkgb2YgdGhpcy5jcmVkZW50aWFscylpZih0aGlzLl9oYXNTYW1lU2VydmVySW5zdGFuY2UoaS5zZXJ2ZXIsZSkmJi0xIT09dGhpcy5fZ2V0SWRlbnRpY2FsU3ZjSWR4KGUsaSkmJmkuc2NvcGU9PT1zKXtyPWk7YnJlYWt9cmV0dXJuIHJ9Z2V0Q3JlZGVudGlhbChlLHQpe2xldCByLHMsbz0hMDt0JiYocj0hIXQudG9rZW4scz10LmVycm9yLG89ITEhPT10LnByb21wdCksdD17Li4udH0sZT10aGlzLl9zYW5pdGl6ZVVybChlKTtjb25zdCBuPW5ldyBBYm9ydENvbnRyb2xsZXIsYT1sKCk7aWYodC5zaWduYWwmJmModC5zaWduYWwsKCgpPT57bi5hYm9ydCgpfSkpLGMobiwoKCk9PnthLnJlamVjdChuZXcgaShcImlkZW50aXR5LW1hbmFnZXI6dXNlci1hYm9ydGVkXCIsXCJBQk9SVEVEXCIpKX0pKSxkKG4pKXJldHVybiBhLnByb21pc2U7dC5zaWduYWw9bi5zaWduYWw7Y29uc3QgaD10aGlzLl9pc0FkbWluUmVzb3VyY2UoZSksdT1yP3RoaXMuZmluZENyZWRlbnRpYWwoZSk6bnVsbDtsZXQgcDtpZih1JiZzJiZzLmRldGFpbHMmJjQ5OD09PXMuZGV0YWlscy5odHRwU3RhdHVzKXUuZGVzdHJveSgpO2Vsc2UgaWYodSlyZXR1cm4gcD1uZXcgaShcImlkZW50aXR5LW1hbmFnZXI6bm90LWF1dGhvcml6ZWRcIixcIllvdSBhcmUgY3VycmVudGx5IHNpZ25lZCBpbiBhczogJ1wiK3UudXNlcklkK1wiJy4gWW91IGRvIG5vdCBoYXZlIGFjY2VzcyB0byB0aGlzIHJlc291cmNlOiBcIitlLHtlcnJvcjpzfSksYS5yZWplY3QocCksYS5wcm9taXNlO2NvbnN0IGY9dGhpcy5fZmluZENyZWRlbnRpYWwoZSx0KTtpZihmKXJldHVybiBhLnJlc29sdmUoZiksYS5wcm9taXNlO2xldCBnPXRoaXMuZmluZFNlcnZlckluZm8oZSk7aWYoZykhZy5oYXNTZXJ2ZXImJnRoaXMuX2lzU2VydmVyUnNyYyhlKSYmKGcuX3Jlc3RJbmZvUG1zPXRoaXMuX2dldFRva2VuU3ZjVXJsKGUpLGcuaGFzU2VydmVyPSEwKTtlbHNle2NvbnN0IHQ9dGhpcy5fZ2V0VG9rZW5TdmNVcmwoZSk7aWYoIXQpcmV0dXJuIHA9bmV3IGkoXCJpZGVudGl0eS1tYW5hZ2VyOnVua25vd24tcmVzb3VyY2VcIixcIlVua25vd24gcmVzb3VyY2UgLSBjb3VsZCBub3QgZmluZCB0b2tlbiBzZXJ2aWNlIGVuZHBvaW50LlwiKSxhLnJlamVjdChwKSxhLnByb21pc2U7Zz1uZXcgUCxnLnNlcnZlcj10aGlzLl9nZXRTZXJ2ZXJJbnN0YW5jZVJvb3QoZSksXCJzdHJpbmdcIj09dHlwZW9mIHQ/KGcudG9rZW5TZXJ2aWNlVXJsPXQsZy5oYXNQb3J0YWw9ITApOihnLl9yZXN0SW5mb1Btcz10LGcuaGFzU2VydmVyPSEwKSx0aGlzLnJlZ2lzdGVyU2VydmVycyhbZ10pfXJldHVybiBnLmhhc1BvcnRhbCYmdm9pZCAwPT09Zy5fc2VsZlJlcSYmKG98fF8oZy50b2tlblNlcnZpY2VVcmwsdGhpcy5fYXBwT3JpZ2luKXx8dGhpcy5fZ3dEb21haW5zLnNvbWUoKGU9PmUudG9rZW5TZXJ2aWNlVXJsPT09Zy50b2tlblNlcnZpY2VVcmwpKSkmJihnLl9zZWxmUmVxPXtvd25pbmdUZW5hbnQ6dCYmdC5vd25pbmdUZW5hbnQsc2VsZkRmZDp0aGlzLl9nZXRQb3J0YWxTZWxmKGcudG9rZW5TZXJ2aWNlVXJsLnJlcGxhY2UodGhpcy5fcmVQb3J0YWxUb2tlblN2YyxcIi9zaGFyaW5nL3Jlc3QvcG9ydGFscy9zZWxmXCIpLGUpfSksdGhpcy5fZW5xdWV1ZShlLGcsdCxhLGgpfWdldFJlc291cmNlTmFtZShlKXtyZXR1cm4gdGhpcy5faXNSRVNUU2VydmljZShlKT9lLnJlcGxhY2UodGhpcy5fcmVnZXhTRGlyVXJsLFwiXCIpLnJlcGxhY2UodGhpcy5fcmVnZXhTZXJ2ZXJUeXBlLFwiXCIpfHxcIlwiOnRoaXMuX2d3VXNlci50ZXN0KGUpJiZlLnJlcGxhY2UodGhpcy5fZ3dVc2VyLFwiJDFcIil8fHRoaXMuX2d3SXRlbS50ZXN0KGUpJiZlLnJlcGxhY2UodGhpcy5fZ3dJdGVtLFwiJDFcIil8fHRoaXMuX2d3R3JvdXAudGVzdChlKSYmZS5yZXBsYWNlKHRoaXMuX2d3R3JvdXAsXCIkMVwiKXx8XCJcIn1nZW5lcmF0ZVRva2VuKGUsdCxyKXtjb25zdCBvPXRoaXMuX3JlUG9ydGFsVG9rZW5TdmMudGVzdChlLnRva2VuU2VydmljZVVybCksbj1uZXcgZih0aGlzLl9hcHBPcmlnaW4pLGE9ZS5zaG9ydExpdmVkVG9rZW5WYWxpZGl0eTtsZXQgaCxsLGMsZCx1LHAsZyxtO3QmJihtPXRoaXMudG9rZW5WYWxpZGl0eXx8YXx8dGhpcy5fZGVmYXVsdFRva2VuVmFsaWRpdHksbT5hJiZhPjAmJihtPWEpKSxyJiYoaD1yLmlzQWRtaW4sbD1yLnNlcnZlclVybCxjPXIudG9rZW4scD1yLnNpZ25hbCxnPXIuc3NsLGUuY3VzdG9tUGFyYW1ldGVycz1yLmN1c3RvbVBhcmFtZXRlcnMpLGg/ZD1lLmFkbWluVG9rZW5TZXJ2aWNlVXJsOihkPWUudG9rZW5TZXJ2aWNlVXJsLHU9bmV3IGYoZC50b0xvd2VyQ2FzZSgpKSxlLndlYlRpZXJBdXRoJiZyPy5zZXJ2ZXJVcmwmJiFnJiZcImh0dHBcIj09PW4uc2NoZW1lJiYoXyhuLnVyaSxkLCEwKXx8XCJodHRwc1wiPT09dS5zY2hlbWUmJm4uaG9zdD09PXUuaG9zdCYmXCI3MDgwXCI9PT1uLnBvcnQmJlwiNzQ0M1wiPT09dS5wb3J0KSYmKGQ9ZC5yZXBsYWNlKC9eaHR0cHM6L2ksXCJodHRwOlwiKS5yZXBsYWNlKC86NzQ0My9pLFwiOjcwODBcIikpKTtjb25zdCB2PXtxdWVyeTp7cmVxdWVzdDpcImdldFRva2VuXCIsdXNlcm5hbWU6dD8udXNlcm5hbWUscGFzc3dvcmQ6dD8ucGFzc3dvcmQsc2VydmVyVXJsOmwsdG9rZW46YyxleHBpcmF0aW9uOm0scmVmZXJlcjpofHxvP3RoaXMuX2FwcE9yaWdpbjpudWxsLGNsaWVudDpoP1wicmVmZXJlclwiOm51bGwsZjpcImpzb25cIiwuLi5lLmN1c3RvbVBhcmFtZXRlcnN9LG1ldGhvZDpcInBvc3RcIixhdXRoTW9kZTpcImFub255bW91c1wiLHVzZVByb3h5OnRoaXMuX3VzZVByb3h5KGUsciksc2lnbmFsOnAsLi4ucj8uaW9BcmdzfTtvfHwodi53aXRoQ3JlZGVudGlhbHM9ITEpO3JldHVybiBzKGQsdikudGhlbigocj0+e2NvbnN0IHM9ci5kYXRhO2lmKCFzfHwhcy50b2tlbilyZXR1cm4gbmV3IGkoXCJpZGVudGl0eS1tYW5hZ2VyOmF1dGhlbnRpY2F0aW9uLWZhaWxlZFwiLFwiVW5hYmxlIHRvIGdlbmVyYXRlIHRva2VuXCIpO2NvbnN0IG89ZS5zZXJ2ZXI7cmV0dXJuIENbb118fChDW29dPXt9KSx0JiYoQ1tvXVt0LnVzZXJuYW1lXT10LnBhc3N3b3JkKSxzLnZhbGlkaXR5PW0sc30pKX1pc0J1c3koKXtyZXR1cm4hIXRoaXMuX2J1c3l9Y2hlY2tTaWduSW5TdGF0dXMoZSl7cmV0dXJuIHRoaXMuY2hlY2tBcHBBY2Nlc3MoZSxcIlwiKS50aGVuKChlPT5lLmNyZWRlbnRpYWwpKX1jaGVja0FwcEFjY2VzcyhlLHQscil7bGV0IG89ITE7cmV0dXJuIHRoaXMuZ2V0Q3JlZGVudGlhbChlLHtwcm9tcHQ6ITF9KS50aGVuKChuPT57bGV0IGE7Y29uc3QgaD17ZjpcImpzb25cIn07aWYoXCJwb3J0YWxcIj09PW4uc2NvcGUpaWYodCYmKHRoaXMuX2RvUG9ydGFsU2lnbkluKGUpfHxyJiZyLmZvcmNlKSlhPW4uc2VydmVyK1wiL3NoYXJpbmcvcmVzdC9vYXV0aDIvdmFsaWRhdGVBcHBBY2Nlc3NcIixoLmNsaWVudF9pZD10O2Vsc2V7aWYoIW4udG9rZW4pcmV0dXJue2NyZWRlbnRpYWw6bn07YT1uLnNlcnZlcitcIi9zaGFyaW5nL3Jlc3RcIn1lbHNle2lmKCFuLnRva2VuKXJldHVybntjcmVkZW50aWFsOm59O2E9bi5zZXJ2ZXIrXCIvcmVzdC9zZXJ2aWNlc1wifXJldHVybiBuLnRva2VuJiYoaC50b2tlbj1uLnRva2VuKSxzKGEse3F1ZXJ5OmgsYXV0aE1vZGU6XCJhbm9ueW1vdXNcIn0pLnRoZW4oKGU9PntpZighMT09PWUuZGF0YS52YWxpZCl0aHJvdyBuZXcgaShcImlkZW50aXR5LW1hbmFnZXI6bm90LWF1dGhvcml6ZWRcIixgWW91IGFyZSBjdXJyZW50bHkgc2lnbmVkIGluIGFzOiAnJHtuLnVzZXJJZH0nLmAsZS5kYXRhKTtyZXR1cm4gbz0hIWUuZGF0YS52aWV3T25seVVzZXJUeXBlQXBwLHtjcmVkZW50aWFsOm59fSkpLmNhdGNoKChlPT57aWYoXCJpZGVudGl0eS1tYW5hZ2VyOm5vdC1hdXRob3JpemVkXCI9PT1lLm5hbWUpdGhyb3cgZTtjb25zdCB0PWUuZGV0YWlscyYmZS5kZXRhaWxzLmh0dHBTdGF0dXM7aWYoNDk4PT09dCl0aHJvdyBuLmRlc3Ryb3koKSxuZXcgaShcImlkZW50aXR5LW1hbmFnZXI6bm90LWF1dGhlbnRpY2F0ZWRcIixcIlVzZXIgaXMgbm90IHNpZ25lZCBpbi5cIik7aWYoNDAwPT09dCl0aHJvdyBuZXcgaShcImlkZW50aXR5LW1hbmFnZXI6aW52YWxpZC1yZXF1ZXN0XCIpO3JldHVybntjcmVkZW50aWFsOm59fSkpfSkpLnRoZW4oKGU9Pih7Y3JlZGVudGlhbDplLmNyZWRlbnRpYWwsdmlld09ubHk6b30pKSl9c2V0T0F1dGhSZXNwb25zZUhhc2goZSl7ZSYmKFwiI1wiPT09ZS5jaGFyQXQoMCkmJihlPWUuc3Vic3RyaW5nKDEpKSx0aGlzLl9wcm9jZXNzT0F1dGhQb3B1cFBhcmFtcyhnKGUpKSl9c2V0T0F1dGhSZWRpcmVjdGlvbkhhbmRsZXIoZSl7dGhpcy5fb0F1dGhSZWRpcmVjdEZ1bmM9ZX1zZXRQcm90b2NvbEVycm9ySGFuZGxlcihlKXt0aGlzLl9wcm90b2NvbEZ1bmM9ZX1zaWduSW4oZSx0LHI9e30pe2NvbnN0IHM9bCgpLG89KCk9PntoPy5yZW1vdmUoKSxkPy5yZW1vdmUoKSxwPy5yZW1vdmUoKSxhPy5kZXN0cm95KCksdGhpcy5kaWFsb2c/LmRlc3Ryb3koKSx0aGlzLmRpYWxvZz1hPWg9ZD1wPW51bGx9LG49KCk9PntvKCksdGhpcy5fb0F1dGhEZmQ9bnVsbCxzLnJlamVjdChuZXcgaShcImlkZW50aXR5LW1hbmFnZXI6dXNlci1hYm9ydGVkXCIsXCJBQk9SVEVEXCIpKX07ci5zaWduYWwmJmMoci5zaWduYWwsKCgpPT57bigpfSkpO2xldCBhPW5ldyB0aGlzLmZvcm1Db25zdHJ1Y3RvcjthLnJlc291cmNlPXRoaXMuZ2V0UmVzb3VyY2VOYW1lKGUpLGEuc2VydmVyPXQuc2VydmVyLHRoaXMuZGlhbG9nPW5ldyBULHRoaXMuZGlhbG9nLmNvbnRlbnQ9YSx0aGlzLmRpYWxvZy5vcGVuPSEwLHRoaXMuZW1pdChcImRpYWxvZy1jcmVhdGVcIik7bGV0IGg9YS5vbihcImNhbmNlbFwiLG4pLGQ9dSgoKCk9PnRoaXMuZGlhbG9nLm9wZW4pLG4pLHA9YS5vbihcInN1Ym1pdFwiLChlPT57dGhpcy5nZW5lcmF0ZVRva2VuKHQsZSx7aXNBZG1pbjpyLmlzQWRtaW4sc2lnbmFsOnIuc2lnbmFsfSkudGhlbigoaT0+e28oKTtjb25zdCBuPW5ldyBMKHt1c2VySWQ6ZS51c2VybmFtZSxzZXJ2ZXI6dC5zZXJ2ZXIsdG9rZW46aS50b2tlbixleHBpcmVzOm51bGwhPWkuZXhwaXJlcz9OdW1iZXIoaS5leHBpcmVzKTpudWxsLHNzbDohIWkuc3NsLGlzQWRtaW46ci5pc0FkbWluLHZhbGlkaXR5OmkudmFsaWRpdHl9KTtzLnJlc29sdmUobil9KSkuY2F0Y2goKGU9PnthLmVycm9yPWUsYS5zaWduaW5nSW49ITF9KSl9KSk7cmV0dXJuIHMucHJvbWlzZX1vQXV0aFNpZ25JbihlLHQscixzKXt0aGlzLl9vQXV0aERmZD1sKCk7Y29uc3Qgbz10aGlzLl9vQXV0aERmZDtsZXQgbjtzPy5zaWduYWwmJmMocy5zaWduYWwsKCgpPT57Y29uc3QgZT10aGlzLl9vQXV0aERmZCYmdGhpcy5fb0F1dGhEZmQub0F1dGhXaW5fO2UmJiFlLmNsb3NlZD9lLmNsb3NlKCk6dGhpcy5kaWFsb2cmJmYoKX0pKSxvLnJlc1VybF89ZSxvLnNpbmZvXz10LG8ub2luZm9fPXI7Y29uc3QgYT1yLl9vQXV0aENyZWQ7aWYoYS5zdG9yYWdlJiYoXCJhdXRob3JpemF0aW9uLWNvZGVcIj09PXIuZmxvd1R5cGV8fFwiYXV0b1wiPT09ci5mbG93VHlwZSYmIXIucG9wdXAmJnQuY3VycmVudFZlcnNpb24+PTguNCkpe2xldCBlPWNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKTtuPW0oZSksYS5jb2RlVmVyaWZpZXI9bixlPWNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKSxhLnN0YXRlVUlEPW0oZSksYS5zYXZlKCl8fChhLmNvZGVWZXJpZmllcj1uPW51bGwpfWVsc2UgYS5jb2RlVmVyaWZpZXI9bnVsbDtsZXQgaCxkLHAsXzt0aGlzLl9nZXRDb2RlQ2hhbGxlbmdlKG4pLnRoZW4oKGk9Pntjb25zdCBvPSFzfHwhMSE9PXMub0F1dGhQb3B1cENvbmZpcm1hdGlvbjtyLnBvcHVwJiZvPyhoPW5ldyB0aGlzLmZvcm1Db25zdHJ1Y3RvcixoLm9BdXRoUHJvbXB0PSEwLGguc2VydmVyPXQuc2VydmVyLHRoaXMuZGlhbG9nPW5ldyBULHRoaXMuZGlhbG9nLmNvbnRlbnQ9aCx0aGlzLmRpYWxvZy5vcGVuPSEwLHRoaXMuZW1pdChcImRpYWxvZy1jcmVhdGVcIiksZD1oLm9uKFwiY2FuY2VsXCIsZikscD11KCgoKT0+dGhpcy5kaWFsb2cub3BlbiksZiksXz1oLm9uKFwic3VibWl0XCIsKCgpPT57ZygpLHRoaXMuX2RvT0F1dGhTaWduSW4oZSx0LHIsaSl9KSkpOnRoaXMuX2RvT0F1dGhTaWduSW4oZSx0LHIsaSl9KSk7Y29uc3QgZj0oKT0+e2coKSx0aGlzLl9vQXV0aERmZD1udWxsLG8ucmVqZWN0KG5ldyBpKFwiaWRlbnRpdHktbWFuYWdlcjp1c2VyLWFib3J0ZWRcIixcIkFCT1JURURcIikpfSxnPSgpPT57ZD8ucmVtb3ZlKCkscD8ucmVtb3ZlKCksXz8ucmVtb3ZlKCksaD8uZGVzdHJveSgpLHRoaXMuZGlhbG9nPy5kZXN0cm95KCksdGhpcy5kaWFsb2c9bnVsbH07cmV0dXJuIG8ucHJvbWlzZX1kZXN0cm95Q3JlZGVudGlhbHMoKXtpZih0aGlzLmNyZWRlbnRpYWxzKXt0aGlzLmNyZWRlbnRpYWxzLnNsaWNlKCkuZm9yRWFjaCgoZT0+e2UuZGVzdHJveSgpfSkpfXRoaXMuZW1pdChcImNyZWRlbnRpYWxzLWRlc3Ryb3lcIil9ZW5hYmxlUG9zdE1lc3NhZ2VBdXRoKGU9XCJodHRwczovL3d3dy5hcmNnaXMuY29tL3NoYXJpbmcvcmVzdFwiKXt0aGlzLl9wb3N0TWVzc2FnZUF1dGhIYW5kbGUmJnRoaXMuX3Bvc3RNZXNzYWdlQXV0aEhhbmRsZS5yZW1vdmUoKSx0aGlzLl9wb3N0TWVzc2FnZUF1dGhIYW5kbGU9bih3aW5kb3csXCJtZXNzYWdlXCIsKHQ9PntpZigodC5vcmlnaW49PT10aGlzLl9hcHBPcmlnaW58fHQub3JpZ2luLmVuZHNXaXRoKFwiLmFyY2dpcy5jb21cIikpJiZcImFyY2dpczphdXRoOnJlcXVlc3RDcmVkZW50aWFsXCI9PT10LmRhdGE/LnR5cGUpe2NvbnN0IHI9dC5zb3VyY2U7dGhpcy5nZXRDcmVkZW50aWFsKGUpLnRoZW4oKGU9PntyLnBvc3RNZXNzYWdlKHt0eXBlOlwiYXJjZ2lzOmF1dGg6Y3JlZGVudGlhbFwiLGNyZWRlbnRpYWw6e2V4cGlyZXM6ZS5leHBpcmVzLHNlcnZlcjplLnNlcnZlcixzc2w6ZS5zc2wsdG9rZW46ZS50b2tlbix1c2VySWQ6ZS51c2VySWR9fSx0Lm9yaWdpbil9KSkuY2F0Y2goKGU9PntyLnBvc3RNZXNzYWdlKHt0eXBlOlwiYXJjZ2lzOmF1dGg6ZXJyb3JcIixlcnJvcjp7bmFtZTplLm5hbWUsbWVzc2FnZTplLm1lc3NhZ2V9fSx0Lm9yaWdpbil9KSl9fSkpfWRpc2FibGVQb3N0TWVzc2FnZUF1dGgoKXt0aGlzLl9wb3N0TWVzc2FnZUF1dGhIYW5kbGUmJih0aGlzLl9wb3N0TWVzc2FnZUF1dGhIYW5kbGUucmVtb3ZlKCksdGhpcy5fcG9zdE1lc3NhZ2VBdXRoSGFuZGxlPW51bGwpfV9nZXRPQXV0aExvY2F0aW9uUGFyYW1zKCl7bGV0IGU9d2luZG93LmxvY2F0aW9uLmhhc2g7aWYoZSl7XCIjXCI9PT1lLmNoYXJBdCgwKSYmKGU9ZS5zdWJzdHJpbmcoMSkpO2NvbnN0IHQ9ZyhlKTtsZXQgcj0hMTtpZih0LmFjY2Vzc190b2tlbiYmdC5leHBpcmVzX2luJiZ0LnN0YXRlJiZ0Lmhhc093blByb3BlcnR5KFwidXNlcm5hbWVcIikpdHJ5e3Quc3RhdGU9SlNPTi5wYXJzZSh0LnN0YXRlKSx0LnN0YXRlLnBvcnRhbFVybCYmKHRoaXMuX29BdXRoTG9jYXRpb25QYXJhbXM9dCxyPSEwKX1jYXRjaHt9ZWxzZSBpZih0LmVycm9yJiZ0LmVycm9yX2Rlc2NyaXB0aW9uJiYoY29uc29sZS5sb2coXCJJZGVudGl0eU1hbmFnZXIgT0F1dGggRXJyb3I6IFwiLHQuZXJyb3IsXCIgLSBcIix0LmVycm9yX2Rlc2NyaXB0aW9uKSxcImFjY2Vzc19kZW5pZWRcIj09PXQuZXJyb3ImJihyPSEwLHQuc3RhdGUpKSl0cnl7dC5zdGF0ZT1KU09OLnBhcnNlKHQuc3RhdGUpfWNhdGNoe31yJiYod2luZG93LmxvY2F0aW9uLmhhc2g9dC5zdGF0ZT8uaGFzaHx8XCJcIil9bGV0IHQ9d2luZG93LmxvY2F0aW9uLnNlYXJjaDtpZih0KXtcIj9cIj09PXQuY2hhckF0KDApJiYodD10LnN1YnN0cmluZygxKSk7Y29uc3QgZT1nKHQpO2xldCByPSExO2lmKGUuY29kZSYmZS5zdGF0ZSl0cnl7ZS5zdGF0ZT1KU09OLnBhcnNlKGUuc3RhdGUpLGUuc3RhdGUucG9ydGFsVXJsJiZlLnN0YXRlLnVpZCYmKHRoaXMuX29BdXRoTG9jYXRpb25QYXJhbXM9ZSxyPSEwKX1jYXRjaHt9ZWxzZSBpZihlLmVycm9yJiZlLmVycm9yX2Rlc2NyaXB0aW9uJiYoY29uc29sZS5sb2coXCJJZGVudGl0eU1hbmFnZXIgT0F1dGggRXJyb3I6IFwiLGUuZXJyb3IsXCIgLSBcIixlLmVycm9yX2Rlc2NyaXB0aW9uKSxcImFjY2Vzc19kZW5pZWRcIj09PWUuZXJyb3ImJihyPSEwLGUuc3RhdGUpKSl0cnl7ZS5zdGF0ZT1KU09OLnBhcnNlKGUuc3RhdGUpfWNhdGNoe31pZihyKXtjb25zdCB0PXsuLi5lfTtbXCJjb2RlXCIsXCJlcnJvclwiLFwiZXJyb3JfZGVzY3JpcHRpb25cIixcIm1lc3NhZ2VfY29kZVwiLFwicGVyc2lzdFwiLFwic3RhdGVcIl0uZm9yRWFjaCgoZT0+e2RlbGV0ZSB0W2VdfSkpO2NvbnN0IHI9dih0KSxzPXdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSsocj9gPyR7cn1gOlwiXCIpKyhlLnN0YXRlPy5oYXNofHxcIlwiKTt3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUod2luZG93Lmhpc3Rvcnkuc3RhdGUsXCJcIixzKX19fV9nZXRPQXV0aFRva2VuKGUsdCxyLGksbyl7cmV0dXJuIGU9ZS5yZXBsYWNlKC9eaHR0cDovaSxcImh0dHBzOlwiKSxzKGAke2V9L3NoYXJpbmcvcmVzdC9vYXV0aDIvdG9rZW5gLHthdXRoTW9kZTpcImFub255bW91c1wiLG1ldGhvZDpcInBvc3RcIixxdWVyeTppJiZvP3tncmFudF90eXBlOlwiYXV0aG9yaXphdGlvbl9jb2RlXCIsY29kZTp0LHJlZGlyZWN0X3VyaTppLGNsaWVudF9pZDpyLGNvZGVfdmVyaWZpZXI6b306e2dyYW50X3R5cGU6XCJyZWZyZXNoX3Rva2VuXCIscmVmcmVzaF90b2tlbjp0LGNsaWVudF9pZDpyfX0pLnRoZW4oKGU9PmUuZGF0YSkpfV9nZXRDb2RlQ2hhbGxlbmdlKGUpe2lmKGUmJmdsb2JhbFRoaXMuaXNTZWN1cmVDb250ZXh0KXtjb25zdCB0PShuZXcgVGV4dEVuY29kZXIpLmVuY29kZShlKTtyZXR1cm4gY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtMjU2XCIsdCkudGhlbigoZT0+bShuZXcgVWludDhBcnJheShlKSkpKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpfV9wYWdlU2hvd0hhbmRsZXIoZSl7aWYoZS5wZXJzaXN0ZWQmJnRoaXMuaXNCdXN5KCkmJnRoaXMuX3JlamVjdE9uUGVyc2lzdGVkUGFnZVNob3cpe2NvbnN0IGU9bmV3IGkoXCJpZGVudGl0eS1tYW5hZ2VyOnVzZXItYWJvcnRlZFwiLFwiQUJPUlRFRFwiKTt0aGlzLl9lcnJiYWNrRnVuYyhlKX19X2ZpbmRDcmVkZW50aWFsKGUsdCl7bGV0IHIscyxpLG8sbj0tMTtjb25zdCBhPXQmJnQudG9rZW4saD10JiZ0LnJlc291cmNlLGw9dGhpcy5faXNTZXJ2ZXJSc3JjKGUpP1wic2VydmVyXCI6XCJwb3J0YWxcIixjPXRoaXMuY3JlZGVudGlhbHMuZmlsdGVyKCh0PT50aGlzLl9oYXNTYW1lU2VydmVySW5zdGFuY2UodC5zZXJ2ZXIsZSkmJnQuc2NvcGU9PT1sKSk7aWYoZT1ofHxlLGMubGVuZ3RoKWlmKDE9PT1jLmxlbmd0aCl7aWYocj1jWzBdLGk9dGhpcy5maW5kU2VydmVySW5mbyhyLnNlcnZlcikscz1pJiZpLm93bmluZ1N5c3RlbVVybCxvPXM/dGhpcy5maW5kQ3JlZGVudGlhbChzLHIudXNlcklkKTp2b2lkIDAsbj10aGlzLl9nZXRJZGVudGljYWxTdmNJZHgoZSxyKSwhYSlyZXR1cm4tMT09PW4mJnIucmVzb3VyY2VzLnB1c2goZSksdGhpcy5fYWRkUmVzb3VyY2UoZSxvKSxyOy0xIT09biYmKHIucmVzb3VyY2VzLnNwbGljZShuLDEpLHRoaXMuX3JlbW92ZVJlc291cmNlKGUsbykpfWVsc2V7bGV0IHQscjtpZihjLnNvbWUoKGE9PihyPXRoaXMuX2dldElkZW50aWNhbFN2Y0lkeChlLGEpLC0xIT09ciYmKHQ9YSxpPXRoaXMuZmluZFNlcnZlckluZm8odC5zZXJ2ZXIpLHM9aSYmaS5vd25pbmdTeXN0ZW1Vcmwsbz1zP3RoaXMuZmluZENyZWRlbnRpYWwocyx0LnVzZXJJZCk6dm9pZCAwLG49ciwhMCkpKSksYSl0JiYodC5yZXNvdXJjZXMuc3BsaWNlKG4sMSksdGhpcy5fcmVtb3ZlUmVzb3VyY2UoZSxvKSk7ZWxzZSBpZih0KXJldHVybiB0aGlzLl9hZGRSZXNvdXJjZShlLG8pLHR9fV9maW5kT0F1dGhJbmZvKGUpe2xldCB0PXRoaXMuZmluZE9BdXRoSW5mbyhlKTtpZighdClmb3IoY29uc3QgciBvZiB0aGlzLm9BdXRoSW5mb3MpaWYodGhpcy5faXNJZFByb3ZpZGVyKHIucG9ydGFsVXJsLGUpKXt0PXI7YnJlYWt9cmV0dXJuIHR9X2FkZFJlc291cmNlKGUsdCl7dCYmLTE9PT10aGlzLl9nZXRJZGVudGljYWxTdmNJZHgoZSx0KSYmdC5yZXNvdXJjZXMucHVzaChlKX1fcmVtb3ZlUmVzb3VyY2UoZSx0KXtsZXQgcj0tMTt0JiYocj10aGlzLl9nZXRJZGVudGljYWxTdmNJZHgoZSx0KSxyPi0xJiZ0LnJlc291cmNlcy5zcGxpY2UociwxKSl9X3VzZVByb3h5KGUsdCl7cmV0dXJuIHQmJnQuaXNBZG1pbiYmIV8oZS5hZG1pblRva2VuU2VydmljZVVybCx0aGlzLl9hcHBPcmlnaW4pfHwhdGhpcy5faXNQb3J0YWxEb21haW4oZS50b2tlblNlcnZpY2VVcmwpJiZcIjEwLjFcIj09PVN0cmluZyhlLmN1cnJlbnRWZXJzaW9uKSYmIV8oZS50b2tlblNlcnZpY2VVcmwsdGhpcy5fYXBwT3JpZ2luKX1fZ2V0T3JpZ2luKGUpe2NvbnN0IHQ9bmV3IGYoZSk7cmV0dXJuIHQuc2NoZW1lK1wiOi8vXCIrdC5ob3N0KyhudWxsIT10LnBvcnQ/XCI6XCIrdC5wb3J0OlwiXCIpfV9nZXRTZXJ2ZXJJbnN0YW5jZVJvb3QoZSl7Y29uc3QgdD1lLnRvTG93ZXJDYXNlKCk7bGV0IHI9dC5pbmRleE9mKHRoaXMuX2Fnc1Jlc3QpO3JldHVybi0xPT09ciYmdGhpcy5faXNBZG1pblJlc291cmNlKGUpJiYocj10aGlzLl9hZ3NBZG1pbi50ZXN0KGUpP2UucmVwbGFjZSh0aGlzLl9hZ3NBZG1pbixcIiQxXCIpLmxlbmd0aDplLnNlYXJjaCh0aGlzLl9hZG1pblN2Y3MpKSwtMSE9PXJ8fFIodCl8fChyPXQuaW5kZXhPZihcIi9zaGFyaW5nXCIpKSwtMT09PXImJlwiL1wiPT09dC5zdWJzdHIoLTEpJiYocj10Lmxlbmd0aC0xKSxyPi0xP2Uuc3Vic3RyaW5nKDAscik6ZX1faGFzU2FtZVNlcnZlckluc3RhbmNlKGUsdCl7cmV0dXJuXCIvXCI9PT1lLnN1YnN0cigtMSkmJihlPWUuc2xpY2UoMCwtMSkpLGU9ZS50b0xvd2VyQ2FzZSgpLHQ9dGhpcy5fZ2V0U2VydmVySW5zdGFuY2VSb290KHQpLnRvTG93ZXJDYXNlKCksZT10aGlzLl9ub3JtYWxpemVBR09Mb3JnRG9tYWluKGUpLHQ9dGhpcy5fbm9ybWFsaXplQUdPTG9yZ0RvbWFpbih0KSwoZT1lLnN1YnN0cihlLmluZGV4T2YoXCI6XCIpKSk9PT0odD10LnN1YnN0cih0LmluZGV4T2YoXCI6XCIpKSl9X25vcm1hbGl6ZUFHT0xvcmdEb21haW4oZSl7Y29uc3QgdD0vXmh0dHBzPzpcXC9cXC8oPzpjZG58W2EtelxcZC1dK1xcLm1hcHMpXFwuYXJjZ2lzXFwuY29tL2kscj0vXmh0dHBzPzpcXC9cXC8oPzpjZG5kZXZ8W2EtelxcZC1dK1xcLm1hcHNkZXZleHQpXFwuYXJjZ2lzXFwuY29tL2kscz0vXmh0dHBzPzpcXC9cXC8oPzpjZG5xYXxbYS16XFxkLV0rXFwubWFwc3FhKVxcLmFyY2dpc1xcLmNvbS9pO3JldHVybiB0LnRlc3QoZSk/ZT1lLnJlcGxhY2UodCxcImh0dHBzOi8vd3d3LmFyY2dpcy5jb21cIik6ci50ZXN0KGUpP2U9ZS5yZXBsYWNlKHIsXCJodHRwczovL2RldmV4dC5hcmNnaXMuY29tXCIpOnMudGVzdChlKSYmKGU9ZS5yZXBsYWNlKHMsXCJodHRwczovL3FhZXh0LmFyY2dpcy5jb21cIikpLGV9X3Nhbml0aXplVXJsKGUpe2NvbnN0IHI9KHQucmVxdWVzdC5wcm94eVVybHx8XCJcIikudG9Mb3dlckNhc2UoKSxzPXI/ZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocitcIj9cIik6LTE7cmV0dXJuLTEhPT1zJiYoZT1lLnN1YnN0cmluZyhzK3IubGVuZ3RoKzEpKSxlPVMoZSkscChlKS5wYXRofV9pc1JFU1RTZXJ2aWNlKGUpe3JldHVybiBlLmluY2x1ZGVzKHRoaXMuX2Fnc1Jlc3QpfV9pc0FkbWluUmVzb3VyY2UoZSl7cmV0dXJuIHRoaXMuX2Fnc0FkbWluLnRlc3QoZSl8fHRoaXMuX2FkbWluU3Zjcy50ZXN0KGUpfV9pc1NlcnZlclJzcmMoZSl7cmV0dXJuIHRoaXMuX2lzUkVTVFNlcnZpY2UoZSl8fHRoaXMuX2lzQWRtaW5SZXNvdXJjZShlKX1faXNJZGVudGljYWxTZXJ2aWNlKGUsdCl7bGV0IHI9ITE7aWYodGhpcy5faXNSRVNUU2VydmljZShlKSYmdGhpcy5faXNSRVNUU2VydmljZSh0KSl7Y29uc3Qgcz10aGlzLl9nZXRTdWZmaXgoZSkudG9Mb3dlckNhc2UoKSxpPXRoaXMuX2dldFN1ZmZpeCh0KS50b0xvd2VyQ2FzZSgpO2lmKHI9cz09PWksIXIpe2NvbnN0IGU9LyguKilcXC8oTWFwU2VydmVyfEZlYXR1cmVTZXJ2ZXJ8VXRpbGl0eU5ldHdvcmtTZXJ2ZXIpLiovZ2k7cj1zLnJlcGxhY2VBbGwoZSxcIiQxXCIpPT09aS5yZXBsYWNlQWxsKGUsXCIkMVwiKX19ZWxzZSB0aGlzLl9pc0FkbWluUmVzb3VyY2UoZSkmJnRoaXMuX2lzQWRtaW5SZXNvdXJjZSh0KT9yPSEwOnRoaXMuX2lzU2VydmVyUnNyYyhlKXx8dGhpcy5faXNTZXJ2ZXJSc3JjKHQpfHwhdGhpcy5faXNQb3J0YWxEb21haW4oZSl8fChyPSEwKTtyZXR1cm4gcn1faXNQb3J0YWxEb21haW4oZSl7Y29uc3Qgcj1uZXcgZihlLnRvTG93ZXJDYXNlKCkpLHM9dGhpcy5fcG9ydGFsQ29uZmlnO2xldCBpPXRoaXMuX2d3RG9tYWlucy5zb21lKChlPT5lLnJlZ2V4LnRlc3Qoci51cmkpKSk7cmV0dXJuIWkmJnMmJihpPXRoaXMuX2hhc1NhbWVTZXJ2ZXJJbnN0YW5jZSh0aGlzLl9nZXRTZXJ2ZXJJbnN0YW5jZVJvb3Qocy5yZXN0QmFzZVVybCksci51cmkpKSxpfHx0LnBvcnRhbFVybCYmKGk9XyhyLHQucG9ydGFsVXJsLCEwKSksaXx8KGk9dGhpcy5fcG9ydGFscy5zb21lKChlPT50aGlzLl9oYXNTYW1lU2VydmVySW5zdGFuY2UoZSxyLnVyaSkpKSksaT1pfHx0aGlzLl9hZ3NQb3J0YWwudGVzdChyLnBhdGgpLGl9X2lzSWRQcm92aWRlcihlLHQpe2xldCByPS0xLHM9LTE7dGhpcy5fZ3dEb21haW5zLmZvckVhY2goKChpLG8pPT57LTE9PT1yJiZpLnJlZ2V4LnRlc3QoZSkmJihyPW8pLC0xPT09cyYmaS5yZWdleC50ZXN0KHQpJiYocz1vKX0pKTtsZXQgaT0hMTtpZihyPi0xJiZzPi0xJiYoMD09PXJ8fDQ9PT1yPzAhPT1zJiY0IT09c3x8KGk9ITApOjE9PT1yPzEhPT1zJiYyIT09c3x8KGk9ITApOjI9PT1yPzI9PT1zJiYoaT0hMCk6Mz09PXImJjM9PT1zJiYoaT0hMCkpLCFpKXtjb25zdCByPXRoaXMuZmluZFNlcnZlckluZm8odCkscz1yJiZyLm93bmluZ1N5c3RlbVVybDtzJiZiKHIpJiZ0aGlzLl9pc1BvcnRhbERvbWFpbihzKSYmdGhpcy5faXNJZFByb3ZpZGVyKGUscykmJihpPSEwKX1yZXR1cm4gaX1fZ2V0SWRlbnRpY2FsU3ZjSWR4KGUsdCl7bGV0IHI9LTE7Zm9yKGxldCBzPTA7czx0LnJlc291cmNlcy5sZW5ndGg7cysrKXtjb25zdCBpPXQucmVzb3VyY2VzW3NdO2lmKHRoaXMuX2lzSWRlbnRpY2FsU2VydmljZShlLGkpKXtyPXM7YnJlYWt9fXJldHVybiByfV9nZXRTdWZmaXgoZSl7cmV0dXJuIGUucmVwbGFjZSh0aGlzLl9yZWdleFNEaXJVcmwsXCJcIikucmVwbGFjZSh0aGlzLl9yZWdleFNlcnZlclR5cGUsXCIkMVwiKX1fZ2V0VG9rZW5TdmNVcmwoZSl7bGV0IHQscixpO2lmKHRoaXMuX2lzUkVTVFNlcnZpY2UoZSl8fHRoaXMuX2lzQWRtaW5SZXNvdXJjZShlKSl7Y29uc3QgaT10aGlzLl9nZXRTZXJ2ZXJJbnN0YW5jZVJvb3QoZSk7cmV0dXJuIHQ9aStcIi9hZG1pbi9nZW5lcmF0ZVRva2VuXCIscj1zKGU9aStcIi9yZXN0L2luZm9cIix7cXVlcnk6e2Y6XCJqc29uXCJ9fSkudGhlbigoZT0+ZS5kYXRhKSkse2FkbWluVXJsOnQscHJvbWlzZTpyfX1pZih0aGlzLl9pc1BvcnRhbERvbWFpbihlKSl7bGV0IHQ9XCJcIjtpZih0aGlzLl9nd0RvbWFpbnMuc29tZSgocj0+KHIucmVnZXgudGVzdChlKSYmKHQ9ci50b2tlblNlcnZpY2VVcmwpLCEhdCkpKSx0fHx0aGlzLl9wb3J0YWxzLnNvbWUoKHI9Pih0aGlzLl9oYXNTYW1lU2VydmVySW5zdGFuY2UocixlKSYmKHQ9cit0aGlzLl9nd1Rva2VuVXJsKSwhIXQpKSksdHx8KGk9ZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCIvc2hhcmluZ1wiKSwtMSE9PWkmJih0PWUuc3Vic3RyaW5nKDAsaSkrdGhpcy5fZ3dUb2tlblVybCkpLHR8fCh0PXRoaXMuX2dldE9yaWdpbihlKSt0aGlzLl9nd1Rva2VuVXJsKSx0KXtjb25zdCByPW5ldyBmKGUpLnBvcnQ7L15odHRwOlxcL1xcLy9pLnRlc3QoZSkmJlwiNzA4MFwiPT09ciYmKHQ9dC5yZXBsYWNlKC86NzA4MC9pLFwiOjc0NDNcIikpLHQ9dC5yZXBsYWNlKC9odHRwOi9pLFwiaHR0cHM6XCIpfXJldHVybiB0fWlmKGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInByZW1pdW0uYXJjZ2lzb25saW5lLmNvbVwiKSlyZXR1cm5cImh0dHBzOi8vcHJlbWl1bS5hcmNnaXNvbmxpbmUuY29tL3NlcnZlci90b2tlbnNcIn1fcHJvY2Vzc09BdXRoUmVzcG9uc2VQYXJhbXMoZSx0LHIpe2NvbnN0IHM9dC5fb0F1dGhDcmVkO2lmKGUuY29kZSl7Y29uc3QgaT1zLmNvZGVWZXJpZmllcjtyZXR1cm4gcy5jb2RlVmVyaWZpZXI9bnVsbCxzLnN0YXRlVUlEPW51bGwscy5zYXZlKCksdGhpcy5fZ2V0T0F1dGhUb2tlbihyLnNlcnZlcixlLmNvZGUsdC5hcHBJZCx0aGlzLl9nZXRSZWRpcmVjdFVSSSh0LCEwKSxpKS50aGVuKChpPT57Y29uc3Qgbz1uZXcgTCh7dXNlcklkOmkudXNlcm5hbWUsc2VydmVyOnIuc2VydmVyLHRva2VuOmkuYWNjZXNzX3Rva2VuLGV4cGlyZXM6RGF0ZS5ub3coKSsxZTMqaS5leHBpcmVzX2luLHNzbDppLnNzbCxvQXV0aFN0YXRlOmUuc3RhdGUsX29BdXRoQ3JlZDpzfSk7cmV0dXJuIHQudXNlcklkPW8udXNlcklkLHMuc3RvcmFnZT1pLnBlcnNpc3Q/cTpqLHMucmVmcmVzaFRva2VuPWkucmVmcmVzaF90b2tlbixzLnRva2VuPW51bGwscy5leHBpcmVzPWkucmVmcmVzaF90b2tlbl9leHBpcmVzX2luP0RhdGUubm93KCkrMWUzKmkucmVmcmVzaF90b2tlbl9leHBpcmVzX2luOm51bGwscy51c2VySWQ9by51c2VySWQscy5zc2w9by5zc2wscy5zYXZlKCksb30pKX1jb25zdCBpPW5ldyBMKHt1c2VySWQ6ZS51c2VybmFtZSxzZXJ2ZXI6ci5zZXJ2ZXIsdG9rZW46ZS5hY2Nlc3NfdG9rZW4sZXhwaXJlczpEYXRlLm5vdygpKzFlMypOdW1iZXIoZS5leHBpcmVzX2luKSxzc2w6XCJ0cnVlXCI9PT1lLnNzbCxvQXV0aFN0YXRlOmUuc3RhdGUsX29BdXRoQ3JlZDpzfSk7cmV0dXJuIHQudXNlcklkPWkudXNlcklkLHMuc3RvcmFnZT1lLnBlcnNpc3Q/cTpqLHMucmVmcmVzaFRva2VuPW51bGwscy50b2tlbj1pLnRva2VuLHMuZXhwaXJlcz1pLmV4cGlyZXMscy51c2VySWQ9aS51c2VySWQscy5zc2w9aS5zc2wscy5zYXZlKCksUHJvbWlzZS5yZXNvbHZlKGkpfV9wcm9jZXNzT0F1dGhQb3B1cFBhcmFtcyhlKXtjb25zdCB0PXRoaXMuX29BdXRoRGZkO2lmKHRoaXMuX29BdXRoRGZkPW51bGwsdClpZihjbGVhckludGVydmFsKHRoaXMuX29BdXRoSW50ZXJ2YWxJZCksdGhpcy5fb0F1dGhPblBvcHVwSGFuZGxlPy5yZW1vdmUoKSxlLmVycm9yKXtjb25zdCByPVwiYWNjZXNzX2RlbmllZFwiPT09ZS5lcnJvcixzPW5ldyBpKHI/XCJpZGVudGl0eS1tYW5hZ2VyOnVzZXItYWJvcnRlZFwiOlwiaWRlbnRpdHktbWFuYWdlcjphdXRoZW50aWNhdGlvbi1mYWlsZWRcIixyP1wiQUJPUlRFRFwiOlwiT0F1dGg6IFwiK2UuZXJyb3IrXCIgLSBcIitlLmVycm9yX2Rlc2NyaXB0aW9uKTt0LnJlamVjdChzKX1lbHNlIHRoaXMuX3Byb2Nlc3NPQXV0aFJlc3BvbnNlUGFyYW1zKGUsdC5vaW5mb18sdC5zaW5mb18pLnRoZW4oKGU9Pnt0LnJlc29sdmUoZSl9KSkuY2F0Y2goKGU9Pnt0LnJlamVjdChlKX0pKX1fc2V0T0F1dGhSZXNwb25zZVF1ZXJ5U3RyaW5nKGUpe2UmJihcIj9cIj09PWUuY2hhckF0KDApJiYoZT1lLnN1YnN0cmluZygxKSksdGhpcy5fcHJvY2Vzc09BdXRoUG9wdXBQYXJhbXMoZyhlKSkpfV9leGNoYW5nZVRva2VuKGUsdCxyKXtyZXR1cm4gcyhgJHtlfS9zaGFyaW5nL3Jlc3Qvb2F1dGgyL2V4Y2hhbmdlVG9rZW5gLHthdXRoTW9kZTpcImFub255bW91c1wiLG1ldGhvZDpcInBvc3RcIixxdWVyeTp7ZjpcImpzb25cIixjbGllbnRfaWQ6dCx0b2tlbjpyfX0pLnRoZW4oKGU9PmUuZGF0YS50b2tlbikpfV9nZXRQbGF0Zm9ybVNlbGYoZSx0KXtyZXR1cm4gZT1lLnJlcGxhY2UoL15odHRwOi9pLFwiaHR0cHM6XCIpLHMoYCR7ZX0vc2hhcmluZy9yZXN0L29hdXRoMi9wbGF0Zm9ybVNlbGZgLHthdXRoTW9kZTpcImFub255bW91c1wiLGhlYWRlcnM6e1wiWC1Fc3JpLUF1dGgtQ2xpZW50LUlkXCI6dCxcIlgtRXNyaS1BdXRoLVJlZGlyZWN0LVVyaVwiOndpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyMuKiQvLFwiXCIpfSxtZXRob2Q6XCJwb3N0XCIscXVlcnk6e2Y6XCJqc29uXCIsZXhwaXJhdGlvbjozMH0sd2l0aENyZWRlbnRpYWxzOiEwfSkudGhlbigoZT0+ZS5kYXRhKSl9X2dldFBvcnRhbFNlbGYoZSx0KXtsZXQgcjtpZih0aGlzLl9nd0RvbWFpbnMuc29tZSgodD0+KHQucmVnZXgudGVzdChlKSYmKHI9dC5jdXN0b21CYXNlVXJsKSwhIXIpKSkscilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHthbGxTU0w6ITAsY3VycmVudFZlcnNpb246XCI4LjRcIixjdXN0b21CYXNlVXJsOnIscG9ydGFsTW9kZTpcIm11bHRpdGVuYW50XCIsc3VwcG9ydHNPQXV0aDohMH0pO3RoaXMuX2FwcE9yaWdpbi5zdGFydHNXaXRoKFwiaHR0cHM6XCIpP2U9ZS5yZXBsYWNlKC9eaHR0cDovaSxcImh0dHBzOlwiKS5yZXBsYWNlKC86NzA4MC9pLFwiOjc0NDNcIik6L15odHRwOi9pLnRlc3QodCkmJihlPWUucmVwbGFjZSgvXmh0dHBzOi9pLFwiaHR0cDpcIikucmVwbGFjZSgvOjc0NDMvaSxcIjo3MDgwXCIpKTtyZXR1cm4gcyhlLHtxdWVyeTp7ZjpcImpzb25cIn0sYXV0aE1vZGU6XCJhbm9ueW1vdXNcIix3aXRoQ3JlZGVudGlhbHM6ITB9KS50aGVuKChlPT5lLmRhdGEpKX1fZG9Qb3J0YWxTaWduSW4oZSl7Y29uc3QgdD10aGlzLl9wb3J0YWxDb25maWcscj13aW5kb3cubG9jYXRpb24uaHJlZixzPXRoaXMuZmluZFNlcnZlckluZm8oZSk7cmV0dXJuISghdCYmIXRoaXMuX2lzUG9ydGFsRG9tYWluKHIpfHwhKHM/cy5oYXNQb3J0YWx8fHMub3duaW5nU3lzdGVtVXJsJiZ0aGlzLl9pc1BvcnRhbERvbWFpbihzLm93bmluZ1N5c3RlbVVybCk6dGhpcy5faXNQb3J0YWxEb21haW4oZSkpfHwhKHRoaXMuX2lzSWRQcm92aWRlcihyLGUpfHx0JiYodGhpcy5faGFzU2FtZVNlcnZlckluc3RhbmNlKHRoaXMuX2dldFNlcnZlckluc3RhbmNlUm9vdCh0LnJlc3RCYXNlVXJsKSxlKXx8dGhpcy5faXNJZFByb3ZpZGVyKHQucmVzdEJhc2VVcmwsZSkpfHxfKHIsZSwhMCkpKX1fY2hlY2tQcm90b2NvbChlLHQscixzKXtsZXQgbz0hMDtjb25zdCBuPXM/dC5hZG1pblRva2VuU2VydmljZVVybDp0LnRva2VuU2VydmljZVVybDtpZihuLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJodHRwczpcIikmJiF0aGlzLl9hcHBPcmlnaW4uc3RhcnRzV2l0aChcImh0dHBzOlwiKSYmdyhuKSYmKG89ISF0aGlzLl9wcm90b2NvbEZ1bmMmJiEhdGhpcy5fcHJvdG9jb2xGdW5jKHtyZXNvdXJjZVVybDplLHNlcnZlckluZm86dH0pLCFvKSl7cihuZXcgaShcImlkZW50aXR5LW1hbmFnZXI6YWJvcnRlZFwiLFwiQWJvcnRlZCB0aGUgU2lnbi1JbiBwcm9jZXNzIHRvIGF2b2lkIHNlbmRpbmcgcGFzc3dvcmQgb3ZlciBpbnNlY3VyZSBjb25uZWN0aW9uLlwiKSl9cmV0dXJuIG99X2VucXVldWUoZSx0LHIscyxpLG8pe3JldHVybiBzfHwocz1sKCkpLHMucmVzVXJsXz1lLHMuc2luZm9fPXQscy5vcHRpb25zXz1yLHMuYWRtaW5fPWkscy5yZWZyZXNoXz1vLHRoaXMuX2J1c3k/dGhpcy5faGFzU2FtZVNlcnZlckluc3RhbmNlKHRoaXMuX2dldFNlcnZlckluc3RhbmNlUm9vdChlKSx0aGlzLl9idXN5LnJlc1VybF8pPyh0aGlzLl9vQXV0aERmZCYmdGhpcy5fb0F1dGhEZmQub0F1dGhXaW5fJiZ0aGlzLl9vQXV0aERmZC5vQXV0aFdpbl8uZm9jdXMoKSx0aGlzLl9zb1JlcXMucHVzaChzKSk6dGhpcy5feG9SZXFzLnB1c2gocyk6dGhpcy5fZG9TaWduSW4ocykscy5wcm9taXNlfV9kb1NpZ25JbihlKXt0aGlzLl9idXN5PWUsdGhpcy5fcmVqZWN0T25QZXJzaXN0ZWRQYWdlU2hvdz0hMTtjb25zdCB0PXQ9Pntjb25zdCByPWUub3B0aW9uc18mJmUub3B0aW9uc18ucmVzb3VyY2Uscz1lLnJlc1VybF8saT1lLnJlZnJlc2hfO2xldCBvPSExO3RoaXMuY3JlZGVudGlhbHMuaW5jbHVkZXModCl8fChpJiZ0aGlzLmNyZWRlbnRpYWxzLmluY2x1ZGVzKGkpPyhpLnVzZXJJZD10LnVzZXJJZCxpLnRva2VuPXQudG9rZW4saS5leHBpcmVzPXQuZXhwaXJlcyxpLnZhbGlkaXR5PXQudmFsaWRpdHksaS5zc2w9dC5zc2wsaS5jcmVhdGlvblRpbWU9dC5jcmVhdGlvblRpbWUsbz0hMCx0PWkpOnRoaXMuY3JlZGVudGlhbHMucHVzaCh0KSksdC5yZXNvdXJjZXN8fCh0LnJlc291cmNlcz1bXSksdC5yZXNvdXJjZXMuaW5jbHVkZXMocnx8cyl8fHQucmVzb3VyY2VzLnB1c2gocnx8cyksdC5zY29wZT10aGlzLl9pc1NlcnZlclJzcmMocyk/XCJzZXJ2ZXJcIjpcInBvcnRhbFwiLHQuZW1pdFRva2VuQ2hhbmdlKCk7Y29uc3Qgbj10aGlzLl9zb1JlcXMsYT17fTt0aGlzLl9zb1JlcXM9W10sbi5mb3JFYWNoKChlPT57aWYoIXRoaXMuX2lzSWRlbnRpY2FsU2VydmljZShzLGUucmVzVXJsXykpe2NvbnN0IHI9dGhpcy5fZ2V0U3VmZml4KGUucmVzVXJsXyk7YVtyXXx8KGFbcl09ITAsdC5yZXNvdXJjZXMucHVzaChlLnJlc1VybF8pKX19KSksZS5yZXNvbHZlKHQpLG4uZm9yRWFjaCgoZT0+e3RoaXMuX2hhc1NhbWVTZXJ2ZXJJbnN0YW5jZSh0aGlzLl9nZXRTZXJ2ZXJJbnN0YW5jZVJvb3QocyksZS5yZXNVcmxfKT9lLnJlc29sdmUodCk6dGhpcy5fc29SZXFzLnB1c2goZSl9KSksdGhpcy5fYnVzeT1lLnJlc1VybF89ZS5zaW5mb189ZS5yZWZyZXNoXz1udWxsLG98fHRoaXMuZW1pdChcImNyZWRlbnRpYWwtY3JlYXRlXCIse2NyZWRlbnRpYWw6dH0pLHRoaXMuX3NvUmVxcy5sZW5ndGg/dGhpcy5fZG9TaWduSW4odGhpcy5fc29SZXFzLnNoaWZ0KCkpOnRoaXMuX3hvUmVxcy5sZW5ndGgmJnRoaXMuX2RvU2lnbkluKHRoaXMuX3hvUmVxcy5zaGlmdCgpKX0scj10PT57ZS5yZWplY3QodCksdGhpcy5fYnVzeT1lLnJlc1VybF89ZS5zaW5mb189ZS5yZWZyZXNoXz1udWxsLHRoaXMuX3NvUmVxcy5sZW5ndGg/dGhpcy5fZG9TaWduSW4odGhpcy5fc29SZXFzLnNoaWZ0KCkpOnRoaXMuX3hvUmVxcy5sZW5ndGgmJnRoaXMuX2RvU2lnbkluKHRoaXMuX3hvUmVxcy5zaGlmdCgpKX0scz0obyxhLGgsbCk9Pntjb25zdCBkPWUuc2luZm9fLHU9IWUub3B0aW9uc198fCExIT09ZS5vcHRpb25zXy5wcm9tcHQscD1kLmhhc1BvcnRhbCYmdGhpcy5fZmluZE9BdXRoSW5mbyhlLnJlc1VybF8pO2xldCBmLGc7aWYobyl0KG5ldyBMKHt1c2VySWQ6byxzZXJ2ZXI6ZC5zZXJ2ZXIsdG9rZW46aHx8bnVsbCxleHBpcmVzOm51bGwhPWw/TnVtYmVyKGwpOm51bGwsc3NsOiEhYX0pKTtlbHNlIGlmKHdpbmRvdyE9PXdpbmRvdy5wYXJlbnQmJnRoaXMuX2FwcFVybE9iai5xdWVyeT8uW1wiYXJjZ2lzLWF1dGgtb3JpZ2luXCJdJiZ0aGlzLl9hcHBVcmxPYmoucXVlcnk/LltcImFyY2dpcy1hdXRoLXBvcnRhbFwiXSYmdGhpcy5faGFzU2FtZVNlcnZlckluc3RhbmNlKHRoaXMuX2dldFNlcnZlckluc3RhbmNlUm9vdCh0aGlzLl9hcHBVcmxPYmoucXVlcnlbXCJhcmNnaXMtYXV0aC1wb3J0YWxcIl0pLGUucmVzVXJsXykpe3dpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2Uoe3R5cGU6XCJhcmNnaXM6YXV0aDpyZXF1ZXN0Q3JlZGVudGlhbFwifSx0aGlzLl9hcHBVcmxPYmoucXVlcnlbXCJhcmNnaXMtYXV0aC1vcmlnaW5cIl0pO2NvbnN0IHM9bih3aW5kb3csXCJtZXNzYWdlXCIsKGU9PntlLnNvdXJjZT09PXdpbmRvdy5wYXJlbnQmJmUuZGF0YSYmKFwiYXJjZ2lzOmF1dGg6Y3JlZGVudGlhbFwiPT09ZS5kYXRhLnR5cGU/KHMucmVtb3ZlKCksZS5kYXRhLmNyZWRlbnRpYWwuZXhwaXJlczxEYXRlLm5vdygpP3IobmV3IGkoXCJpZGVudGl0eS1tYW5hZ2VyOmNyZWRlbnRpYWwtcmVxdWVzdC1mYWlsZWRcIixcIlBhcmVudCBhcHBsaWNhdGlvbidzIHRva2VuIGhhcyBleHBpcmVkLlwiKSk6dChuZXcgTChlLmRhdGEuY3JlZGVudGlhbCkpKTpcImFyY2dpczphdXRoOmVycm9yXCI9PT1lLmRhdGEudHlwZSYmKHMucmVtb3ZlKCksXCJ0b2tlbkV4cGlyZWRFcnJvclwiPT09ZS5kYXRhLmVycm9yLm5hbWU/cihuZXcgaShcImlkZW50aXR5LW1hbmFnZXI6Y3JlZGVudGlhbC1yZXF1ZXN0LWZhaWxlZFwiLFwiUGFyZW50IGFwcGxpY2F0aW9uJ3MgdG9rZW4gaGFzIGV4cGlyZWQuXCIpKTpyKGkuZnJvbUpTT04oZS5kYXRhLmVycm9yKSkpKX0pKTtjKGUub3B0aW9uc18/LnNpZ25hbCwoKCk9PntzLnJlbW92ZSgpfSkpfWVsc2UgaWYocCl7bGV0IG89cC5fb0F1dGhDcmVkO2lmKCFvKXtjb25zdCBlPW5ldyB4KHAscSksdD1uZXcgeChwLGopO2UuaXNWYWxpZCgpJiZ0LmlzVmFsaWQoKT9lLmV4cGlyZXM+dC5leHBpcmVzPyhvPWUsdC5kZXN0cm95KCkpOihvPXQsZS5kZXN0cm95KCkpOm89ZS5pc1ZhbGlkKCk/ZTp0LHAuX29BdXRoQ3JlZD1vfWlmKG8uaXNWYWxpZCgpKXtmPW5ldyBMKHt1c2VySWQ6by51c2VySWQsc2VydmVyOmQuc2VydmVyLHRva2VuOm8udG9rZW4sZXhwaXJlczpvLmV4cGlyZXMsc3NsOm8uc3NsLF9vQXV0aENyZWQ6b30pO2NvbnN0IHI9cC5hcHBJZCE9PW8uYXBwSWQmJnRoaXMuX2RvUG9ydGFsU2lnbkluKGUucmVzVXJsXyk7cnx8by5yZWZyZXNoVG9rZW4/KGUuX3BlbmRpbmdEZmQ9by5yZWZyZXNoVG9rZW4/dGhpcy5fZ2V0T0F1dGhUb2tlbihkLnNlcnZlcixvLnJlZnJlc2hUb2tlbixvLmFwcElkKS50aGVuKChlPT4oZi5leHBpcmVzPURhdGUubm93KCkrMWUzKmUuZXhwaXJlc19pbixmLnRva2VuPWUuYWNjZXNzX3Rva2VuLGYpKSk6UHJvbWlzZS5yZXNvbHZlKGYpLGUuX3BlbmRpbmdEZmQudGhlbigoZT0+cj90aGlzLl9leGNoYW5nZVRva2VuKGUuc2VydmVyLHAuYXBwSWQsZS50b2tlbikudGhlbigodD0+KGUudG9rZW49dCxlKSkpLmNhdGNoKCgoKT0+ZSkpOmUpKS50aGVuKChlPT57dChlKX0pKS5jYXRjaCgoKCk9PntvPy5kZXN0cm95KCkscygpfSkpKTp0KGYpfWVsc2UgaWYodGhpcy5fb0F1dGhMb2NhdGlvblBhcmFtcyYmdGhpcy5faGFzU2FtZVNlcnZlckluc3RhbmNlKHAucG9ydGFsVXJsLHRoaXMuX29BdXRoTG9jYXRpb25QYXJhbXMuc3RhdGUucG9ydGFsVXJsKSYmKHRoaXMuX29BdXRoTG9jYXRpb25QYXJhbXMuYWNjZXNzX3Rva2VufHx0aGlzLl9vQXV0aExvY2F0aW9uUGFyYW1zLmNvZGUmJnRoaXMuX29BdXRoTG9jYXRpb25QYXJhbXMuc3RhdGUudWlkPT09by5zdGF0ZVVJRCYmby5jb2RlVmVyaWZpZXIpKXtjb25zdCBzPXRoaXMuX29BdXRoTG9jYXRpb25QYXJhbXM7dGhpcy5fb0F1dGhMb2NhdGlvblBhcmFtcz1udWxsLGUuX3BlbmRpbmdEZmQ9dGhpcy5fcHJvY2Vzc09BdXRoUmVzcG9uc2VQYXJhbXMocyxwLGQpLnRoZW4oKGU9Pnt0KGUpfSkpLmNhdGNoKHIpfWVsc2V7Y29uc3Qgcz0oKT0+e3U/ZS5fcGVuZGluZ0RmZD10aGlzLm9BdXRoU2lnbkluKGUucmVzVXJsXyxkLHAsZS5vcHRpb25zXykudGhlbih0LHIpOihnPW5ldyBpKFwiaWRlbnRpdHktbWFuYWdlcjpub3QtYXV0aGVudGljYXRlZFwiLFwiVXNlciBpcyBub3Qgc2lnbmVkIGluLlwiKSxyKGcpKX07dGhpcy5fZG9Qb3J0YWxTaWduSW4oZS5yZXNVcmxfKT9lLl9wZW5kaW5nRGZkPXRoaXMuX2dldFBsYXRmb3JtU2VsZihkLnNlcnZlcixwLmFwcElkKS50aGVuKChlPT57XyhlLnBvcnRhbFVybCx0aGlzLl9hcHBPcmlnaW4sITApPyhmPW5ldyBMKHt1c2VySWQ6ZS51c2VybmFtZSxzZXJ2ZXI6ZC5zZXJ2ZXIsZXhwaXJlczpEYXRlLm5vdygpKzFlMyplLmV4cGlyZXNfaW4sdG9rZW46ZS50b2tlbn0pLHQoZikpOnMoKX0pKS5jYXRjaChzKTpzKCl9fWVsc2UgaWYodSl7aWYodGhpcy5fY2hlY2tQcm90b2NvbChlLnJlc1VybF8sZCxyLGUuYWRtaW5fKSl7bGV0IHM9ZS5vcHRpb25zXztlLmFkbWluXyYmKHM9c3x8e30scy5pc0FkbWluPSEwKSxlLl9wZW5kaW5nRGZkPXRoaXMuc2lnbkluKGUucmVzVXJsXyxkLHMpLnRoZW4odCxyKX19ZWxzZSBnPW5ldyBpKFwiaWRlbnRpdHktbWFuYWdlcjpub3QtYXV0aGVudGljYXRlZFwiLFwiVXNlciBpcyBub3Qgc2lnbmVkIGluLlwiKSxyKGcpfSxvPSgpPT57Y29uc3Qgcz1lLnNpbmZvXyxpPXMub3duaW5nU3lzdGVtVXJsLG89ZS5vcHRpb25zXztsZXQgbixhLGgsbDtpZihvJiYobj1vLnRva2VuLGE9by5lcnJvcixoPW8ucHJvbXB0KSxsPXRoaXMuX2ZpbmRDcmVkZW50aWFsKGkse3Rva2VuOm4scmVzb3VyY2U6ZS5yZXNVcmxffSksIWwpZm9yKGNvbnN0IGUgb2YgdGhpcy5jcmVkZW50aWFscylpZih0aGlzLl9pc0lkUHJvdmlkZXIoaSxlLnNlcnZlcikpe2w9ZTticmVha31pZihsKXtjb25zdCBpPXRoaXMuZmluZENyZWRlbnRpYWwoZS5yZXNVcmxfLGwudXNlcklkKTtpZihpKXQoaSk7ZWxzZSBpZihEKHMsdGhpcy5fbGVnYWN5RmVkKSl7Y29uc3QgZT1sLnRvSlNPTigpO2Uuc2VydmVyPXMuc2VydmVyLGUucmVzb3VyY2VzPW51bGwsdChuZXcgTChlKSl9ZWxzZXsoZS5fcGVuZGluZ0RmZD10aGlzLmdlbmVyYXRlVG9rZW4odGhpcy5maW5kU2VydmVySW5mbyhsLnNlcnZlciksbnVsbCx7c2VydmVyVXJsOmUucmVzVXJsXyx0b2tlbjpsLnRva2VuLHNpZ25hbDplLm9wdGlvbnNfLnNpZ25hbCxzc2w6bC5zc2x9KSkudGhlbigocj0+e3QobmV3IEwoe3VzZXJJZDpsPy51c2VySWQsc2VydmVyOnMuc2VydmVyLHRva2VuOnIudG9rZW4sZXhwaXJlczpudWxsIT1yLmV4cGlyZXM/TnVtYmVyKHIuZXhwaXJlcyk6bnVsbCxzc2w6ISFyLnNzbCxpc0FkbWluOmUuYWRtaW5fLHZhbGlkaXR5OnIudmFsaWRpdHl9KSl9KSxyKX19ZWxzZXt0aGlzLl9idXN5PW51bGwsbiYmKGUub3B0aW9uc18udG9rZW49bnVsbCk7KGUuX3BlbmRpbmdEZmQ9dGhpcy5nZXRDcmVkZW50aWFsKGkucmVwbGFjZSgvXFwvPyQvLFwiL3NoYXJpbmdcIikse3Jlc291cmNlOmUucmVzVXJsXyxvd25pbmdUZW5hbnQ6cy5vd25pbmdUZW5hbnQsc2lnbmFsOmUub3B0aW9uc18uc2lnbmFsLHRva2VuOm4sZXJyb3I6YSxwcm9tcHQ6aH0pKS50aGVuKCgoKT0+e3RoaXMuX2VucXVldWUoZS5yZXNVcmxfLGUuc2luZm9fLGUub3B0aW9uc18sZSxlLmFkbWluXyl9KSwodD0+e2UucmVzVXJsXz1lLnNpbmZvXz1lLnJlZnJlc2hfPW51bGwsZS5yZWplY3QodCl9KSl9fTt0aGlzLl9lcnJiYWNrRnVuYz1yO2NvbnN0IGE9ZS5zaW5mb18ub3duaW5nU3lzdGVtVXJsLGw9dGhpcy5faXNTZXJ2ZXJSc3JjKGUucmVzVXJsXyksZD1lLnNpbmZvXy5fcmVzdEluZm9QbXM7ZD9kLnByb21pc2UudGhlbigodD0+e2NvbnN0IHI9ZS5zaW5mb187aWYoci5fcmVzdEluZm9QbXMpe3IuYWRtaW5Ub2tlblNlcnZpY2VVcmw9ci5fcmVzdEluZm9QbXMuYWRtaW5Vcmwsci5fcmVzdEluZm9QbXM9bnVsbCxyLnRva2VuU2VydmljZVVybD0oaChcImF1dGhJbmZvLnRva2VuU2VydmljZXNVcmxcIix0KXx8aChcImF1dGhJbmZvLnRva2VuU2VydmljZVVybFwiLHQpfHxoKFwidG9rZW5TZXJ2aWNlVXJsXCIsdCkpPz9udWxsLHIuc2hvcnRMaXZlZFRva2VuVmFsaWRpdHk9aChcImF1dGhJbmZvLnNob3J0TGl2ZWRUb2tlblZhbGlkaXR5XCIsdCk/P251bGwsci5jdXJyZW50VmVyc2lvbj10LmN1cnJlbnRWZXJzaW9uLHIub3duaW5nVGVuYW50PXQub3duaW5nVGVuYW50O2NvbnN0IGU9ci5vd25pbmdTeXN0ZW1Vcmw9dC5vd25pbmdTeXN0ZW1Vcmw7ZSYmdGhpcy5fcG9ydGFscy5wdXNoKGUpfWwmJnIub3duaW5nU3lzdGVtVXJsP28oKTpzKCl9KSwoKCk9PntlLnNpbmZvXy5fcmVzdEluZm9QbXM9bnVsbDtjb25zdCB0PW5ldyBpKFwiaWRlbnRpdHktbWFuYWdlcjpzZXJ2ZXItaWRlbnRpZmljYXRpb24tZmFpbGVkXCIsXCJVbmtub3duIHJlc291cmNlIC0gY291bGQgbm90IGZpbmQgdG9rZW4gc2VydmljZSBlbmRwb2ludC5cIik7cih0KX0pKTpsJiZhP28oKTplLnNpbmZvXy5fc2VsZlJlcT9lLnNpbmZvXy5fc2VsZlJlcS5zZWxmRGZkLnRoZW4oKHQ9Pntjb25zdCByPXt9O2xldCBzLGksbyxuO3JldHVybiB0JiYocz10LnVzZXImJnQudXNlci51c2VybmFtZSxyLnVzZXJuYW1lPXMsci5hbGxTU0w9dC5hbGxTU0wsaT10LnN1cHBvcnRzT0F1dGgsbj1wYXJzZUZsb2F0KHQuY3VycmVudFZlcnNpb24pLFwibXVsdGl0ZW5hbnRcIj09PXQucG9ydGFsTW9kZSYmKG89dC5jdXN0b21CYXNlVXJsKSxlLnNpbmZvXy5jdXJyZW50VmVyc2lvbj1uKSxlLnNpbmZvXy53ZWJUaWVyQXV0aD0hIXMscyYmdGhpcy5ub3JtYWxpemVXZWJUaWVyQXV0aD90aGlzLmdlbmVyYXRlVG9rZW4oZS5zaW5mb18sbnVsbCx7c3NsOnIuYWxsU1NMfSkuY2F0Y2goKCgpPT5udWxsKSkudGhlbigoZT0+KHIucG9ydGFsVG9rZW49ZSYmZS50b2tlbixyLnRva2VuRXhwaXJhdGlvbj1lJiZlLmV4cGlyZXMscikpKTohcyYmaSYmbj49NC40JiYhdGhpcy5fZmluZE9BdXRoSW5mbyhlLnJlc1VybF8pP3RoaXMuX2dlbmVyYXRlT0F1dGhJbmZvKHtwb3J0YWxVcmw6ZS5zaW5mb18uc2VydmVyLGN1c3RvbUJhc2VVcmw6byxvd25pbmdUZW5hbnQ6ZS5zaW5mb18uX3NlbGZSZXEub3duaW5nVGVuYW50fSkuY2F0Y2goKCgpPT5udWxsKSkudGhlbigoKCk9PnIpKTpyfSkpLmNhdGNoKCgoKT0+bnVsbCkpLnRoZW4oKHQ9PntlLnNpbmZvXy5fc2VsZlJlcT1udWxsLHQ/cyh0LnVzZXJuYW1lLHQuYWxsU1NMLHQucG9ydGFsVG9rZW4sdC50b2tlbkV4cGlyYXRpb24pOnMoKX0pKTpzKCl9X2dlbmVyYXRlT0F1dGhJbmZvKGUpe2xldCB0LHI9bnVsbCxpPWUucG9ydGFsVXJsO2NvbnN0IG89ZS5jdXN0b21CYXNlVXJsLG49ZS5vd25pbmdUZW5hbnQsYT0hdGhpcy5fZGVmYXVsdE9BdXRoSW5mbyYmdGhpcy5fY3JlYXRlRGVmYXVsdE9BdXRoSW5mbyYmIXRoaXMuX2hhc1Rlc3RlZElmQXBwSXNPblBvcnRhbDtpZihhKXtyPXdpbmRvdy5sb2NhdGlvbi5ocmVmO2xldCBlPXIuaW5kZXhPZihcIj9cIik7ZT4tMSYmKHI9ci5zbGljZSgwLGUpKSxlPXIuc2VhcmNoKC9cXC8oYXBwc3xob21lKVxcLy8pLHI9ZT4tMT9yLnNsaWNlKDAsZSk6bnVsbH1yZXR1cm4gYSYmcj8odGhpcy5faGFzVGVzdGVkSWZBcHBJc09uUG9ydGFsPSEwLHQ9cyhyK1wiL3NoYXJpbmcvcmVzdFwiLHtxdWVyeTp7ZjpcImpzb25cIn19KS50aGVuKCgoKT0+e3RoaXMuX2RlZmF1bHRPQXV0aEluZm89bmV3IE8oe2FwcElkOlwiYXJjZ2lzb25saW5lXCIscG9wdXBDYWxsYmFja1VybDpyK1wiL2hvbWUvb2F1dGgtY2FsbGJhY2suaHRtbFwifSl9KSkpOnQ9UHJvbWlzZS5yZXNvbHZlKCksdC50aGVuKCgoKT0+e2lmKHRoaXMuX2RlZmF1bHRPQXV0aEluZm8pcmV0dXJuIGk9aS5yZXBsYWNlKC9eaHR0cDovaSxcImh0dHBzOlwiKSxzKGkrXCIvc2hhcmluZy9yZXN0L29hdXRoMi92YWxpZGF0ZVJlZGlyZWN0VXJpXCIse3F1ZXJ5OnthY2NvdW50SWQ6bixjbGllbnRfaWQ6dGhpcy5fZGVmYXVsdE9BdXRoSW5mby5hcHBJZCxyZWRpcmVjdF91cmk6SSh0aGlzLl9kZWZhdWx0T0F1dGhJbmZvLnBvcHVwQ2FsbGJhY2tVcmwpLGY6XCJqc29uXCJ9fSkudGhlbigoZT0+e2lmKGUuZGF0YS52YWxpZCl7Y29uc3QgdD10aGlzLl9kZWZhdWx0T0F1dGhJbmZvLmNsb25lKCk7ZS5kYXRhLnVybEtleSYmbz90LnBvcnRhbFVybD1cImh0dHBzOi8vXCIrZS5kYXRhLnVybEtleS50b0xvd2VyQ2FzZSgpK1wiLlwiK286dC5wb3J0YWxVcmw9aSx0LnBvcHVwPXdpbmRvdyE9PXdpbmRvdy50b3B8fCEoXyhpLHRoaXMuX2FwcE9yaWdpbil8fHRoaXMuX2d3RG9tYWlucy5zb21lKChlPT5lLnJlZ2V4LnRlc3QoaSkmJmUucmVnZXgudGVzdCh0aGlzLl9hcHBPcmlnaW4pKSkpLHRoaXMub0F1dGhJbmZvcy5wdXNoKHQpfX0pKX0pKX1fZG9PQXV0aFNpZ25JbihlLHQscixzKXtjb25zdCBvPXIuX29BdXRoQ3JlZCxhPXtwb3J0YWxVcmw6ci5wb3J0YWxVcmx9OyFyLnBvcHVwJiZyLnByZXNlcnZlVXJsSGFzaCYmd2luZG93LmxvY2F0aW9uLmhhc2gmJihhLmhhc2g9d2luZG93LmxvY2F0aW9uLmhhc2gpLG8uc3RhdGVVSUQmJihhLnVpZD1vLnN0YXRlVUlEKTtjb25zdCBoPXtjbGllbnRfaWQ6ci5hcHBJZCxyZXNwb25zZV90eXBlOm8uY29kZVZlcmlmaWVyP1wiY29kZVwiOlwidG9rZW5cIixzdGF0ZTpKU09OLnN0cmluZ2lmeShhKSxleHBpcmF0aW9uOnIuZXhwaXJhdGlvbixsb2NhbGU6ci5sb2NhbGUscmVkaXJlY3RfdXJpOnRoaXMuX2dldFJlZGlyZWN0VVJJKHIsISFvLmNvZGVWZXJpZmllcil9O3IuZm9yY2VMb2dpbiYmKGguZm9yY2VfbG9naW49ITApLHIuZm9yY2VVc2VySWQmJnIudXNlcklkJiYoaC5wcmVwb3B1bGF0ZWR1c2VybmFtZT1yLnVzZXJJZCksIXIucG9wdXAmJnRoaXMuX2RvUG9ydGFsU2lnbkluKGUpJiYoaC5yZWRpcmVjdFRvVXNlck9yZ1VybD0hMCksby5jb2RlVmVyaWZpZXImJihoLmNvZGVfY2hhbGxlbmdlPXN8fG8uY29kZVZlcmlmaWVyLGguY29kZV9jaGFsbGVuZ2VfbWV0aG9kPXM/XCJTMjU2XCI6XCJwbGFpblwiKTtjb25zdCBsPXIucG9ydGFsVXJsLnJlcGxhY2UoL15odHRwOi9pLFwiaHR0cHM6XCIpK1wiL3NoYXJpbmcvb2F1dGgyL2F1dGhvcml6ZVwiLGM9bCtcIj9cIit2KGgpO2lmKHIucG9wdXApe2NvbnN0IGU9d2luZG93Lm9wZW4oYyxcImVzcmlKU0FQSU9BdXRoXCIsci5wb3B1cFdpbmRvd0ZlYXR1cmVzKTtpZihlKWUuZm9jdXMoKSx0aGlzLl9vQXV0aERmZC5vQXV0aFdpbl89ZSx0aGlzLl9vQXV0aEludGVydmFsSWQ9c2V0SW50ZXJ2YWwoKCgpPT57aWYoZS5jbG9zZWQpe2NsZWFySW50ZXJ2YWwodGhpcy5fb0F1dGhJbnRlcnZhbElkKSx0aGlzLl9vQXV0aE9uUG9wdXBIYW5kbGUucmVtb3ZlKCk7Y29uc3QgZT10aGlzLl9vQXV0aERmZDtpZihlKXtjb25zdCB0PW5ldyBpKFwiaWRlbnRpdHktbWFuYWdlcjp1c2VyLWFib3J0ZWRcIixcIkFCT1JURURcIik7ZS5yZWplY3QodCl9fX0pLDUwMCksdGhpcy5fb0F1dGhPblBvcHVwSGFuZGxlPW4od2luZG93LFtcImFyY2dpczphdXRoOmhhc2hcIixcImFyY2dpczphdXRoOmxvY2F0aW9uOnNlYXJjaFwiXSwoZT0+e1wiYXJjZ2lzOmF1dGg6aGFzaFwiPT09ZS50eXBlP3RoaXMuc2V0T0F1dGhSZXNwb25zZUhhc2goZS5kZXRhaWwpOnRoaXMuX3NldE9BdXRoUmVzcG9uc2VRdWVyeVN0cmluZyhlLmRldGFpbCl9KSk7ZWxzZXtjb25zdCBlPW5ldyBpKFwiaWRlbnRpdHktbWFuYWdlcjpwb3B1cC1ibG9ja2VkXCIsXCJBQk9SVEVEXCIpO3RoaXMuX29BdXRoRGZkLnJlamVjdChlKX19ZWxzZSB0aGlzLl9yZWplY3RPblBlcnNpc3RlZFBhZ2VTaG93PSEwLHRoaXMuX29BdXRoUmVkaXJlY3RGdW5jP3RoaXMuX29BdXRoUmVkaXJlY3RGdW5jKHthdXRob3JpemVQYXJhbXM6aCxhdXRob3JpemVVcmw6bCxyZXNvdXJjZVVybDplLHNlcnZlckluZm86dCxvQXV0aEluZm86cn0pOndpbmRvdy5sb2NhdGlvbi5ocmVmPWN9X2dldFJlZGlyZWN0VVJJKGUsdCl7Y29uc3Qgcj13aW5kb3cubG9jYXRpb24uaHJlZi5yZXBsYWNlKC8jLiokLyxcIlwiKTtpZihlLnBvcHVwKXJldHVybiBJKGUucG9wdXBDYWxsYmFja1VybCk7aWYodCl7Y29uc3QgZT1wKHIpO3JldHVybiBlLnF1ZXJ5JiZbXCJjb2RlXCIsXCJlcnJvclwiLFwiZXJyb3JfZGVzY3JpcHRpb25cIixcIm1lc3NhZ2VfY29kZVwiLFwicGVyc2lzdFwiLFwic3RhdGVcIl0uZm9yRWFjaCgodD0+e2RlbGV0ZSBlLnF1ZXJ5W3RdfSkpLEEoZS5wYXRoLGUucXVlcnkpfXJldHVybiByfX1FLnByb3RvdHlwZS5kZWNsYXJlZENsYXNzPVwiZXNyaS5pZGVudGl0eS5JZGVudGl0eU1hbmFnZXJCYXNlXCI7bGV0IEw9Y2xhc3MgZXh0ZW5kcyBvLkV2ZW50ZWRBY2Nlc3Nvcntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLl9vQXV0aENyZWQ9bnVsbCx0aGlzLnRva2VuUmVmcmVzaEJ1ZmZlcj0yLGUmJmUuX29BdXRoQ3JlZCYmKHRoaXMuX29BdXRoQ3JlZD1lLl9vQXV0aENyZWQpfWluaXRpYWxpemUoKXt0aGlzLnJlc291cmNlcz10aGlzLnJlc291cmNlc3x8W10sbnVsbD09dGhpcy5jcmVhdGlvblRpbWUmJih0aGlzLmNyZWF0aW9uVGltZT1EYXRlLm5vdygpKX1yZWZyZXNoVG9rZW4oKXtjb25zdCBlPXIuZmluZFNlcnZlckluZm8odGhpcy5zZXJ2ZXIpLHQ9ZSYmZS5vd25pbmdTeXN0ZW1Vcmwscz0hIXQmJlwic2VydmVyXCI9PT10aGlzLnNjb3BlLGk9cyYmRChlLHIuX2xlZ2FjeUZlZCksbz1lLndlYlRpZXJBdXRoLG49byYmci5ub3JtYWxpemVXZWJUaWVyQXV0aCxhPUNbdGhpcy5zZXJ2ZXJdLGg9YSYmYVt0aGlzLnVzZXJJZF07bGV0IGwsYz10aGlzLnJlc291cmNlcyYmdGhpcy5yZXNvdXJjZXNbMF0sZD1zP3IuZmluZFNlcnZlckluZm8odCk6bnVsbCx1PXt1c2VybmFtZTp0aGlzLnVzZXJJZCxwYXNzd29yZDpofTtpZihvJiYhbilyZXR1cm47cyYmIWQmJnIuc2VydmVySW5mb3Muc29tZSgoZT0+KHIuX2lzSWRQcm92aWRlcih0LGUuc2VydmVyKSYmKGQ9ZSksISFkKSkpO2NvbnN0IHA9ZD9yLmZpbmRDcmVkZW50aWFsKGQuc2VydmVyLHRoaXMudXNlcklkKTpudWxsO2lmKCFzfHxwKXtpZighaSl7aWYocylsPXtzZXJ2ZXJVcmw6Yyx0b2tlbjpwJiZwLnRva2VuLHNzbDpwJiZwLnNzbH07ZWxzZSBpZihuKXU9bnVsbCxsPXtzc2w6dGhpcy5zc2x9O2Vsc2V7aWYoIWgpe2xldCB0O3JldHVybiBjJiYoYz1yLl9zYW5pdGl6ZVVybChjKSx0aGlzLl9lbnF1ZXVlZD0xLHQ9ci5fZW5xdWV1ZShjLGUsbnVsbCxudWxsLHRoaXMuaXNBZG1pbix0aGlzKSx0LnRoZW4oKCgpPT57dGhpcy5fZW5xdWV1ZWQ9MCx0aGlzLnJlZnJlc2hTZXJ2ZXJUb2tlbnMoKX0pKS5jYXRjaCgoKCk9Pnt0aGlzLl9lbnF1ZXVlZD0wfSkpKSx0fXRoaXMuaXNBZG1pbiYmKGw9e2lzQWRtaW46ITB9KX1yZXR1cm4gci5nZW5lcmF0ZVRva2VuKHM/ZDplLHM/bnVsbDp1LGwpLnRoZW4oKGU9Pnt0aGlzLnRva2VuPWUudG9rZW4sdGhpcy5leHBpcmVzPW51bGwhPWUuZXhwaXJlcz9OdW1iZXIoZS5leHBpcmVzKTpudWxsLHRoaXMuY3JlYXRpb25UaW1lPURhdGUubm93KCksdGhpcy52YWxpZGl0eT1lLnZhbGlkaXR5LHRoaXMuZW1pdFRva2VuQ2hhbmdlKCksdGhpcy5yZWZyZXNoU2VydmVyVG9rZW5zKCl9KSkuY2F0Y2goKCgpPT57fSkpfXA/LnJlZnJlc2hUb2tlbigpfX1yZWZyZXNoU2VydmVyVG9rZW5zKCl7XCJwb3J0YWxcIj09PXRoaXMuc2NvcGUmJnIuY3JlZGVudGlhbHMuZm9yRWFjaCgoZT0+e2NvbnN0IHQ9ci5maW5kU2VydmVySW5mbyhlLnNlcnZlcikscz10JiZ0Lm93bmluZ1N5c3RlbVVybDtlIT09dGhpcyYmZS51c2VySWQ9PT10aGlzLnVzZXJJZCYmcyYmXCJzZXJ2ZXJcIj09PWUuc2NvcGUmJihyLl9oYXNTYW1lU2VydmVySW5zdGFuY2UodGhpcy5zZXJ2ZXIscyl8fHIuX2lzSWRQcm92aWRlcihzLHRoaXMuc2VydmVyKSkmJihEKHQsci5fbGVnYWN5RmVkKT8oZS50b2tlbj10aGlzLnRva2VuLGUuZXhwaXJlcz10aGlzLmV4cGlyZXMsZS5jcmVhdGlvblRpbWU9dGhpcy5jcmVhdGlvblRpbWUsZS52YWxpZGl0eT10aGlzLnZhbGlkaXR5LGUuZW1pdFRva2VuQ2hhbmdlKCkpOmUucmVmcmVzaFRva2VuKCkpfSkpfWVtaXRUb2tlbkNoYW5nZShlKXtjbGVhclRpbWVvdXQodGhpcy5fcmVmcmVzaFRpbWVyKTtjb25zdCB0PXRoaXMuc2VydmVyJiZyLmZpbmRTZXJ2ZXJJbmZvKHRoaXMuc2VydmVyKSxzPXQmJnQub3duaW5nU3lzdGVtVXJsLGk9cyYmci5maW5kU2VydmVySW5mbyhzKTshMT09PWV8fHMmJlwicG9ydGFsXCIhPT10aGlzLnNjb3BlJiYoIWl8fCFpLndlYlRpZXJBdXRofHxyLm5vcm1hbGl6ZVdlYlRpZXJBdXRoKXx8bnVsbD09dGhpcy5leHBpcmVzJiZudWxsPT10aGlzLnZhbGlkaXR5fHx0aGlzLl9zdGFydFJlZnJlc2hUaW1lcigpLHRoaXMuZW1pdChcInRva2VuLWNoYW5nZVwiKX1kZXN0cm95KCl7dGhpcy51c2VySWQ9dGhpcy5zZXJ2ZXI9dGhpcy50b2tlbj10aGlzLmV4cGlyZXM9dGhpcy52YWxpZGl0eT10aGlzLnJlc291cmNlcz10aGlzLmNyZWF0aW9uVGltZT1udWxsLHRoaXMuX29BdXRoQ3JlZCYmKHRoaXMuX29BdXRoQ3JlZC5kZXN0cm95KCksdGhpcy5fb0F1dGhDcmVkPW51bGwpO2NvbnN0IGU9ci5jcmVkZW50aWFscy5pbmRleE9mKHRoaXMpO2U+LTEmJnIuY3JlZGVudGlhbHMuc3BsaWNlKGUsMSksdGhpcy5lbWl0VG9rZW5DaGFuZ2UoKSx0aGlzLmVtaXQoXCJkZXN0cm95XCIpfXRvSlNPTigpe2NvbnN0IGU9YSh7dXNlcklkOnRoaXMudXNlcklkLHNlcnZlcjp0aGlzLnNlcnZlcix0b2tlbjp0aGlzLnRva2VuLGV4cGlyZXM6dGhpcy5leHBpcmVzLHZhbGlkaXR5OnRoaXMudmFsaWRpdHksc3NsOnRoaXMuc3NsLGlzQWRtaW46dGhpcy5pc0FkbWluLGNyZWF0aW9uVGltZTp0aGlzLmNyZWF0aW9uVGltZSxzY29wZTp0aGlzLnNjb3BlfSksdD10aGlzLnJlc291cmNlcztyZXR1cm4gdCYmdC5sZW5ndGg+MCYmKGUucmVzb3VyY2VzPXQuc2xpY2UoKSksZX1fc3RhcnRSZWZyZXNoVGltZXIoKXtjbGVhclRpbWVvdXQodGhpcy5fcmVmcmVzaFRpbWVyKTtjb25zdCBlPTZlNCp0aGlzLnRva2VuUmVmcmVzaEJ1ZmZlcix0PTIqKjMxLTE7bGV0IHI9KHRoaXMudmFsaWRpdHk/dGhpcy5jcmVhdGlvblRpbWUrNmU0KnRoaXMudmFsaWRpdHk6dGhpcy5leHBpcmVzKS1EYXRlLm5vdygpO3I8MD9yPTA6cj50JiYocj10KSx0aGlzLl9yZWZyZXNoVGltZXI9c2V0VGltZW91dCh0aGlzLnJlZnJlc2hUb2tlbi5iaW5kKHRoaXMpLHI+ZT9yLWU6cil9fTtlKFtrKCldLEwucHJvdG90eXBlLFwiY3JlYXRpb25UaW1lXCIsdm9pZCAwKSxlKFtrKCldLEwucHJvdG90eXBlLFwiZXhwaXJlc1wiLHZvaWQgMCksZShbaygpXSxMLnByb3RvdHlwZSxcImlzQWRtaW5cIix2b2lkIDApLGUoW2soKV0sTC5wcm90b3R5cGUsXCJvQXV0aFN0YXRlXCIsdm9pZCAwKSxlKFtrKCldLEwucHJvdG90eXBlLFwicmVzb3VyY2VzXCIsdm9pZCAwKSxlKFtrKCldLEwucHJvdG90eXBlLFwic2NvcGVcIix2b2lkIDApLGUoW2soKV0sTC5wcm90b3R5cGUsXCJzZXJ2ZXJcIix2b2lkIDApLGUoW2soKV0sTC5wcm90b3R5cGUsXCJzc2xcIix2b2lkIDApLGUoW2soKV0sTC5wcm90b3R5cGUsXCJ0b2tlblwiLHZvaWQgMCksZShbaygpXSxMLnByb3RvdHlwZSxcInRva2VuUmVmcmVzaEJ1ZmZlclwiLHZvaWQgMCksZShbaygpXSxMLnByb3RvdHlwZSxcInVzZXJJZFwiLHZvaWQgMCksZShbaygpXSxMLnByb3RvdHlwZSxcInZhbGlkaXR5XCIsdm9pZCAwKSxMPWUoW3koXCJlc3JpLmlkZW50aXR5LkNyZWRlbnRpYWxcIildLEwpO2V4cG9ydHtMIGFzIENyZWRlbnRpYWwsRSBhcyBJZGVudGl0eU1hbmFnZXJCYXNlfTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnR7XyBhcyB0fWZyb21cIi4uL2NodW5rcy90c2xpYi5lczYuanNcIjtpbXBvcnR7bWFrZUhhbmRsZSBhcyBlfWZyb21cIi4uL2NvcmUvaGFuZGxlVXRpbHMuanNcIjtpbXBvcnR7d2F0Y2ggYXMgb31mcm9tXCIuLi9jb3JlL3JlYWN0aXZlVXRpbHMuanNcIjtpbXBvcnR7cHJvcGVydHkgYXMgc31mcm9tXCIuLi9jb3JlL2FjY2Vzc29yU3VwcG9ydC9kZWNvcmF0b3JzL3Byb3BlcnR5LmpzXCI7aW1wb3J0XCIuLi9jb3JlL2FjY2Vzc29yU3VwcG9ydC9lbnN1cmVUeXBlLmpzXCI7aW1wb3J0XCIuLi9jb3JlL2FycmF5VXRpbHMuanNcIjtpbXBvcnRcIi4uL2NvcmUvaGFzLmpzXCI7aW1wb3J0e3N1YmNsYXNzIGFzIGl9ZnJvbVwiLi4vY29yZS9hY2Nlc3NvclN1cHBvcnQvZGVjb3JhdG9ycy9zdWJjbGFzcy5qc1wiO2ltcG9ydCByIGZyb21cIi4uL3dpZGdldHMvV2lkZ2V0LmpzXCI7aW1wb3J0e2lzV2lkZ2V0IGFzIG59ZnJvbVwiLi4vd2lkZ2V0cy9zdXBwb3J0L3dpZGdldC5qc1wiO2ltcG9ydHtjcmVhdGVGb2N1c1RyYXAgYXMgYX1mcm9tXCJmb2N1cy10cmFwXCI7aW1wb3J0e3RzeCBhcyBjfWZyb21cIi4uL3dpZGdldHMvc3VwcG9ydC9qc3hGYWN0b3J5LmpzXCI7aW1wb3J0e21lc3NhZ2VCdW5kbGUgYXMgbH1mcm9tXCIuLi93aWRnZXRzL3N1cHBvcnQvZGVjb3JhdG9ycy9tZXNzYWdlQnVuZGxlLmpzXCI7Y29uc3QgZD1cImVzcmktaWRlbnRpdHktbW9kYWxcIixwPXtiYXNlOmQsb3BlbjpgJHtkfS0tb3BlbmAsY2xvc2VkOmAke2R9LS1jbG9zZWRgLHRpdGxlOmAke2R9X190aXRsZWAsZGlhbG9nOmAke2R9X19kaWFsb2dgLGNvbnRlbnQ6YCR7ZH1fX2NvbnRlbnRgLGNsb3NlQnV0dG9uOmAke2R9X19jbG9zZS1idXR0b25gLGljb25DbG9zZTpcImVzcmktaWNvbi1jbG9zZVwifTtsZXQgdT1jbGFzcyBleHRlbmRzIHJ7Y29uc3RydWN0b3IodCxlKXtzdXBlcih0LGUpLHRoaXMuY29udGFpbmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5jb250ZW50PW51bGwsdGhpcy5vcGVuPSExLHRoaXMuX2ZvY3VzVHJhcD1udWxsLHRoaXMuX2Nsb3NlPSgpPT57dGhpcy5vcGVuPSExfSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKSx0aGlzLmFkZEhhbmRsZXMobygoKCk9PnRoaXMub3BlbiksKCgpPT50aGlzLl90b2dnbGVGb2N1c1RyYXAoKSkpKX1kZXN0cm95KCl7dGhpcy5fZGVzdHJveUZvY3VzVHJhcCgpfWdldCB0aXRsZSgpe3JldHVybiB0aGlzLm1lc3NhZ2VzPy5hdXRoLnNpZ25Jbn1yZW5kZXIoKXtjb25zdCB0PXRoaXMuaWQse29wZW46ZSxjb250ZW50Om8sdGl0bGU6cyxtZXNzYWdlczppfT10aGlzLHI9ZSYmISFvLG49e1twLm9wZW5dOnIsW3AuY2xvc2VkXTohcn0sYT1jKFwiYnV0dG9uXCIse2NsYXNzOnAuY2xvc2VCdXR0b24sXCJhcmlhLWxhYmVsXCI6aS5jbG9zZSx0aXRsZTppLmNsb3NlLGJpbmQ6dGhpcyxvbmNsaWNrOnRoaXMuX2Nsb3NlLHR5cGU6XCJidXR0b25cIn0sYyhcInNwYW5cIix7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwiLGNsYXNzOnAuaWNvbkNsb3NlfSkpLGw9YCR7dH1fdGl0bGVgLGQ9YCR7dH1fY29udGVudGAsdT1zP2MoXCJoMVwiLHtpZDpsLGNsYXNzOnAudGl0bGV9LHMpOm51bGwsaD1yP2MoXCJkaXZcIix7YmluZDp0aGlzLGNsYXNzOnAuZGlhbG9nLHJvbGU6XCJkaWFsb2dcIixcImFyaWEtbGFiZWxsZWRieVwiOmwsXCJhcmlhLWRlc2NyaWJlZGJ5XCI6ZCxhZnRlckNyZWF0ZTp0aGlzLl9jcmVhdGVGb2N1c1RyYXB9LGEsdSx0aGlzLl9yZW5kZXJDb250ZW50KGQpKTpudWxsO3JldHVybiBjKFwiZGl2XCIse3RhYkluZGV4Oi0xLGNsYXNzOnRoaXMuY2xhc3NlcyhwLmJhc2Usbil9LGgpfV9kZXN0cm95Rm9jdXNUcmFwKCl7dGhpcy5fZm9jdXNUcmFwPy5kZWFjdGl2YXRlKHtvbkRlYWN0aXZhdGU6KCk9Pnt9fSksdGhpcy5fZm9jdXNUcmFwPW51bGx9X3RvZ2dsZUZvY3VzVHJhcCgpe2NvbnN0e19mb2N1c1RyYXA6dCxvcGVuOmV9PXRoaXM7dCYmKGU/dC5hY3RpdmF0ZSgpOnQuZGVhY3RpdmF0ZSgpKX1fY3JlYXRlRm9jdXNUcmFwKHQpe3RoaXMuX2Rlc3Ryb3lGb2N1c1RyYXAoKTtjb25zdCBvPXJlcXVlc3RBbmltYXRpb25GcmFtZSgoKCk9Pnt0aGlzLl9mb2N1c1RyYXA9YSh0LHtpbml0aWFsRm9jdXM6XCJpbnB1dFwiLG9uRGVhY3RpdmF0ZTp0aGlzLl9jbG9zZX0pLHRoaXMuX3RvZ2dsZUZvY3VzVHJhcCgpfSkpO3RoaXMuYWRkSGFuZGxlcyhlKCgoKT0+Y2FuY2VsQW5pbWF0aW9uRnJhbWUobykpKSl9X3JlbmRlckNvbnRlbnQodCl7Y29uc3QgZT10aGlzLmNvbnRlbnQ7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/YyhcImRpdlwiLHtjbGFzczpwLmNvbnRlbnQsaWQ6dCxpbm5lckhUTUw6ZX0pOm4oZSk/YyhcImRpdlwiLHtjbGFzczpwLmNvbnRlbnQsaWQ6dH0sZS5yZW5kZXIoKSk6ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50P2MoXCJkaXZcIix7Y2xhc3M6cC5jb250ZW50LGlkOnQsYmluZDplLGFmdGVyQ3JlYXRlOnRoaXMuX2F0dGFjaFRvTm9kZX0pOm51bGx9X2F0dGFjaFRvTm9kZSh0KXtjb25zdCBlPXRoaXM7dC5hcHBlbmRDaGlsZChlKX19O3QoW3Moe3JlYWRPbmx5OiEwfSldLHUucHJvdG90eXBlLFwiY29udGFpbmVyXCIsdm9pZCAwKSx0KFtzKCldLHUucHJvdG90eXBlLFwiY29udGVudFwiLHZvaWQgMCksdChbcygpXSx1LnByb3RvdHlwZSxcIm9wZW5cIix2b2lkIDApLHQoW3MoKSxsKFwiZXNyaS90OW4vY29tbW9uXCIpXSx1LnByb3RvdHlwZSxcIm1lc3NhZ2VzXCIsdm9pZCAwKSx0KFtzKCldLHUucHJvdG90eXBlLFwidGl0bGVcIixudWxsKSx1PXQoW2koXCJlc3JpLmlkZW50aXR5LklkZW50aXR5TW9kYWxcIildLHUpO2NvbnN0IGg9dTtleHBvcnR7aCBhcyBkZWZhdWx0fTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5jb25zdCB0PVwiZXNyaUpTQVBJT0F1dGhcIjtjbGFzcyBle2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5vQXV0aEluZm89bnVsbCx0aGlzLnN0b3JhZ2U9bnVsbCx0aGlzLmFwcElkPW51bGwsdGhpcy5jb2RlVmVyaWZpZXI9bnVsbCx0aGlzLmV4cGlyZXM9bnVsbCx0aGlzLnJlZnJlc2hUb2tlbj1udWxsLHRoaXMuc3NsPW51bGwsdGhpcy5zdGF0ZVVJRD1udWxsLHRoaXMudG9rZW49bnVsbCx0aGlzLnVzZXJJZD1udWxsLHRoaXMub0F1dGhJbmZvPXQsdGhpcy5zdG9yYWdlPWUsdGhpcy5faW5pdCgpfWlzVmFsaWQoKXtsZXQgdD0hMTtpZih0aGlzLm9BdXRoSW5mbyYmdGhpcy51c2VySWQmJih0aGlzLnJlZnJlc2hUb2tlbnx8dGhpcy50b2tlbikpaWYobnVsbD09dGhpcy5leHBpcmVzJiZ0aGlzLnJlZnJlc2hUb2tlbil0PSEwO2Vsc2UgaWYodGhpcy5leHBpcmVzKXtjb25zdCBlPURhdGUubm93KCk7aWYodGhpcy5leHBpcmVzPmUpeyh0aGlzLmV4cGlyZXMtZSkvMWUzPjYwKnRoaXMub0F1dGhJbmZvLm1pblRpbWVVbnRpbEV4cGlyYXRpb24mJih0PSEwKX19cmV0dXJuIHR9c2F2ZSgpe2lmKCF0aGlzLnN0b3JhZ2UpcmV0dXJuITE7Y29uc3QgZT10aGlzLl9sb2FkKCkscz10aGlzLm9BdXRoSW5mbztpZihzJiZzLmF1dGhOYW1lc3BhY2UmJnMucG9ydGFsVXJsKXtsZXQgcj1lW3MuYXV0aE5hbWVzcGFjZV07cnx8KHI9ZVtzLmF1dGhOYW1lc3BhY2VdPXt9KSx0aGlzLmFwcElkfHwodGhpcy5hcHBJZD1zLmFwcElkKSxyW3MucG9ydGFsVXJsXT17YXBwSWQ6dGhpcy5hcHBJZCxjb2RlVmVyaWZpZXI6dGhpcy5jb2RlVmVyaWZpZXIsZXhwaXJlczp0aGlzLmV4cGlyZXMscmVmcmVzaFRva2VuOnRoaXMucmVmcmVzaFRva2VuLHNzbDp0aGlzLnNzbCxzdGF0ZVVJRDp0aGlzLnN0YXRlVUlELHRva2VuOnRoaXMudG9rZW4sdXNlcklkOnRoaXMudXNlcklkfTt0cnl7dGhpcy5zdG9yYWdlLnNldEl0ZW0odCxKU09OLnN0cmluZ2lmeShlKSl9Y2F0Y2goaSl7cmV0dXJuIGNvbnNvbGUud2FybihpKSwhMX1yZXR1cm4hMH1yZXR1cm4hMX1kZXN0cm95KCl7Y29uc3QgZT10aGlzLl9sb2FkKCkscz10aGlzLm9BdXRoSW5mbztpZihzJiZzLmFwcElkJiZzLnBvcnRhbFVybCYmKG51bGw9PXRoaXMuZXhwaXJlc3x8dGhpcy5leHBpcmVzPkRhdGUubm93KCkpJiYodGhpcy5yZWZyZXNoVG9rZW58fHRoaXMudG9rZW4pKXtjb25zdCB0PXMucG9ydGFsVXJsLnJlcGxhY2UoL15odHRwOi9pLFwiaHR0cHM6XCIpK1wiL3NoYXJpbmcvcmVzdC9vYXV0aDIvcmV2b2tlVG9rZW5cIixlPW5ldyBGb3JtRGF0YTtpZihlLmFwcGVuZChcImZcIixcImpzb25cIiksZS5hcHBlbmQoXCJhdXRoX3Rva2VuXCIsdGhpcy5yZWZyZXNoVG9rZW58fHRoaXMudG9rZW4pLGUuYXBwZW5kKFwiY2xpZW50X2lkXCIscy5hcHBJZCksZS5hcHBlbmQoXCJ0b2tlbl90eXBlX2hpbnRcIix0aGlzLnJlZnJlc2hUb2tlbj9cInJlZnJlc2hfdG9rZW5cIjpcImFjY2Vzc190b2tlblwiKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiluYXZpZ2F0b3Iuc2VuZEJlYWNvbih0LGUpO2Vsc2V7Y29uc3Qgcz1uZXcgWE1MSHR0cFJlcXVlc3Q7cy5vcGVuKFwiUE9TVFwiLHQpLHMuc2VuZChlKX19aWYocyYmcy5hdXRoTmFtZXNwYWNlJiZzLnBvcnRhbFVybCYmdGhpcy5zdG9yYWdlKXtjb25zdCByPWVbcy5hdXRoTmFtZXNwYWNlXTtpZihyKXtkZWxldGUgcltzLnBvcnRhbFVybF07dHJ5e3RoaXMuc3RvcmFnZS5zZXRJdGVtKHQsSlNPTi5zdHJpbmdpZnkoZSkpfWNhdGNoKGkpe2NvbnNvbGUubG9nKGkpfX19cyYmKHMuX29BdXRoQ3JlZD1udWxsLHRoaXMub0F1dGhJbmZvPW51bGwpfV9pbml0KCl7Y29uc3QgdD10aGlzLl9sb2FkKCksZT10aGlzLm9BdXRoSW5mbztpZihlJiZlLmF1dGhOYW1lc3BhY2UmJmUucG9ydGFsVXJsKXtsZXQgcz10W2UuYXV0aE5hbWVzcGFjZV07cyYmKHM9c1tlLnBvcnRhbFVybF0scyYmKHRoaXMuYXBwSWQ9cy5hcHBJZCx0aGlzLmNvZGVWZXJpZmllcj1zLmNvZGVWZXJpZmllcix0aGlzLmV4cGlyZXM9cy5leHBpcmVzLHRoaXMucmVmcmVzaFRva2VuPXMucmVmcmVzaFRva2VuLHRoaXMuc3NsPXMuc3NsLHRoaXMuc3RhdGVVSUQ9cy5zdGF0ZVVJRCx0aGlzLnRva2VuPXMudG9rZW4sdGhpcy51c2VySWQ9cy51c2VySWQpKX19X2xvYWQoKXtsZXQgZT17fTtpZih0aGlzLnN0b3JhZ2Upe2NvbnN0IGk9dGhpcy5zdG9yYWdlLmdldEl0ZW0odCk7aWYoaSl0cnl7ZT1KU09OLnBhcnNlKGkpfWNhdGNoKHMpe2NvbnNvbGUud2FybihzKX19cmV0dXJuIGV9fWUucHJvdG90eXBlLmRlY2xhcmVkQ2xhc3M9XCJlc3JpLmlkZW50aXR5Lk9BdXRoQ3JlZGVudGlhbFwiO2V4cG9ydHtlIGFzIGRlZmF1bHR9O1xuIiwiLypcbkFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG5TZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMjcvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxuKi9cbmltcG9ydHtfIGFzIG99ZnJvbVwiLi4vY2h1bmtzL3RzbGliLmVzNi5qc1wiO2ltcG9ydHtKU09OU3VwcG9ydCBhcyB0fWZyb21cIi4uL2NvcmUvSlNPTlN1cHBvcnQuanNcIjtpbXBvcnR7cHJvcGVydHkgYXMgcn1mcm9tXCIuLi9jb3JlL2FjY2Vzc29yU3VwcG9ydC9kZWNvcmF0b3JzL3Byb3BlcnR5LmpzXCI7aW1wb3J0XCIuLi9jb3JlL2FjY2Vzc29yU3VwcG9ydC9lbnN1cmVUeXBlLmpzXCI7aW1wb3J0XCIuLi9jb3JlL2FycmF5VXRpbHMuanNcIjtpbXBvcnRcIi4uL2NvcmUvaGFzLmpzXCI7aW1wb3J0e3N1YmNsYXNzIGFzIGV9ZnJvbVwiLi4vY29yZS9hY2Nlc3NvclN1cHBvcnQvZGVjb3JhdG9ycy9zdWJjbGFzcy5qc1wiO3ZhciBwO2xldCBzPXA9Y2xhc3MgZXh0ZW5kcyB0e2NvbnN0cnVjdG9yKG8pe3N1cGVyKG8pLHRoaXMuX29BdXRoQ3JlZD1udWxsLHRoaXMuYXBwSWQ9bnVsbCx0aGlzLmF1dGhOYW1lc3BhY2U9XCIvXCIsdGhpcy5leHBpcmF0aW9uPTIwMTYwLHRoaXMuZmxvd1R5cGU9XCJhdXRvXCIsdGhpcy5mb3JjZUxvZ2luPSExLHRoaXMuZm9yY2VVc2VySWQ9ITEsdGhpcy5sb2NhbGU9bnVsbCx0aGlzLm1pblRpbWVVbnRpbEV4cGlyYXRpb249MzAsdGhpcy5wb3B1cD0hMSx0aGlzLnBvcHVwQ2FsbGJhY2tVcmw9XCJvYXV0aC1jYWxsYmFjay5odG1sXCIsdGhpcy5wb3B1cFdpbmRvd0ZlYXR1cmVzPVwiaGVpZ2h0PTQ5MCx3aWR0aD04MDAscmVzaXphYmxlLHNjcm9sbGJhcnMsc3RhdHVzXCIsdGhpcy5wb3J0YWxVcmw9XCJodHRwczovL3d3dy5hcmNnaXMuY29tXCIsdGhpcy5wcmVzZXJ2ZVVybEhhc2g9ITEsdGhpcy51c2VySWQ9bnVsbH1jbG9uZSgpe3JldHVybiBwLmZyb21KU09OKHRoaXMudG9KU09OKCkpfX07byhbcih7anNvbjp7d3JpdGU6ITB9fSldLHMucHJvdG90eXBlLFwiYXBwSWRcIix2b2lkIDApLG8oW3Ioe2pzb246e3dyaXRlOiEwfX0pXSxzLnByb3RvdHlwZSxcImF1dGhOYW1lc3BhY2VcIix2b2lkIDApLG8oW3Ioe2pzb246e3dyaXRlOiEwfX0pXSxzLnByb3RvdHlwZSxcImV4cGlyYXRpb25cIix2b2lkIDApLG8oW3Ioe2pzb246e3dyaXRlOiEwfX0pXSxzLnByb3RvdHlwZSxcImZsb3dUeXBlXCIsdm9pZCAwKSxvKFtyKHtqc29uOnt3cml0ZTohMH19KV0scy5wcm90b3R5cGUsXCJmb3JjZUxvZ2luXCIsdm9pZCAwKSxvKFtyKHtqc29uOnt3cml0ZTohMH19KV0scy5wcm90b3R5cGUsXCJmb3JjZVVzZXJJZFwiLHZvaWQgMCksbyhbcih7anNvbjp7d3JpdGU6ITB9fSldLHMucHJvdG90eXBlLFwibG9jYWxlXCIsdm9pZCAwKSxvKFtyKHtqc29uOnt3cml0ZTohMH19KV0scy5wcm90b3R5cGUsXCJtaW5UaW1lVW50aWxFeHBpcmF0aW9uXCIsdm9pZCAwKSxvKFtyKHtqc29uOnt3cml0ZTohMH19KV0scy5wcm90b3R5cGUsXCJwb3B1cFwiLHZvaWQgMCksbyhbcih7anNvbjp7d3JpdGU6ITB9fSldLHMucHJvdG90eXBlLFwicG9wdXBDYWxsYmFja1VybFwiLHZvaWQgMCksbyhbcih7anNvbjp7d3JpdGU6ITB9fSldLHMucHJvdG90eXBlLFwicG9wdXBXaW5kb3dGZWF0dXJlc1wiLHZvaWQgMCksbyhbcih7anNvbjp7d3JpdGU6ITB9fSldLHMucHJvdG90eXBlLFwicG9ydGFsVXJsXCIsdm9pZCAwKSxvKFtyKHtqc29uOnt3cml0ZTohMH19KV0scy5wcm90b3R5cGUsXCJwcmVzZXJ2ZVVybEhhc2hcIix2b2lkIDApLG8oW3Ioe2pzb246e3dyaXRlOiEwfX0pXSxzLnByb3RvdHlwZSxcInVzZXJJZFwiLHZvaWQgMCkscz1wPW8oW2UoXCJlc3JpLmlkZW50aXR5Lk9BdXRoSW5mb1wiKV0scyk7Y29uc3QgaT1zO2V4cG9ydHtpIGFzIGRlZmF1bHR9O1xuIiwiLypcbkFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG5TZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMjcvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxuKi9cbmltcG9ydHtfIGFzIG99ZnJvbVwiLi4vY2h1bmtzL3RzbGliLmVzNi5qc1wiO2ltcG9ydHtKU09OU3VwcG9ydCBhcyByfWZyb21cIi4uL2NvcmUvSlNPTlN1cHBvcnQuanNcIjtpbXBvcnR7cHJvcGVydHkgYXMgZX1mcm9tXCIuLi9jb3JlL2FjY2Vzc29yU3VwcG9ydC9kZWNvcmF0b3JzL3Byb3BlcnR5LmpzXCI7aW1wb3J0XCIuLi9jb3JlL2FjY2Vzc29yU3VwcG9ydC9lbnN1cmVUeXBlLmpzXCI7aW1wb3J0XCIuLi9jb3JlL2FycmF5VXRpbHMuanNcIjtpbXBvcnRcIi4uL2NvcmUvaGFzLmpzXCI7aW1wb3J0e3N1YmNsYXNzIGFzIHR9ZnJvbVwiLi4vY29yZS9hY2Nlc3NvclN1cHBvcnQvZGVjb3JhdG9ycy9zdWJjbGFzcy5qc1wiO2xldCBzPWNsYXNzIGV4dGVuZHMgcntjb25zdHJ1Y3RvcihvKXtzdXBlcihvKSx0aGlzLmFkbWluVG9rZW5TZXJ2aWNlVXJsPW51bGwsdGhpcy5jdXJyZW50VmVyc2lvbj1udWxsLHRoaXMuaGFzUG9ydGFsPW51bGwsdGhpcy5oYXNTZXJ2ZXI9bnVsbCx0aGlzLm93bmluZ1N5c3RlbVVybD1udWxsLHRoaXMub3duaW5nVGVuYW50PW51bGwsdGhpcy5zZXJ2ZXI9bnVsbCx0aGlzLnNob3J0TGl2ZWRUb2tlblZhbGlkaXR5PW51bGwsdGhpcy50b2tlblNlcnZpY2VVcmw9bnVsbCx0aGlzLndlYlRpZXJBdXRoPW51bGx9fTtvKFtlKHtqc29uOnt3cml0ZTohMH19KV0scy5wcm90b3R5cGUsXCJhZG1pblRva2VuU2VydmljZVVybFwiLHZvaWQgMCksbyhbZSh7anNvbjp7d3JpdGU6ITB9fSldLHMucHJvdG90eXBlLFwiY3VycmVudFZlcnNpb25cIix2b2lkIDApLG8oW2Uoe2pzb246e3dyaXRlOiEwfX0pXSxzLnByb3RvdHlwZSxcImhhc1BvcnRhbFwiLHZvaWQgMCksbyhbZSh7anNvbjp7d3JpdGU6ITB9fSldLHMucHJvdG90eXBlLFwiaGFzU2VydmVyXCIsdm9pZCAwKSxvKFtlKHtqc29uOnt3cml0ZTohMH19KV0scy5wcm90b3R5cGUsXCJvd25pbmdTeXN0ZW1VcmxcIix2b2lkIDApLG8oW2Uoe2pzb246e3dyaXRlOiEwfX0pXSxzLnByb3RvdHlwZSxcIm93bmluZ1RlbmFudFwiLHZvaWQgMCksbyhbZSh7anNvbjp7d3JpdGU6ITB9fSldLHMucHJvdG90eXBlLFwic2VydmVyXCIsdm9pZCAwKSxvKFtlKHtqc29uOnt3cml0ZTohMH19KV0scy5wcm90b3R5cGUsXCJzaG9ydExpdmVkVG9rZW5WYWxpZGl0eVwiLHZvaWQgMCksbyhbZSh7anNvbjp7d3JpdGU6ITB9fSldLHMucHJvdG90eXBlLFwidG9rZW5TZXJ2aWNlVXJsXCIsdm9pZCAwKSxvKFtlKHtqc29uOnt3cml0ZTohMH19KV0scy5wcm90b3R5cGUsXCJ3ZWJUaWVyQXV0aFwiLHZvaWQgMCkscz1vKFt0KFwiZXNyaS5pZGVudGl0eS5TZXJ2ZXJJbmZvXCIpXSxzKTtjb25zdCBpPXM7ZXhwb3J0e2kgYXMgZGVmYXVsdH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuY29uc3QgZT17aGFuZGxlSW50ZXJjZXB0ZWRFdmVudDooZSxwLHQsbik9PihlLnNjaGVkdWxlUmVuZGVyKCkscC5wcm9wZXJ0aWVzW2BvbiR7bi50eXBlfWBdLmFwcGx5KHAucHJvcGVydGllcy5iaW5kfHx0LFtuXSkpfTtleHBvcnR7ZSBhcyBkZWZhdWx0QWR2YW5jZWRQcm9qZWN0b3JPcHRpb25zfTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnR7ZG9tIGFzIGV9ZnJvbVwiLi4vbWFxdWV0dGUvZG9tLmpzXCI7aW1wb3J0XCIuLi9tYXF1ZXR0ZS9wcm9qZWN0b3IuanNcIjtpbXBvcnR7ZGVmYXVsdEFkdmFuY2VkUHJvamVjdG9yT3B0aW9ucyBhcyB0fWZyb21cIi4vYWR2YW5jZWQtcHJvamVjdG9yLW9wdGlvbnMuanNcIjtpbXBvcnR7YXBwbHlEZWZhdWx0UHJvamVjdGlvbk9wdGlvbnMgYXMgcn1mcm9tXCIuL3V0aWxzLmpzXCI7Y29uc3Qgbz0oZSx0KT0+e2NvbnN0IHI9W107Zm9yKDtlJiZlIT09dDspci5wdXNoKGUpLGU9ZS5wYXJlbnROb2RlO3JldHVybiByfSxuPShlLHQpPT5lLmZpbmQodCksZD0oZSx0LHI9ITEpPT57bGV0IG89ZTtyZXR1cm4gdC5mb3JFYWNoKCgoZSxkKT0+e2NvbnN0IHM9bz8uY2hpbGRyZW4/bihvLmNoaWxkcmVuLCh0PT50LmRvbU5vZGU9PT1lKSk6dm9pZCAwO3ImJiFzJiZkIT09dC5sZW5ndGgtMXx8KG89cyl9KSksb30scz1uPT57bGV0IHM7Y29uc3QgaT17Li4udCwuLi5ufSxjPXIoaSksYT1jLnBlcmZvcm1hbmNlTG9nZ2VyO2xldCBtLHA9ITAsbD0hMTtjb25zdCBmPVtdLHU9W10saD0oZSx0LHIpPT57bGV0IG47Yy5ldmVudEhhbmRsZXJJbnRlcmNlcHRvcj0oZSx0LHIsYyk9PmZ1bmN0aW9uKGUpe2xldCB0O2EoXCJkb21FdmVudFwiLGUpO2NvbnN0IHI9byhlLmN1cnJlbnRUYXJnZXQsbi5kb21Ob2RlKSxjPXIuc29tZSgoZT0+Y3VzdG9tRWxlbWVudHMuZ2V0KGU/LnRhZ05hbWU/LnRvTG93ZXJDYXNlKCkpKSk7aWYoZS5ldmVudFBoYXNlPT09RXZlbnQuQ0FQVFVSSU5HX1BIQVNFfHwhYylyLnJldmVyc2UoKSx0PWQobi5nZXRMYXN0UmVuZGVyKCkscik7ZWxzZXtjb25zdCByPWUuY29tcG9zZWRQYXRoKCksbz1yLnNsaWNlKHIuaW5kZXhPZihlLmN1cnJlbnRUYXJnZXQpLHIuaW5kZXhPZihuLmRvbU5vZGUpKS5maWx0ZXIoKGU9PmUuZ2V0Um9vdE5vZGUoKT09PWUub3duZXJEb2N1bWVudCkpLnJldmVyc2UoKTt0PWQobi5nZXRMYXN0UmVuZGVyKCksbywhMCl9bGV0IG07cmV0dXJuIHQmJihtPWkuaGFuZGxlSW50ZXJjZXB0ZWRFdmVudChzLHQsdGhpcyxlKSksYShcImRvbUV2ZW50UHJvY2Vzc2VkXCIsZSksbX0saS5wb3N0UHJvY2Vzc1Byb2plY3Rpb25PcHRpb25zPy4oYyk7Y29uc3QgbT1yKCk7bj1lKHQsbSxjKSxmLnB1c2gobiksdS5wdXNoKHIpLGkuYWZ0ZXJGaXJzdFZOb2RlUmVuZGVyZWQmJmkuYWZ0ZXJGaXJzdFZOb2RlUmVuZGVyZWQobixtKX07bGV0IHY9KCk9PntpZihtPXZvaWQgMCxwKXtwPSExLGEoXCJyZW5kZXJTdGFydFwiLHZvaWQgMCk7Zm9yKGxldCBlPTA7ZTxmLmxlbmd0aDtlKyspe2NvbnN0IHQ9dVtlXSgpO2EoXCJyZW5kZXJlZFwiLHZvaWQgMCksZltlXS51cGRhdGUodCksYShcInBhdGNoZWRcIix2b2lkIDApfWEoXCJyZW5kZXJEb25lXCIsdm9pZCAwKSxwPSEwfX07cmV0dXJuIGkubW9kaWZ5RG9SZW5kZXJJbXBsZW1lbnRhdGlvbiYmKHY9aS5tb2RpZnlEb1JlbmRlckltcGxlbWVudGF0aW9uKHYsZix1KSkscz17cmVuZGVyTm93OnYsc2NoZWR1bGVSZW5kZXI6KCk9PnttfHxsfHwobT1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodikpfSxzdG9wOigpPT57bSYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKG0pLG09dm9pZCAwKSxsPSEwfSxyZXN1bWU6KCk9PntsPSExLHA9ITAscy5zY2hlZHVsZVJlbmRlcigpfSxhcHBlbmQ6KHQscik9PntoKGUuYXBwZW5kLHQscil9LGluc2VydEJlZm9yZToodCxyKT0+e2goZS5pbnNlcnRCZWZvcmUsdCxyKX0sbWVyZ2U6KHQscik9PntoKGUubWVyZ2UsdCxyKX0scmVwbGFjZToodCxyKT0+e2goZS5yZXBsYWNlLHQscil9LGRldGFjaDplPT57Zm9yKGxldCB0PTA7dDx1Lmxlbmd0aDt0KyspaWYodVt0XT09PWUpcmV0dXJuIHUuc3BsaWNlKHQsMSksZi5zcGxpY2UodCwxKVswXTt0aHJvdyBuZXcgRXJyb3IoXCJyZW5kZXJGdW5jdGlvbiB3YXMgbm90IGZvdW5kXCIpfX0sc307ZXhwb3J0e3MgYXMgY3JlYXRlQWR2YW5jZWRQcm9qZWN0b3J9O1xuIiwiLypcbkFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG5TZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMjcvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxuKi9cbmNvbnN0IGU9e25hbWVzcGFjZTp2b2lkIDAscGVyZm9ybWFuY2VMb2dnZXI6KCk9Pnt9LGV2ZW50SGFuZGxlckludGVyY2VwdG9yOnZvaWQgMCxzdHlsZUFwcGx5ZXI6KGUscixvKT0+e2Uuc3R5bGVbcl09b319LHI9cj0+KHsuLi5lLC4uLnJ9KTtleHBvcnR7ciBhcyBhcHBseURlZmF1bHRQcm9qZWN0aW9uT3B0aW9uc307XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e2V4dGVuZCBhcyBlLGNyZWF0ZURvbSBhcyByLGNyZWF0ZVByb2plY3Rpb24gYXMgbyxpbml0UHJvcGVydGllc0FuZENoaWxkcmVuIGFzIHR9ZnJvbVwiLi9wcm9qZWN0aW9uLmpzXCI7Y29uc3QgcD17bmFtZXNwYWNlOnZvaWQgMCxwZXJmb3JtYW5jZUxvZ2dlcjooKT0+e30sZXZlbnRIYW5kbGVySW50ZXJjZXB0b3I6dm9pZCAwLHN0eWxlQXBwbHllcjooZSxyLG8pPT57XCItXCI9PT1yLmNoYXJBdCgwKT9lLnN0eWxlLnNldFByb3BlcnR5KHIsbyk6ZS5zdHlsZVtyXT1vfX07bGV0IGQ9cj0+ZShwLHIpLG49e2NyZWF0ZTooZSx0KT0+KHQ9ZCh0KSxyKGUsZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx2b2lkIDAsdCksbyhlLHQpKSxhcHBlbmQ6KGUsdCxwKT0+KHA9ZChwKSxyKHQsZSx2b2lkIDAscCksbyh0LHApKSxpbnNlcnRCZWZvcmU6KGUsdCxwKT0+KHA9ZChwKSxyKHQsZS5wYXJlbnROb2RlLGUscCksbyh0LHApKSxtZXJnZTooZSxyLHApPT4ocD1kKHApLHIuZG9tTm9kZT1lLHQoZSxyLHApLG8ocixwKSkscmVwbGFjZTooZSx0LHApPT4ocD1kKHApLHIodCxlLnBhcmVudE5vZGUsZSxwKSxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSksbyh0LHApKX07ZXhwb3J0e2QgYXMgYXBwbHlEZWZhdWx0UHJvamVjdGlvbk9wdGlvbnMsbiBhcyBkb219O1xuIiwiLypcbkFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG5TZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMjcvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxuKi9cbmltcG9ydHtyZW5kZXJpbmdTYW5pdGl6ZXIgYXMgZX1mcm9tXCIuLi8uLi93aWRnZXRzL3N1cHBvcnQvd2lkZ2V0VXRpbHMuanNcIjtjb25zdCB0PVwiaHR0cDovL3d3dy53My5vcmcvXCIscj1gJHt0fTIwMDAvc3ZnYCxvPWAke3R9MTk5OS94bGlua2A7bGV0IGk9W10sbj0oZSx0KT0+e2xldCByPXt9O3JldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKCh0PT57clt0XT1lW3RdfSkpLHQmJk9iamVjdC5rZXlzKHQpLmZvckVhY2goKGU9PntyW2VdPXRbZV19KSkscn0scz0oZSx0KT0+ZS52bm9kZVNlbGVjdG9yPT09dC52bm9kZVNlbGVjdG9yJiYoZS5wcm9wZXJ0aWVzJiZ0LnByb3BlcnRpZXM/ZS5wcm9wZXJ0aWVzLmtleT09PXQucHJvcGVydGllcy5rZXkmJmUucHJvcGVydGllcy5iaW5kPT09dC5wcm9wZXJ0aWVzLmJpbmQ6IWUucHJvcGVydGllcyYmIXQucHJvcGVydGllcyksbD1lPT57aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiU3R5bGUgdmFsdWVzIG11c3QgYmUgc3RyaW5nc1wiKX0scD0oZSx0LHIpPT57aWYoXCJcIiE9PXQudm5vZGVTZWxlY3Rvcilmb3IobGV0IG89cjtvPGUubGVuZ3RoO28rKylpZihzKGVbb10sdCkpcmV0dXJuIG87cmV0dXJuLTF9LGQ9KGUsdCxyLG8pPT57bGV0IGk9ZVt0XTtpZihcIlwiPT09aS52bm9kZVNlbGVjdG9yKXJldHVybjtsZXQgbj1pLnByb3BlcnRpZXM7aWYoIShuP3ZvaWQgMD09PW4ua2V5P24uYmluZDpuLmtleTp2b2lkIDApKWZvcihsZXQgbD0wO2w8ZS5sZW5ndGg7bCsrKWlmKGwhPT10KXtsZXQgdD1lW2xdO2lmKHModCxpKSl0aHJvdyBuZXcgRXJyb3IoYCR7ci52bm9kZVNlbGVjdG9yfSBoYWQgYSAke2kudm5vZGVTZWxlY3Rvcn0gY2hpbGQgJHtcImFkZGVkXCI9PT1vP286XCJyZW1vdmVkXCJ9LCBidXQgdGhlcmUgaXMgbm93IG1vcmUgdGhhbiBvbmUuIFlvdSBtdXN0IGFkZCB1bmlxdWUga2V5IHByb3BlcnRpZXMgdG8gbWFrZSB0aGVtIGRpc3Rpbmd1aXNoYWJsZS5gKX19LGE9ZT0+e2lmKGUucHJvcGVydGllcyl7bGV0IHQ9ZS5wcm9wZXJ0aWVzLmVudGVyQW5pbWF0aW9uO3QmJnQoZS5kb21Ob2RlLGUucHJvcGVydGllcyl9fSxmPVtdLGM9ITEsdT1lPT57KGUuY2hpbGRyZW58fFtdKS5mb3JFYWNoKHUpLGUucHJvcGVydGllcyYmZS5wcm9wZXJ0aWVzLmFmdGVyUmVtb3ZlZCYmZS5wcm9wZXJ0aWVzLmFmdGVyUmVtb3ZlZC5hcHBseShlLnByb3BlcnRpZXMuYmluZHx8ZS5wcm9wZXJ0aWVzLFtlLmRvbU5vZGVdKX0sbT0oKT0+e2M9ITEsZi5mb3JFYWNoKHUpLGYubGVuZ3RoPTB9LGg9ZT0+e2YucHVzaChlKSxjfHwoYz0hMCxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZcInJlcXVlc3RJZGxlQ2FsbGJhY2tcImluIHdpbmRvdz93aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayhtLHt0aW1lb3V0OjE2fSk6c2V0VGltZW91dChtLDE2KSl9LHY9ZT0+e2xldCB0PWUuZG9tTm9kZTtpZihlLnByb3BlcnRpZXMpe2xldCByPWUucHJvcGVydGllcy5leGl0QW5pbWF0aW9uO2lmKHIpe3Quc3R5bGUucG9pbnRlckV2ZW50cz1cIm5vbmVcIjtsZXQgbz0oKT0+e3QucGFyZW50Tm9kZSYmKHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSxoKGUpKX07cmV0dXJuIHZvaWQgcih0LG8sZS5wcm9wZXJ0aWVzKX19dC5wYXJlbnROb2RlJiYodC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpLGgoZSkpfSx5PSh0LGksbik9PntpZighaSlyZXR1cm47bGV0IHM9bi5ldmVudEhhbmRsZXJJbnRlcmNlcHRvcixwPU9iamVjdC5rZXlzKGkpLGQ9cC5sZW5ndGg7Zm9yKGxldCBhPTA7YTxkO2ErKyl7bGV0IGQ9cFthXSxmPWlbZF07aWYoXCJjbGFzc05hbWVcIj09PWQpdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcImNsYXNzTmFtZVwiIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSBcImNsYXNzXCIuJyk7aWYoXCJjbGFzc1wiPT09ZClrKHQsZiwhMCk7ZWxzZSBpZihcImNsYXNzZXNcIj09PWQpe2xldCBlPU9iamVjdC5rZXlzKGYpLHI9ZS5sZW5ndGg7Zm9yKGxldCBvPTA7bzxyO28rKyl7bGV0IHI9ZVtvXTtmW3JdJiZ0LmNsYXNzTGlzdC5hZGQocil9fWVsc2UgaWYoXCJzdHlsZXNcIj09PWQpe2xldCBlPU9iamVjdC5rZXlzKGYpLHI9ZS5sZW5ndGg7Zm9yKGxldCBvPTA7bzxyO28rKyl7bGV0IHI9ZVtvXSxpPWZbcl07aSYmKGwoaSksbi5zdHlsZUFwcGx5ZXIodCxyLGkpKX19ZWxzZSBpZihcImtleVwiIT09ZCYmbnVsbCE9Zil7bGV0IGw9dHlwZW9mIGY7XCJmdW5jdGlvblwiPT09bD8oMD09PWQubGFzdEluZGV4T2YoXCJvblwiLDApJiYocyYmKGY9cyhkLGYsdCxpKSksXCJvbmlucHV0XCI9PT1kJiZmdW5jdGlvbigpe2xldCBlPWY7Zj1mdW5jdGlvbih0KXtlLmFwcGx5KHRoaXMsW3RdKSx0LnRhcmdldFtcIm9uaW5wdXQtdmFsdWVcIl09dC50YXJnZXQudmFsdWV9fSgpKSx0W2RdPWYpOm4ubmFtZXNwYWNlPT09cj9cImhyZWZcIj09PWQ/dC5zZXRBdHRyaWJ1dGVOUyhvLGQsZik6dC5zZXRBdHRyaWJ1dGUoZCxmKTpcInN0cmluZ1wiPT09bCYmXCJ2YWx1ZVwiIT09ZD9cImlubmVySFRNTFwiPT09ZD90W2RdPWUuc2FuaXRpemUoZik6Zyh0KSYmZCBpbiB0P3RbZF09Zjp0LnNldEF0dHJpYnV0ZShkLGYpOnRbZF09Zn19fTtmdW5jdGlvbiBnKGUpe2lmKCEoZSBpbnN0YW5jZW9mIEVsZW1lbnQmJmUudGFnTmFtZS5pbmNsdWRlcyhcIi1cIikpKXJldHVybiExO2NvbnN0IHQ9d2luZG93LmN1c3RvbUVsZW1lbnRzLmdldChlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7cmV0dXJuISF0JiZlIGluc3RhbmNlb2YgdH1sZXQgTixiPShlLHQscik9PntpZih0KWZvcihsZXQgbyBvZiB0KXgobyxlLHZvaWQgMCxyKX0sdz0oZSx0LHIpPT57YihlLHQuY2hpbGRyZW4sciksdC50ZXh0JiYoZS50ZXh0Q29udGVudD10LnRleHQpLHkoZSx0LnByb3BlcnRpZXMsciksdC5wcm9wZXJ0aWVzJiZ0LnByb3BlcnRpZXMuYWZ0ZXJDcmVhdGUmJnQucHJvcGVydGllcy5hZnRlckNyZWF0ZS5hcHBseSh0LnByb3BlcnRpZXMuYmluZHx8dC5wcm9wZXJ0aWVzLFtlLHIsdC52bm9kZVNlbGVjdG9yLHQucHJvcGVydGllcyx0LmNoaWxkcmVuXSl9LHg9KGUsdCxvLGkpPT57bGV0IHMsbD0wLHA9ZS52bm9kZVNlbGVjdG9yLGQ9dC5vd25lckRvY3VtZW50O2lmKFwiXCI9PT1wKXM9ZS5kb21Ob2RlPWQuY3JlYXRlVGV4dE5vZGUoZS50ZXh0KSx2b2lkIDAhPT1vP3QuaW5zZXJ0QmVmb3JlKHMsbyk6dC5hcHBlbmRDaGlsZChzKTtlbHNle2ZvcihsZXQgYT0wO2E8PXAubGVuZ3RoOysrYSl7bGV0IGY9cC5jaGFyQXQoYSk7aWYoYT09PXAubGVuZ3RofHxcIi5cIj09PWZ8fFwiI1wiPT09Zil7bGV0IGY9cC5jaGFyQXQobC0xKSxjPXAuc2xpY2UobCxhKTtcIi5cIj09PWY/cy5jbGFzc0xpc3QuYWRkKGMpOlwiI1wiPT09Zj9zLmlkPWM6KFwic3ZnXCI9PT1jJiYoaT1uKGkse25hbWVzcGFjZTpyfSkpLHZvaWQgMCE9PWkubmFtZXNwYWNlP3M9ZS5kb21Ob2RlPWQuY3JlYXRlRWxlbWVudE5TKGkubmFtZXNwYWNlLGMpOihzPWUuZG9tTm9kZT1lLmRvbU5vZGV8fGQuY3JlYXRlRWxlbWVudChjKSxcImlucHV0XCI9PT1jJiZlLnByb3BlcnRpZXMmJnZvaWQgMCE9PWUucHJvcGVydGllcy50eXBlJiZzLnNldEF0dHJpYnV0ZShcInR5cGVcIixlLnByb3BlcnRpZXMudHlwZSkpLHZvaWQgMCE9PW8/dC5pbnNlcnRCZWZvcmUocyxvKTpzLnBhcmVudE5vZGUhPT10JiZ0LmFwcGVuZENoaWxkKHMpKSxsPWErMX19dyhzLGUsaSl9fSxrPShlLHQscik9Pnt0JiZ0LnNwbGl0KFwiIFwiKS5mb3JFYWNoKCh0PT57dCYmZS5jbGFzc0xpc3QudG9nZ2xlKHQscil9KSl9LEE9KHQsaSxuLHMpPT57aWYoIW4pcmV0dXJuO2xldCBwPSExLGQ9T2JqZWN0LmtleXMobiksYT1kLmxlbmd0aDtmb3IobGV0IGY9MDtmPGE7ZisrKXtsZXQgYT1kW2ZdLGM9blthXSx1PWlbYV07aWYoXCJjbGFzc1wiPT09YSl1IT09YyYmKGsodCx1LCExKSxrKHQsYywhMCkpO2Vsc2UgaWYoXCJjbGFzc2VzXCI9PT1hKXtsZXQgZT10LmNsYXNzTGlzdCxyPU9iamVjdC5rZXlzKGMpLG89ci5sZW5ndGg7Zm9yKGxldCB0PTA7dDxvO3QrKyl7bGV0IG89clt0XSxpPSEhY1tvXTtpIT09ISF1W29dJiYocD0hMCxpP2UuYWRkKG8pOmUucmVtb3ZlKG8pKX19ZWxzZSBpZihcInN0eWxlc1wiPT09YSl7bGV0IGU9T2JqZWN0LmtleXMoYykscj1lLmxlbmd0aDtmb3IobGV0IG89MDtvPHI7bysrKXtsZXQgcj1lW29dLGk9Y1tyXTtpIT09dVtyXSYmKHA9ITAsaT8obChpKSxzLnN0eWxlQXBwbHllcih0LHIsaSkpOnMuc3R5bGVBcHBseWVyKHQscixcIlwiKSl9fWVsc2UgaWYoY3x8XCJzdHJpbmdcIiE9dHlwZW9mIHV8fChjPVwiXCIpLFwidmFsdWVcIj09PWEpe2xldCBlPXRbYV07ZSE9PWMmJih0W1wib25pbnB1dC12YWx1ZVwiXT9lPT09dFtcIm9uaW5wdXQtdmFsdWVcIl06YyE9PXUpJiYodFthXT1jLHRbXCJvbmlucHV0LXZhbHVlXCJdPXZvaWQgMCksYyE9PXUmJihwPSEwKX1lbHNlIGlmKGMhPT11KXtsZXQgaT10eXBlb2YgYztcImZ1bmN0aW9uXCI9PT1pJiZzLmV2ZW50SGFuZGxlckludGVyY2VwdG9yfHwocy5uYW1lc3BhY2U9PT1yP1wiaHJlZlwiPT09YT90LnNldEF0dHJpYnV0ZU5TKG8sYSxjKTp0LnNldEF0dHJpYnV0ZShhLGMpOlwic3RyaW5nXCI9PT1pP1wiaW5uZXJIVE1MXCI9PT1hP3RbYV09ZS5zYW5pdGl6ZShjKTpcInJvbGVcIj09PWEmJlwiXCI9PT1jP3QucmVtb3ZlQXR0cmlidXRlKGEpOmcodCkmJmEgaW4gdD90W2FdPWM6dC5zZXRBdHRyaWJ1dGUoYSxjKTp0W2FdIT09YyYmKHRbYV09YykscD0hMCl9fXJldHVybiBwfSxTPShlLHQscixvLG4pPT57aWYocj09PW8pcmV0dXJuITE7bz1vfHxpO2xldCBsLGY9KHI9cnx8aSkubGVuZ3RoLGM9by5sZW5ndGgsdT0wLG09MCxoPSExO2Zvcig7bTxjOyl7bGV0IGk9dTxmP3JbdV06dm9pZCAwLGM9b1ttXTtpZih2b2lkIDAhPT1pJiZzKGksYykpaD1OKGksYyxuKXx8aCx1Kys7ZWxzZXtsZXQgaT1wKHIsYyx1KzEpO2lmKGk+PTApe2ZvcihsPXU7bDxpO2wrKyl2KHJbbF0pLGQocixsLGUsXCJyZW1vdmVkXCIpO2g9TihyW2ldLGMsbil8fGgsdT1pKzF9ZWxzZSB4KGMsdCx1PGY/clt1XS5kb21Ob2RlOnZvaWQgMCxuKSxhKGMpLGQobyxtLGUsXCJhZGRlZFwiKX1tKyt9aWYoZj51KWZvcihsPXU7bDxmO2wrKyl2KHJbbF0pLGQocixsLGUsXCJyZW1vdmVkXCIpO3JldHVybiBofTtOPShlLHQsbyk9PntsZXQgaT1lLmRvbU5vZGUscz0hMTtpZihlPT09dClyZXR1cm4hMTtsZXQgbD0hMTtpZihcIlwiPT09dC52bm9kZVNlbGVjdG9yKXtpZih0LnRleHQhPT1lLnRleHQpe2xldCBlPWkub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0LnRleHQpO3JldHVybiBpLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGUsaSksdC5kb21Ob2RlPWUscz0hMCxzfXQuZG9tTm9kZT1pfWVsc2UgMD09PXQudm5vZGVTZWxlY3Rvci5sYXN0SW5kZXhPZihcInN2Z1wiLDApJiYobz1uKG8se25hbWVzcGFjZTpyfSkpLGUudGV4dCE9PXQudGV4dCYmKGw9ITAsdm9pZCAwPT09dC50ZXh0P2kucmVtb3ZlQ2hpbGQoaS5maXJzdENoaWxkKTppLnRleHRDb250ZW50PXQudGV4dCksdC5kb21Ob2RlPWksbD1TKHQsaSxlLmNoaWxkcmVuLHQuY2hpbGRyZW4sbyl8fGwsbD1BKGksZS5wcm9wZXJ0aWVzLHQucHJvcGVydGllcyxvKXx8bCx0LnByb3BlcnRpZXMmJnQucHJvcGVydGllcy5hZnRlclVwZGF0ZSYmdC5wcm9wZXJ0aWVzLmFmdGVyVXBkYXRlLmFwcGx5KHQucHJvcGVydGllcy5iaW5kfHx0LnByb3BlcnRpZXMsW2ksbyx0LnZub2RlU2VsZWN0b3IsdC5wcm9wZXJ0aWVzLHQuY2hpbGRyZW5dKTtyZXR1cm4gbCYmdC5wcm9wZXJ0aWVzJiZ0LnByb3BlcnRpZXMudXBkYXRlQW5pbWF0aW9uJiZ0LnByb3BlcnRpZXMudXBkYXRlQW5pbWF0aW9uKGksdC5wcm9wZXJ0aWVzLGUucHJvcGVydGllcyksc307bGV0IEM9KGUsdCk9Pih7Z2V0TGFzdFJlbmRlcjooKT0+ZSx1cGRhdGU6cj0+e2lmKGUudm5vZGVTZWxlY3RvciE9PXIudm5vZGVTZWxlY3Rvcil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2VsZWN0b3IgZm9yIHRoZSByb290IFZOb2RlIG1heSBub3QgYmUgY2hhbmdlZC4gKGNvbnNpZGVyIHVzaW5nIGRvbS5tZXJnZSBhbmQgYWRkIG9uZSBleHRyYSBsZXZlbCB0byB0aGUgdmlydHVhbCBET00pXCIpO2xldCBvPWU7ZT1yLE4obyxyLHQpfSxkb21Ob2RlOmUuZG9tTm9kZX0pO2V4cG9ydHt4IGFzIGNyZWF0ZURvbSxDIGFzIGNyZWF0ZVByb2plY3Rpb24sbiBhcyBleHRlbmQsdyBhcyBpbml0UHJvcGVydGllc0FuZENoaWxkcmVufTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnR7YXBwbHlEZWZhdWx0UHJvamVjdGlvbk9wdGlvbnMgYXMgZSxkb20gYXMgcn1mcm9tXCIuL2RvbS5qc1wiO2xldCB0LG49KGUscik9PntsZXQgdD1bXTtmb3IoO2UmJmUhPT1yOyl0LnB1c2goZSksZT1lLnBhcmVudE5vZGU7cmV0dXJuIHR9O3Q9QXJyYXkucHJvdG90eXBlLmZpbmQ/KGUscik9PmUuZmluZChyKTooZSxyKT0+ZS5maWx0ZXIocilbMF07bGV0IG89KGUscik9PntsZXQgbj1lO3JldHVybiByLmZvckVhY2goKGU9PntuPW4mJm4uY2hpbGRyZW4/dChuLmNoaWxkcmVuLChyPT5yLmRvbU5vZGU9PT1lKSk6dm9pZCAwfSkpLG59LGQ9KGUscix0KT0+e2xldCBkPWZ1bmN0aW9uKGQpe3QoXCJkb21FdmVudFwiLGQpO2xldCBpPXIoKSxwPW4oZC5jdXJyZW50VGFyZ2V0LGkuZG9tTm9kZSk7cC5yZXZlcnNlKCk7bGV0IGwsYT1vKGkuZ2V0TGFzdFJlbmRlcigpLHApO3JldHVybiBlLnNjaGVkdWxlUmVuZGVyKCksYSYmKGw9YS5wcm9wZXJ0aWVzW2BvbiR7ZC50eXBlfWBdLmFwcGx5KGEucHJvcGVydGllcy5iaW5kfHx0aGlzLGFyZ3VtZW50cykpLHQoXCJkb21FdmVudFByb2Nlc3NlZFwiLGQpLGx9O3JldHVybihlLHIsdCxuKT0+ZH0saT10PT57bGV0IG4sbyxpPWUodCkscD1pLnBlcmZvcm1hbmNlTG9nZ2VyLGw9ITAsYT0hMSxzPVtdLGM9W10sdT0oZSxyLHQpPT57bGV0IG8sbD0oKT0+bztpLmV2ZW50SGFuZGxlckludGVyY2VwdG9yPWQobixsLHApLG89ZShyLHQoKSxpKSxzLnB1c2gobyksYy5wdXNoKHQpfSxmPSgpPT57aWYobz12b2lkIDAsbCl7bD0hMSxwKFwicmVuZGVyU3RhcnRcIix2b2lkIDApO2ZvcihsZXQgZT0wO2U8cy5sZW5ndGg7ZSsrKXtsZXQgcj1jW2VdKCk7cChcInJlbmRlcmVkXCIsdm9pZCAwKSxzW2VdLnVwZGF0ZShyKSxwKFwicGF0Y2hlZFwiLHZvaWQgMCl9cChcInJlbmRlckRvbmVcIix2b2lkIDApLGw9ITB9fTtyZXR1cm4gbj17cmVuZGVyTm93OmYsc2NoZWR1bGVSZW5kZXI6KCk9PntvfHxhfHwobz1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZikpfSxzdG9wOigpPT57byYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKG8pLG89dm9pZCAwKSxhPSEwfSxyZXN1bWU6KCk9PnthPSExLGw9ITAsbi5zY2hlZHVsZVJlbmRlcigpfSxhcHBlbmQ6KGUsdCk9Pnt1KHIuYXBwZW5kLGUsdCl9LGluc2VydEJlZm9yZTooZSx0KT0+e3Uoci5pbnNlcnRCZWZvcmUsZSx0KX0sbWVyZ2U6KGUsdCk9Pnt1KHIubWVyZ2UsZSx0KX0scmVwbGFjZTooZSx0KT0+e3Uoci5yZXBsYWNlLGUsdCl9LGRldGFjaDplPT57Zm9yKGxldCByPTA7cjxjLmxlbmd0aDtyKyspaWYoY1tyXT09PWUpcmV0dXJuIGMuc3BsaWNlKHIsMSkscy5zcGxpY2UociwxKVswXTt0aHJvdyBuZXcgRXJyb3IoXCJyZW5kZXJGdW5jdGlvbiB3YXMgbm90IGZvdW5kXCIpfX0sbn07ZXhwb3J0e2kgYXMgY3JlYXRlUHJvamVjdG9yfTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5jb25zdCB0PVwiY2FsY2l0ZS1tb2RlLVwiO2Z1bmN0aW9uIGUoKXtyZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1lc3JpLWNhbGNpdGUtbW9kZS1uYW1lXCIpLnJlcGxhY2VBbGwoL1xcc3wnfFwiL2csXCJcIil9ZnVuY3Rpb24gcigpe3JldHVybiBlKCkuc3RhcnRzV2l0aChcImRhcmtcIil9ZnVuY3Rpb24gYygpe3JldHVybmAke3R9JHtyKCk/XCJkYXJrXCI6XCJsaWdodFwifWB9ZnVuY3Rpb24gbih0KXtvKHQpLHQuY2xhc3NMaXN0LmFkZChjKCkpfWZ1bmN0aW9uIG8oZSl7QXJyYXkuZnJvbShlLmNsYXNzTGlzdCkuZm9yRWFjaCgocj0+e3Iuc3RhcnRzV2l0aCh0KSYmZS5jbGFzc0xpc3QucmVtb3ZlKHIpfSkpfWV4cG9ydHtjIGFzIGdldENhbGNpdGVUaGVtZUNsYXNzLHIgYXMgaXNEYXJrVGhlbWUsbiBhcyBzZXRDYWxjaXRlVGhlbWVDbGFzc307XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e18gYXMgZX1mcm9tXCIuLi9jaHVua3MvdHNsaWIuZXM2LmpzXCI7aW1wb3J0XCIuLi9pbnRsLmpzXCI7aW1wb3J0e2J5SWQgYXMgdH1mcm9tXCIuLi9jb3JlL2RvbVV0aWxzLmpzXCI7aW1wb3J0IHIgZnJvbVwiLi4vY29yZS9FdmVudGVkLmpzXCI7aW1wb3J0e2lzRXZlbnRUYXJnZXQgYXMgcyxvbiBhcyBvfWZyb21cIi4uL2NvcmUvZXZlbnRzLmpzXCI7aW1wb3J0IGkgZnJvbVwiLi4vY29yZS9IYW5kbGVzLmpzXCI7aW1wb3J0XCIuLi9jb3JlL2hhcy5qc1wiO2ltcG9ydHtjbG9uZSBhcyBufWZyb21cIi4uL2NvcmUvbGFuZy5qc1wiO2ltcG9ydCBhIGZyb21cIi4uL2NvcmUvTG9nZ2VyLmpzXCI7aW1wb3J0e2Rlc3Ryb3lNYXliZSBhcyBjfWZyb21cIi4uL2NvcmUvbWF5YmUuanNcIjtpbXBvcnR7RXNyaVByb21pc2VNaXhpbiBhcyBsfWZyb21cIi4uL2NvcmUvUHJvbWlzZS5qc1wiO2ltcG9ydHtkZWJvdW5jZSBhcyBkLHRocm93SWZOb3RBYm9ydEVycm9yIGFzIHAsZWFjaEFsd2F5cyBhcyBofWZyb21cIi4uL2NvcmUvcHJvbWlzZVV0aWxzLmpzXCI7aW1wb3J0e3dhdGNoIGFzIG0sd2hlbiBhcyB1LGluaXRpYWwgYXMgeX1mcm9tXCIuLi9jb3JlL3JlYWN0aXZlVXRpbHMuanNcIjtpbXBvcnR7Z2VuZXJhdGVVVUlEIGFzIGd9ZnJvbVwiLi4vY29yZS91dWlkLmpzXCI7aW1wb3J0e3Byb3BlcnR5IGFzIF99ZnJvbVwiLi4vY29yZS9hY2Nlc3NvclN1cHBvcnQvZGVjb3JhdG9ycy9wcm9wZXJ0eS5qc1wiO2ltcG9ydHtjYXN0IGFzIGZ9ZnJvbVwiLi4vY29yZS9hY2Nlc3NvclN1cHBvcnQvZGVjb3JhdG9ycy9jYXN0LmpzXCI7aW1wb3J0e3N1YmNsYXNzIGFzIHZ9ZnJvbVwiLi4vY29yZS9hY2Nlc3NvclN1cHBvcnQvZGVjb3JhdG9ycy9zdWJjbGFzcy5qc1wiO2ltcG9ydHtydW5UcmFja2VkIGFzIGp9ZnJvbVwiLi4vY29yZS9hY2Nlc3NvclN1cHBvcnQvdHJhY2tpbmcuanNcIjtpbXBvcnR7U2ltcGxlVHJhY2tpbmdUYXJnZXQgYXMgYn1mcm9tXCIuLi9jb3JlL2FjY2Vzc29yU3VwcG9ydC90cmFja2luZy9TaW1wbGVUcmFja2luZ1RhcmdldC5qc1wiO2ltcG9ydHtjcmVhdGVBZHZhbmNlZFByb2plY3RvciBhcyB3fWZyb21cIi4uL2xpYnMvbWFxdWV0dGUtYWR2YW5jZWQtcHJvamVjdG9yL3Byb2plY3Rvci5qc1wiO2ltcG9ydHtjb21taXRBc3NldFBhdGggYXMga31mcm9tXCIuL3N1cHBvcnQvY29tcG9uZW50c1V0aWxzLmpzXCI7aW1wb3J0e2lzV2lkZ2V0Q29uc3RydWN0b3IgYXMgUixwcm9jZXNzV2lkZ2V0cyBhcyBTfWZyb21cIi4vc3VwcG9ydC9qc3hXaWRnZXRTdXBwb3J0LmpzXCI7aW1wb3J0e1dJREdFVF9URVNUX0RBVEFfU1lNQk9MIGFzIEMsV0lER0VUX1NZTUJPTCBhcyBQfWZyb21cIi4vc3VwcG9ydC9zeW1ib2xzLmpzXCI7aW1wb3J0e3JlZ2lzdGVyTG9hZGluZyBhcyBFfWZyb21cIi4vc3VwcG9ydC90ZXN0cy5qc1wiO2ltcG9ydHtnZXRWTm9kZUNhY2hlIGFzIEksc2V0Vk5vZGVDYWNoZSBhcyBMLGRlbGV0ZVZOb2RlQ2FjaGUgYXMgVCxjbGVhclZOb2RlQ2FjaGUgYXMgSH1mcm9tXCIuL3N1cHBvcnQvdm5vZGVDYWNoZS5qc1wiO2ltcG9ydHtjbGFzc2VzIGFzIEZ9ZnJvbVwiLi9zdXBwb3J0L3dpZGdldFV0aWxzLmpzXCI7aW1wb3J0e29uTG9jYWxlQ2hhbmdlIGFzIE59ZnJvbVwiLi4vaW50bC9sb2NhbGUuanNcIjtpbXBvcnR7ZmV0Y2hNZXNzYWdlQnVuZGxlIGFzIFV9ZnJvbVwiLi4vaW50bC9tZXNzYWdlcy5qc1wiO3ZhciAkO2NvbnN0IHo9XCJlc3JpLndpZGdldHMuV2lkZ2V0XCI7bGV0IHg9MDtjb25zdCBBPXt3aWRnZXRJY29uOlwiZXNyaS1pY29uLWNoZWNrYm94LXVuY2hlY2tlZFwifTtmdW5jdGlvbiBCKGUsdCl7Zm9yKGNvbnN0IHIgaW4gdCludWxsIT1lW3JdJiYoXCJvYmplY3RcIj09dHlwZW9mIGVbcl0mJlwib2JqZWN0XCI9PXR5cGVvZiB0W3JdP0IoZVtyXSx0Py5bcl0pOmVbcl09dFtyXSk7cmV0dXJuIGV9Y29uc3QgRD13KHtwb3N0UHJvY2Vzc1Byb2plY3Rpb25PcHRpb25zKGUpe2NvbnN0IHQ9ZS5ldmVudEhhbmRsZXJJbnRlcmNlcHRvcixyPS9jYXB0dXJlJC9pO2UuZXZlbnRIYW5kbGVySW50ZXJjZXB0b3I9KGUscyxvLGkpPT57Y29uc3Qgbj10Py4oZSxzLG8saSksYT1yLnRlc3QoZSk7aWYoISgoZT1lLnJlcGxhY2UocixcIlwiKSkudG9Mb3dlckNhc2UoKWluIG8pfHxhKXtjb25zdCB0PWVbMl0udG9Mb3dlckNhc2UoKStlLnNsaWNlKDMpLHI9ZT0+bj8uY2FsbChvLGUpO28uYWRkRXZlbnRMaXN0ZW5lcih0LHIsYSk7Y29uc3Qgcz0oKT0+by5yZW1vdmVFdmVudExpc3RlbmVyKHQscixhKSxjPWkuYWZ0ZXJSZW1vdmVkO2kuYWZ0ZXJSZW1vdmVkPWU9PntjPy4oZSkscygpfX1yZXR1cm4gbn19LGhhbmRsZUludGVyY2VwdGVkRXZlbnQoZSx0LHIscyl7Y29uc3R7ZXZlbnRQaGFzZTpvLHR5cGU6aX09cyxuPW89PT1FdmVudC5DQVBUVVJJTkdfUEhBU0U7bGV0IGE9YG9uJHtpfSR7bj9cImNhcHR1cmVcIjpcIlwifWA7Y29uc3QgYz10LnByb3BlcnRpZXM7KGMmJmEgaW4gY3x8KGE9YG9uJHtpWzBdLnRvVXBwZXJDYXNlKCl9JHtpLnNsaWNlKDEpfSR7bj9cIkNhcHR1cmVcIjpcIlwifWAsYyYmYSBpbiBjKSkmJihIKCksZS5zY2hlZHVsZVJlbmRlcigpLGNbYV0uY2FsbChjLmJpbmR8fHIscykpfX0pO2xldCBNPSExLE89Y2xhc3MgZXh0ZW5kcyhsKHIuRXZlbnRlZEFjY2Vzc29yKSl7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlLHQpLHRoaXMuX2F0dGFjaGVkPSExLHRoaXMuX2ludGVybmFsSGFuZGxlcz1uZXcgaSx0aGlzLl9wcm9qZWN0b3I9RCx0aGlzLl9yZWFkeUZvclRydWVSZW5kZXI9ITEsdGhpcy5pY29uQ2xhc3M9QS53aWRnZXRJY29uLHRoaXMuaWNvbj1udWxsLHRoaXMua2V5PXRoaXMsdGhpcy5fbG9hZExvY2FsZT1kKChhc3luYygpPT57aWYodGhpcy5fbWVzc2FnZUJ1bmRsZVByb3BzJiZ0aGlzLl9tZXNzYWdlQnVuZGxlUHJvcHMubGVuZ3RoKXtjb25zdCBlPWF3YWl0IGgodGhpcy5fbWVzc2FnZUJ1bmRsZVByb3BzLm1hcCgoYXN5bmMoe2J1bmRsZVBhdGg6ZSxwcm9wZXJ0eU5hbWU6dH0pPT57aWYodGhpcy5kZXN0cm95ZWQpcmV0dXJuO2xldCByPWF3YWl0IFUoZSk7dGhpcy51aVN0cmluZ3MmJk9iamVjdC5rZXlzKHRoaXMudWlTdHJpbmdzKSYmKHI9QihuKHIpLHRoaXMudWlTdHJpbmdzKSksdGhpc1t0XT1yfSkpKTtpZih0aGlzLmRlc3Ryb3llZClyZXR1cm47Zm9yKGNvbnN0IHQgb2YgZSl0LmVycm9yJiZhLmdldExvZ2dlcih0aGlzKS5lcnJvcihcIndpZGdldC1pbnRsOmxvY2FsZS1lcnJvclwiLHRoaXMuZGVjbGFyZWRDbGFzcyx0LmVycm9yKX1hd2FpdCB0aGlzLmxvYWRMb2NhbGUoKX0pKSxrKCk7Y29uc3Qgcj1cImVzcmktd2lkZ2V0LXVpZC1cIitnKCkscz10aGlzLnJlbmRlci5iaW5kKHRoaXMpO3RoaXMuX3RyYWNraW5nVGFyZ2V0PW5ldyBiKCgoKT0+dGhpcy5zY2hlZHVsZVJlbmRlcigpKSk7Y29uc3Qgbz0oKT0+e2lmKCF0aGlzLl9yZWFkeUZvclRydWVSZW5kZXJ8fHRoaXMuZGVzdHJveWVkKXJldHVybiBudWxsO2NvbnN0IGU9cygpO2xldHtwcm9wZXJ0aWVzOnR9PWU7dHx8KGUucHJvcGVydGllcz10PXt9KTtjb25zdHtrZXk6b309dDtvfHwodC5rZXk9ciksdGhpcy52aXNpYmxlP3Quc3R5bGVzfHwodC5zdHlsZXM9e30pOih0LmNsYXNzPVwiXCIsdC5zdHlsZXM9e2Rpc3BsYXk6XCJub25lXCJ9KSx0LnN0eWxlcy5kaXNwbGF5fHwodC5zdHlsZXMuZGlzcGxheT1cIlwiKTtsZXQgaT0wO3JldHVybiBlLmNoaWxkcmVuPy5mb3JFYWNoKChlPT57aWYoUihlLnZub2RlU2VsZWN0b3IpKXJldHVybjtsZXR7cHJvcGVydGllczp0fT1lO3R8fChlLnByb3BlcnRpZXM9dD17fSksdC5rZXl8fCh0LmtleT1gJHt0aGlzLmlkfS0tJHtpKyt9YCl9KSksUyh0aGlzLGUpfTt0aGlzLnJlbmRlcj0oKT0+e2lmKE0pcmV0dXJuIG8oKTtsZXQgZT1JKHRoaXMpPz9udWxsO2lmKGUpcmV0dXJuIGU7dGhpcy5fdHJhY2tpbmdUYXJnZXQuY2xlYXIoKSxNPSEwO3RyeXtlPWoodGhpcy5fdHJhY2tpbmdUYXJnZXQsbyl9Y2F0Y2godCl7dGhyb3cgY29uc29sZS5lcnJvcih0KSx0fWZpbmFsbHl7TT0hMX1yZXR1cm4gZSYmTCh0aGlzLGUpLGV9LHRoaXMuYWRkUmVzb2x2aW5nUHJvbWlzZSh0aGlzLl9yZXNvdXJjZXNGZXRjaD10aGlzLmJlZm9yZUZpcnN0UmVuZGVyKCkudGhlbigoKCk9Pnt0aGlzLl9yZWFkeUZvclRydWVSZW5kZXI9ITAsdGhpcy5fcG9zdEluaXRpYWxpemUoKX0pKSksRSh0aGlzLl9yZXNvdXJjZXNGZXRjaCl9bm9ybWFsaXplQ3RvckFyZ3MoZSx0KXtjb25zdCByPXsuLi5lfTtyZXR1cm4gdCYmKHIuY29udGFpbmVyPXQpLHJ9cG9zdEluaXRpYWxpemUoKXt9YmVmb3JlRmlyc3RSZW5kZXIoKXtyZXR1cm4gUHJvbWlzZS5hbGwoW3RoaXMubG9hZERlcGVuZGVuY2llcygpLHRoaXMuX2xvYWRMb2NhbGUoKV0pLnRoZW4oKCgpPT57fSkpLmNhdGNoKHApfWFzeW5jIGxvYWREZXBlbmRlbmNpZXMoKXt9YXN5bmMgbG9hZExvY2FsZSgpe31kZXN0cm95KCl7dGhpcy5kZXN0cm95ZWR8fChjKHRoaXMuX3RyYWNraW5nVGFyZ2V0KSxjKHRoaXMudmlld01vZGVsKSx0aGlzLl9kZXRhY2godGhpcy5jb250YWluZXIpLHRoaXMuX3NldChcImNvbnRhaW5lclwiLG51bGwpLHRoaXMuX2ludGVybmFsSGFuZGxlcy5kZXN0cm95KCksdGhpcy5fZW1pdHRlci5jbGVhcigpLHRoaXMucmVuZGVyPSgpPT5udWxsLHRoaXMuX3Byb2plY3Rvcj1udWxsLFQodGhpcykpfXNldCBjb250YWluZXIoZSl7dGhpcy5fZ2V0KFwiY29udGFpbmVyXCIpfHx0aGlzLl9zZXQoXCJjb250YWluZXJcIixlKX1jYXN0Q29udGFpbmVyKGUpe3JldHVybiB0KGUpfWdldCBkb21Ob2RlKCl7cmV0dXJuIHRoaXMuY29udGFpbmVyfXNldCBkb21Ob2RlKGUpe3RoaXMuY29udGFpbmVyPWV9Z2V0IGlkKCl7cmV0dXJuIHRoaXMuX2dldChcImlkXCIpfHx0aGlzLmdldChcImNvbnRhaW5lci5pZFwiKXx8RGF0ZS5ub3coKS50b1N0cmluZygxNikrXCItd2lkZ2V0LVwiK3grK31zZXQgaWQoZSl7ZSYmdGhpcy5fc2V0KFwiaWRcIixlKX1nZXQgbGFiZWwoKXtyZXR1cm4gdGhpcy5kZWNsYXJlZENsYXNzLnNwbGl0KFwiLlwiKS5wb3AoKX1zZXQgbGFiZWwoZSl7dGhpcy5fb3ZlcnJpZGVJZlNvbWUoXCJsYWJlbFwiLGUpfWdldCByZW5kZXJhYmxlKCl7cmV0dXJuIHRoaXMuX3Jlc291cmNlc0ZldGNofWdldCB2aXNpYmxlKCl7cmV0dXJuIHRoaXMuX2dldChcInZpc2libGVcIil9c2V0IHZpc2libGUoZSl7dGhpcy5fc2V0KFwidmlzaWJsZVwiLGUpfWdldFsoJD1QLEMpXSgpe3JldHVybntwcm9qZWN0b3I6dGhpcy5fcHJvamVjdG9yfX1yZW5kZXIoKXt0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIil9c2NoZWR1bGVSZW5kZXIoKXt0aGlzLmRlc3Ryb3llZHx8KFQodGhpcyksdGhpcy5fcHJvamVjdG9yLnNjaGVkdWxlUmVuZGVyKCkpfWNsYXNzZXMoLi4uZSl7cmV0dXJuIEYuYXBwbHkodGhpcyxlKX1yZW5kZXJOb3coKXtUKHRoaXMpLHRoaXMuX3Byb2plY3Rvci5yZW5kZXJOb3coKX1fcG9zdEluaXRpYWxpemUoKXtpZih0aGlzLmRlc3Ryb3llZClyZXR1cm47dGhpcy5zY2hlZHVsZVJlbmRlcigpLHRoaXMuX2RlbGVnYXRlZEV2ZW50TmFtZXM/Lmxlbmd0aCYmdGhpcy5faW50ZXJuYWxIYW5kbGVzLmFkZChtKCgoKT0+dGhpcy52aWV3TW9kZWwpLCgoZSx0KT0+e3QmJnRoaXMuX2ludGVybmFsSGFuZGxlcy5yZW1vdmUoXCJkZWxlZ2F0ZWQtZXZlbnRzXCIpLGUmJnMoZSkmJnRoaXMuX2ludGVybmFsSGFuZGxlcy5hZGQodGhpcy5fZGVsZWdhdGVkRXZlbnROYW1lcy5tYXAoKHQ9Pm8oZSx0LChlPT57dGhpcy5lbWl0KHQsZSl9KSkpKSxcImRlbGVnYXRlZC1ldmVudHNcIil9KSx5KSksdGhpcy5wb3N0SW5pdGlhbGl6ZSgpO2NvbnN0IGU9YXN5bmMoKT0+e2F3YWl0IHRoaXMuX2xvYWRMb2NhbGUoKS5jYXRjaChwKSx0aGlzLnNjaGVkdWxlUmVuZGVyKCl9O3RoaXMuX2ludGVybmFsSGFuZGxlcy5hZGQoW04oZSksbSgoKCk9PnRoaXMudWlTdHJpbmdzKSxlKSx1KCgoKT0+dGhpcy5jb250YWluZXIpLChlPT57dGhpcy5kZXN0cm95ZWR8fHRoaXMuX2F0dGFjaChlKX0pLHtpbml0aWFsOiEwLG9uY2U6ITB9KV0pfV9hdHRhY2goZSl7ZSYmKHRoaXMuX3Byb2plY3Rvci5tZXJnZShlLHRoaXMucmVuZGVyKSx0aGlzLl9hdHRhY2hlZD0hMCl9X2RldGFjaChlKXt0aGlzLl9hdHRhY2hlZCYmKHRoaXMuX3Byb2plY3Rvci5kZXRhY2godGhpcy5yZW5kZXIpLHRoaXMuX2F0dGFjaGVkPSExKSxlPy5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZChlKX19O09bJF09ITAsZShbXygpXSxPLnByb3RvdHlwZSxcIl9yZWFkeUZvclRydWVSZW5kZXJcIix2b2lkIDApLGUoW18oe3ZhbHVlOm51bGx9KV0sTy5wcm90b3R5cGUsXCJjb250YWluZXJcIixudWxsKSxlKFtmKFwiY29udGFpbmVyXCIpXSxPLnByb3RvdHlwZSxcImNhc3RDb250YWluZXJcIixudWxsKSxlKFtfKCldLE8ucHJvdG90eXBlLFwiaWNvbkNsYXNzXCIsdm9pZCAwKSxlKFtfKCldLE8ucHJvdG90eXBlLFwiaWNvblwiLHZvaWQgMCksZShbXygpXSxPLnByb3RvdHlwZSxcImlkXCIsbnVsbCksZShbXygpXSxPLnByb3RvdHlwZSxcImxhYmVsXCIsbnVsbCksZShbXygpXSxPLnByb3RvdHlwZSxcInJlbmRlcmFibGVcIixudWxsKSxlKFtfKCldLE8ucHJvdG90eXBlLFwidWlTdHJpbmdzXCIsdm9pZCAwKSxlKFtfKCldLE8ucHJvdG90eXBlLFwidmlld01vZGVsXCIsdm9pZCAwKSxlKFtfKHt2YWx1ZTohMH0pXSxPLnByb3RvdHlwZSxcInZpc2libGVcIixudWxsKSxlKFtfKCldLE8ucHJvdG90eXBlLFwia2V5XCIsdm9pZCAwKSxlKFtfKCldLE8ucHJvdG90eXBlLFwiY2hpbGRyZW5cIix2b2lkIDApLGUoW18oKV0sTy5wcm90b3R5cGUsXCJhZnRlckNyZWF0ZVwiLHZvaWQgMCksZShbXygpXSxPLnByb3RvdHlwZSxcImFmdGVyVXBkYXRlXCIsdm9pZCAwKSxlKFtfKCldLE8ucHJvdG90eXBlLFwiYWZ0ZXJSZW1vdmVkXCIsdm9pZCAwKSxPPWUoW3YoeildLE8pO2NvbnN0IFc9TztleHBvcnR7VyBhcyBkZWZhdWx0fTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnR7Z2V0QXNzZXRQYXRoIGFzIHQsc2V0QXNzZXRQYXRoIGFzIG99ZnJvbVwiQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Rpc3QvY29tcG9uZW50cy9pbmRleC5qc1wiO2ltcG9ydHtnZXRBc3NldFVybCBhcyBzfWZyb21cIi4uLy4uL2Fzc2V0cy5qc1wiO2ltcG9ydFwiLi4vLi4vY29yZS9oYXMuanNcIjtpbXBvcnR7bWFrZUFic29sdXRlIGFzIGV9ZnJvbVwiLi4vLi4vY29yZS91cmxVdGlscy5qc1wiO2xldCBjO2Z1bmN0aW9uIHIoKXt0cnl7dChcIi5cIil9Y2F0Y2h7byhlKHMoYykpKX19ZnVuY3Rpb24gbih0KXtjb25zdCBvPVtdO2Zvcihjb25zdCBzIG9mIE9iamVjdC5rZXlzKHQpKWN1c3RvbUVsZW1lbnRzLmdldChgY2FsY2l0ZS0ke3N9YCl8fG8ucHVzaCh0W3NdPy4oKSk7cmV0dXJuIFByb21pc2UuYWxsKG8pfWM9XCJjb21wb25lbnRzL2Fzc2V0c1wiO2V4cG9ydHtyIGFzIGNvbW1pdEFzc2V0UGF0aCxuIGFzIGxvYWRDYWxjaXRlQ29tcG9uZW50c307XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e2lzQWN0aXZhdGlvbktleSBhcyBufWZyb21cIi4uL3dpZGdldFV0aWxzLmpzXCI7ZnVuY3Rpb24gdCgpe3JldHVybiBmdW5jdGlvbihuLHQpe2lmKCFuW3RdKXRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCBhdXRvIGJpbmQgdW5kZWZpbmVkIGZ1bmN0aW9uICcke1N0cmluZyh0KX0nYCk7cmV0dXJue3ZhbHVlOnIoblt0XSl9fX1mdW5jdGlvbiBlKG4pe2NvbnN0IHQ9bj8udHlwZTtyZXR1cm4gbiBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnR8fFwia2V5dXBcIj09PXR8fFwia2V5ZG93blwiPT09dHx8XCJrZXlwcmVzc1wiPT09dH1mdW5jdGlvbiByKHQpe3JldHVybiBmdW5jdGlvbihyLC4uLm8pe2Uocik/bihyLmtleSkmJihyLnByZXZlbnREZWZhdWx0KCksci5zdG9wUHJvcGFnYXRpb24oKSxyLnRhcmdldC5jbGljaygpKTp0LmNhbGwodGhpcyxyLC4uLm8pfX1leHBvcnR7dCBhcyBhY2Nlc3NpYmxlSGFuZGxlcn07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuZnVuY3Rpb24gZShlKXtyZXR1cm4ocyxyKT0+e3MuaGFzT3duUHJvcGVydHkoXCJfbWVzc2FnZUJ1bmRsZVByb3BzXCIpfHwocy5fbWVzc2FnZUJ1bmRsZVByb3BzPXMuX21lc3NhZ2VCdW5kbGVQcm9wcz9zLl9tZXNzYWdlQnVuZGxlUHJvcHMuc2xpY2UoKTpbXSk7cy5fbWVzc2FnZUJ1bmRsZVByb3BzLnB1c2goe2J1bmRsZVBhdGg6ZSxwcm9wZXJ0eU5hbWU6cn0pfX1leHBvcnR7ZSBhcyBtZXNzYWdlQnVuZGxlfTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5mdW5jdGlvbiBlKGUpe3JldHVybiBhPT57YS5oYXNPd25Qcm9wZXJ0eShcIl9kZWxlZ2F0ZWRFdmVudE5hbWVzXCIpfHwoYS5fZGVsZWdhdGVkRXZlbnROYW1lcz1hLl9kZWxlZ2F0ZWRFdmVudE5hbWVzP2EuX2RlbGVnYXRlZEV2ZW50TmFtZXMuc2xpY2UoKTpbXSk7Y29uc3Qgbj1hLl9kZWxlZ2F0ZWRFdmVudE5hbWVzLHI9QXJyYXkuaXNBcnJheShlKT9lOnQoZSk7bi5wdXNoKC4uLnIpfX1mdW5jdGlvbiB0KGUpe3JldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGU9PmUudHJpbSgpKSl9ZXhwb3J0e2UgYXMgdm1FdmVudH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e2lzV2lkZ2V0Q29uc3RydWN0b3IgYXMgcn1mcm9tXCIuL2pzeFdpZGdldFN1cHBvcnQuanNcIjt2YXIgZT1mdW5jdGlvbihyKXtyZXR1cm57dm5vZGVTZWxlY3RvcjpcIlwiLHByb3BlcnRpZXM6dm9pZCAwLGNoaWxkcmVuOnZvaWQgMCx0ZXh0OnIudG9TdHJpbmcoKSxkb21Ob2RlOm51bGx9fSxvPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBuPTAsaT1yLmxlbmd0aDtuPGk7bisrKXt2YXIgZD1yW25dO0FycmF5LmlzQXJyYXkoZCk/byhkLHQpOm51bGwhPWQmJiExIT09ZCYmKGQuaGFzT3duUHJvcGVydHkoXCJ2bm9kZVNlbGVjdG9yXCIpfHwoZD1lKGQpKSx0LnB1c2goZCkpfX0sdD1mdW5jdGlvbihyLGUpe2Zvcih2YXIgdD1bXSxuPTI7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0W24tMl09YXJndW1lbnRzW25dO2lmKDE9PT10Lmxlbmd0aCYmXCJzdHJpbmdcIj09dHlwZW9mIHRbMF0pcmV0dXJue3Zub2RlU2VsZWN0b3I6cixwcm9wZXJ0aWVzOmV8fHZvaWQgMCxjaGlsZHJlbjp2b2lkIDAsdGV4dDp0WzBdLGRvbU5vZGU6bnVsbH07dmFyIGk9W107cmV0dXJuIG8odCxpKSx7dm5vZGVTZWxlY3RvcjpyLHByb3BlcnRpZXM6ZXx8dm9pZCAwLGNoaWxkcmVuOmksdGV4dDp2b2lkIDAsZG9tTm9kZTpudWxsfX07ZnVuY3Rpb24gbihlLG8sLi4ubil7cmV0dXJuXCJmdW5jdGlvblwiIT10eXBlb2YgZXx8cihlKT90KGUsbywuLi5uKTplKG8sLi4ubil9ZnVuY3Rpb24gaSguLi5yKXtyZXR1cm4gcn1leHBvcnR7biBhcyB0c3gsaSBhcyB0c3hGcmFnbWVudH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e21ha2VIYW5kbGUgYXMgZX1mcm9tXCIuLi8uLi9jb3JlL2hhbmRsZVV0aWxzLmpzXCI7aW1wb3J0e1dJREdFVF9TWU1CT0wgYXMgdH1mcm9tXCIuL3N5bWJvbHMuanNcIjtjb25zdCByPVtdLG89e30sbj1uZXcgV2Vha01hcDtmdW5jdGlvbiBpKGUsdCl7bGV0IG49dC5jaGlsZHJlbjtpZihuJiZuLmxlbmd0aClmb3IobGV0IHI9MDtyPG4ubGVuZ3RoOysrciluW3JdPWkoZSxuW3JdKTtlbHNlIG49cjtjb25zdCBmPXQudm5vZGVTZWxlY3RvcjtpZihhKGYpKXtjb25zdCByPXQucHJvcGVydGllc3x8byxpPXIua2V5fHxmO3JldHVybnt2bm9kZVNlbGVjdG9yOlwiZGl2XCIscHJvcGVydGllczp7a2V5OmksYWZ0ZXJDcmVhdGU6ZCxhZnRlclVwZGF0ZTpzLGFmdGVyUmVtb3ZlZDpjLHBhcmVudFdpZGdldDplLHdpZGdldENvbnN0cnVjdG9yOmYsd2lkZ2V0UHJvcGVydGllczp7Li4ucixrZXk6aSxjaGlsZHJlbjpufX0sY2hpbGRyZW46dm9pZCAwLHRleHQ6dm9pZCAwLGRvbU5vZGU6bnVsbH19cmV0dXJuIHR9ZnVuY3Rpb24gZCh0LHIsbyx7cGFyZW50V2lkZ2V0Omksd2lkZ2V0Q29uc3RydWN0b3I6ZCx3aWRnZXRQcm9wZXJ0aWVzOnN9KXtjb25zdCBhPW5ldyBkKHMpO2EuY29udGFpbmVyPXQsbi5zZXQodCxhKSxhLmFmdGVyQ3JlYXRlPy4oYSx0KSxpLl9pbnRlcm5hbEhhbmRsZXMuYWRkKGUoKCgpPT5jKHQpKSkpfWZ1bmN0aW9uIHMoZSx0LHIse3dpZGdldFByb3BlcnRpZXM6b30pe2NvbnN0IGk9bi5nZXQoZSk7aSYmKGkuc2V0KG8pLGkuYWZ0ZXJVcGRhdGU/LihpLGUpKX1mdW5jdGlvbiBjKGUpe2NvbnN0IHQ9bi5nZXQoZSk7dCYmKHQuYWZ0ZXJSZW1vdmVkPy4odCxlKSx0LmRlc3Ryb3koKSxuLmRlbGV0ZShlKSl9ZnVuY3Rpb24gYShlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlW3RdfWV4cG9ydHthIGFzIGlzV2lkZ2V0Q29uc3RydWN0b3IsaSBhcyBwcm9jZXNzV2lkZ2V0c307XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuY29uc3QgdD1TeW1ib2woXCJ3aWRnZXRcIiksZT1TeW1ib2woXCJ3aWRnZXQtdGVzdC1kYXRhXCIpO2V4cG9ydHt0IGFzIFdJREdFVF9TWU1CT0wsZSBhcyBXSURHRVRfVEVTVF9EQVRBX1NZTUJPTH07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuY29uc3QgZT1uZXcgU2V0O2Z1bmN0aW9uIG4obil7ZS5hZGQobiksbi5maW5hbGx5KCgoKT0+ZS5kZWxldGUobikpKX1mdW5jdGlvbiB0KCl7cmV0dXJuIGUuc2l6ZT4wfWV4cG9ydHt0IGFzIGhhc1BlbmRpbmdMb2FkaW5nLG4gYXMgcmVnaXN0ZXJMb2FkaW5nfTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5jb25zdCBuPW5ldyBNYXA7ZnVuY3Rpb24gdCgpe24uY2xlYXIoKX1mdW5jdGlvbiBlKHQpe3JldHVybiBuLmdldCh0KX1mdW5jdGlvbiBjKHQsZSl7bi5zZXQodCxlKX1mdW5jdGlvbiBvKHQpe24uZGVsZXRlKHQpfWV4cG9ydHt0IGFzIGNsZWFyVk5vZGVDYWNoZSxvIGFzIGRlbGV0ZVZOb2RlQ2FjaGUsZSBhcyBnZXRWTm9kZUNhY2hlLGMgYXMgc2V0Vk5vZGVDYWNoZX07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuZXhwb3J0e2FjY2Vzc2libGVIYW5kbGVyfWZyb21cIi4vZGVjb3JhdG9ycy9hY2Nlc3NpYmxlSGFuZGxlci5qc1wiO2V4cG9ydHttZXNzYWdlQnVuZGxlfWZyb21cIi4vZGVjb3JhdG9ycy9tZXNzYWdlQnVuZGxlLmpzXCI7ZXhwb3J0e3ZtRXZlbnR9ZnJvbVwiLi9kZWNvcmF0b3JzL3ZtRXZlbnQuanNcIjtleHBvcnR7dHN4LHRzeEZyYWdtZW50fWZyb21cIi4vanN4RmFjdG9yeS5qc1wiO2V4cG9ydHthZGRpdGlvbmFsQWxsb3dlZFRhZ3MsY2xhc3Nlcyxjc3NUcmFuc2l0aW9uLGRpc2NhcmROb2RlLGdldERpcixpc0FjdGl2YXRpb25LZXksaXNSVEwsa2VlcE1lbnVJdGVtV2l0aGluVmlldyxvblJlc2l6ZSxyZW5kZXJpbmdTYW5pdGl6ZXIsc2FmZUF0dHJzLHN0b3JlTm9kZX1mcm9tXCIuL3dpZGdldFV0aWxzLmpzXCI7ZXhwb3J0e2dldENhbGNpdGVUaGVtZUNsYXNzLGlzRGFya1RoZW1lLHNldENhbGNpdGVUaGVtZUNsYXNzfWZyb21cIi4uLy4uL3N1cHBvcnQvdGhlbWVVdGlscy5qc1wiO2Z1bmN0aW9uIGUoZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUucmVuZGVyfWZ1bmN0aW9uIHQoZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUucG9zdE1peEluUHJvcGVydGllcyYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5idWlsZFJlbmRlcmluZyYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5wb3N0Q3JlYXRlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnN0YXJ0dXB9ZXhwb3J0e3QgYXMgaGFzRG9tTm9kZSxlIGFzIGlzV2lkZ2V0fTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5pbXBvcnQgZSBmcm9tXCJAZXNyaS9hcmNnaXMtaHRtbC1zYW5pdGl6ZXJcIjtpbXBvcnQgdCBmcm9tXCIuLi8uLi9jb3JlL0FycmF5UG9vbC5qc1wiO2ltcG9ydHttYWtlSGFuZGxlIGFzIG59ZnJvbVwiLi4vLi4vY29yZS9oYW5kbGVVdGlscy5qc1wiO2ltcG9ydFwiLi4vLi4vY29yZS9oYXMuanNcIjtpbXBvcnQgciBmcm9tXCIuLi8uLi9jb3JlL0xvZ2dlci5qc1wiO2ltcG9ydHt3YXRjaCBhcyBpLHN5bmNBbmRJbml0aWFsIGFzIG99ZnJvbVwiLi4vLi4vY29yZS9yZWFjdGl2ZVV0aWxzLmpzXCI7aW1wb3J0e2NsZWFyVk5vZGVDYWNoZSBhcyBzfWZyb21cIi4vdm5vZGVDYWNoZS5qc1wiO3ZhciBhLGMsbD1mdW5jdGlvbihlKXtpZihcIldlYmtpdFRyYW5zaXRpb25cImluIGUuc3R5bGUpYT1cIndlYmtpdFRyYW5zaXRpb25FbmRcIixjPVwid2Via2l0QW5pbWF0aW9uRW5kXCI7ZWxzZXtpZighKFwidHJhbnNpdGlvblwiaW4gZS5zdHlsZSkpdGhyb3cgbmV3IEVycm9yKFwiWW91ciBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQhXCIpO2E9XCJ0cmFuc2l0aW9uZW5kXCIsYz1cImFuaW1hdGlvbmVuZFwifX0sZD1mdW5jdGlvbihlKXthfHxsKGUpfSx1PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PWUrXCItYWN0aXZlXCIpLGZ1bmN0aW9uKG4pe2Qobik7dmFyIHI9ITEsaT1mdW5jdGlvbihvKXtyfHwocj0hMCxuLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSxpKSxuLnJlbW92ZUV2ZW50TGlzdGVuZXIoYyxpKSxuLmNsYXNzTGlzdC5yZW1vdmUoZSksbi5jbGFzc0xpc3QucmVtb3ZlKHQpKX07bi5jbGFzc0xpc3QuYWRkKGUpLG4uYWRkRXZlbnRMaXN0ZW5lcihhLGkpLG4uYWRkRXZlbnRMaXN0ZW5lcihjLGkpLHJlcXVlc3RBbmltYXRpb25GcmFtZSgoZnVuY3Rpb24oKXtuLmNsYXNzTGlzdC5hZGQodCl9KSl9fSxwPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PWUrXCItYWN0aXZlXCIpLGZ1bmN0aW9uKG4scil7ZChuKTt2YXIgaT0hMSxvPWZ1bmN0aW9uKGUpe2l8fChpPSEwLG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihhLG8pLG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihjLG8pLHIoKSl9O24uY2xhc3NMaXN0LmFkZChlKSxuLmFkZEV2ZW50TGlzdGVuZXIoYSxvKSxuLmFkZEV2ZW50TGlzdGVuZXIoYyxvKSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKGZ1bmN0aW9uKCl7bi5jbGFzc0xpc3QuYWRkKHQpfSkpfX07Y29uc3QgZj1yLmdldExvZ2dlcihcImVzcmkud2lkZ2V0cy5zdXBwb3J0LndpZGdldFV0aWxzXCIpO2Z1bmN0aW9uIG0oZSl7Y29uc3Qgbj10LmFjcXVpcmUoKTtmb3IobGV0IHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtjb25zdCBlPWFyZ3VtZW50c1t0XSxyPXR5cGVvZiBlO2lmKFwic3RyaW5nXCI9PT1yKW4ucHVzaChlKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZSkpbi5wdXNoLmFwcGx5KG4sZSk7ZWxzZSBpZihcIm9iamVjdFwiPT09cilmb3IoY29uc3QgdCBpbiBlKWVbdF0mJm4ucHVzaCh0KX1jb25zdCByPW4uam9pbihcIiBcIik7cmV0dXJuIHQucmVsZWFzZShuKSxyfWNvbnN0IGc9KCgpPT57Y29uc3QgZT1uZXcgTWFwLHQ9bmV3IFJlc2l6ZU9ic2VydmVyKCh0PT57cygpO2Zvcihjb25zdCBuIG9mIHQpZS5nZXQobi50YXJnZXQpPy4obil9KSkscj0ocixpLG8pPT4oZS5oYXMocikmJmYuZXJyb3IoXCJBbHJlYWR5IG9ic2VydmluZyBlbGVtZW50XCIsciksZS5zZXQocixpKSx0Lm9ic2VydmUocixvKSxuKCgoKT0+e3QudW5vYnNlcnZlKHIpLGUuZGVsZXRlKHIpfSkpKTtyZXR1cm4oZSx0LG4pPT57bGV0IHM9bnVsbDtyZXR1cm4gaSgoKCk9PlwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZSgpOmUpLChlPT57cz8ucmVtb3ZlKCksZSYmKHM9cihlLHQsbikpfSksbyl9fSkoKTtmdW5jdGlvbiBoKGUpe2NvbnN0IHQ9ZT8uY2xvc2VzdChcIltkaXJdXCIpO3JldHVybiBudWxsIT09dCYmdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiZcInJ0bFwiPT09dC5kaXJ8fFwicnRsXCI9PT1kb2N1bWVudC5kaXJ9ZnVuY3Rpb24gdihlKXtyZXR1cm4gaChlKT9cInJ0bFwiOlwibHRyXCJ9ZnVuY3Rpb24gdyhlKXtjb25zdCB0PVwiZGF0YS1ub2RlLXJlZlwiO3RoaXNbZS5nZXRBdHRyaWJ1dGUodCldPW51bGx9ZnVuY3Rpb24gTChlKXtjb25zdCB0PVwiZGF0YS1ub2RlLXJlZlwiO3RoaXNbZS5nZXRBdHRyaWJ1dGUodCldPWV9ZnVuY3Rpb24gYihlLHQpe3JldHVybihcImVudGVyXCI9PT1lP3U6cCkodCl9Y29uc3QgeT1bXCJkZFwiLFwiZGxcIixcImR0XCIsXCJoMVwiLFwiaDJcIixcImgzXCIsXCJoNFwiLFwiaDVcIixcImg2XCIsXCJzdWJcIixcInN1cFwiLC4uLltcImFuaW1hdGVcIixcImFuaW1hdGV0cmFuc2Zvcm1cIixcImNpcmNsZVwiLFwiY2xpcHBhdGhcIixcImRlZnNcIixcImVsbGlwc2VcIixcImdcIixcImltYWdlXCIsXCJsaW5lXCIsXCJsaW5lYXJncmFkaWVudFwiLFwibWFya2VyXCIsXCJtYXNrXCIsXCJwYXRoXCIsXCJwYXR0ZXJuXCIsXCJwb2x5Z29uXCIsXCJwb2x5bGluZVwiLFwicmFkaWFsZ3JhZGllbnRcIixcInJlY3RcIixcInN0b3BcIixcInN2Z1wiLFwic3dpdGNoXCIsXCJzeW1ib2xcIixcInRleHRcIixcInRleHRwYXRoXCIsXCJ0c3BhblwiLFwidXNlXCJdXSxFPXkucmVkdWNlKCgoZSx0KT0+KGVbdF09W10sZSkpLHt9KSxBPVtcImFsaWduXCIsXCJhbGlua1wiLFwiYWx0XCIsXCJiZ2NvbG9yXCIsXCJib3JkZXJcIixcImNlbGxwYWRkaW5nXCIsXCJjZWxsc3BhY2luZ1wiLFwiY2xhc3NcIixcImNvbG9yXCIsXCJjb2xzXCIsXCJjb2xzcGFuXCIsXCJjb29yZHNcIixcImRcIixcImRpclwiLFwiZmFjZVwiLFwiaGVpZ2h0XCIsXCJoc3BhY2VcIixcImlzbWFwXCIsXCJsYW5nXCIsXCJtYXJnaW5oZWlnaHRcIixcIm1hcmdpbndpZHRoXCIsXCJtdWx0aXBsZVwiLFwibm9ocmVmXCIsXCJub3Jlc2l6ZVwiLFwibm9zaGFkZVwiLFwibm93cmFwXCIsXCJyZWZcIixcInJlbFwiLFwicmV2XCIsXCJyb3dzXCIsXCJyb3dzcGFuXCIsXCJzY3JvbGxpbmdcIixcInNoYXBlXCIsXCJzcGFuXCIsXCJzdW1tYXJ5XCIsXCJ0YWJpbmRleFwiLFwidGl0bGVcIixcInVzZW1hcFwiLFwidmFsaWduXCIsXCJ2YWx1ZVwiLFwidmxpbmtcIixcInZzcGFjZVwiLFwid2lkdGhcIl0saj1uZXcgZSh7d2hpdGVMaXN0OkUsb25UYWdBdHRyOihlLHQsbik9Pntjb25zdCByPWAke3R9PVwiJHtufVwiYDtpZihBLmluY2x1ZGVzKHQpKXJldHVybiByfSxzdHJpcElnbm9yZVRhZzohMCxzdHJpcElnbm9yZVRhZ0JvZHk6W1wic2NyaXB0XCIsXCJzdHlsZVwiXX0sITApO2Z1bmN0aW9uIGsoZSx0KXtjb25zdCBuPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkscj10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGk9bi50b3Arbi5oZWlnaHQsbz1yLnRvcCtyLmhlaWdodCxzPW4udG9wLGE9ci50b3A7KGk+b3x8czxhKSYmZS5zY3JvbGxJbnRvVmlldyh7YmxvY2s6XCJlbmRcIn0pfWZ1bmN0aW9uIFQoZSl7cmV0dXJuXCJFbnRlclwiPT09ZXx8XCIgXCI9PT1lfWV4cG9ydHt5IGFzIGFkZGl0aW9uYWxBbGxvd2VkVGFncyxtIGFzIGNsYXNzZXMsYiBhcyBjc3NUcmFuc2l0aW9uLHcgYXMgZGlzY2FyZE5vZGUsdiBhcyBnZXREaXIsVCBhcyBpc0FjdGl2YXRpb25LZXksaCBhcyBpc1JUTCxrIGFzIGtlZXBNZW51SXRlbVdpdGhpblZpZXcsZyBhcyBvblJlc2l6ZSxqIGFzIHJlbmRlcmluZ1Nhbml0aXplcixBIGFzIHNhZmVBdHRycyxMIGFzIHN0b3JlTm9kZX07XG4iLCIvKiFcbiAqIEBlc3JpL2FyY2dpcy1odG1sLXNhbml0aXplciAtIHYzLjAuMSAtIFR1ZSBOb3YgMTUgMjAyMiAwOTo0Njo1NCBHTVQtMDgwMCAoUGFjaWZpYyBTdGFuZGFyZCBUaW1lKVxuICogQ29weXJpZ2h0IChjKSAyMDIyIC0gRW52aXJvbm1lbnRhbCBTeXN0ZW1zIFJlc2VhcmNoIEluc3RpdHV0ZSwgSW5jLlxuICogQXBhY2hlLTIuMFxuICogXG4gKiBqcy14c3NcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE4IFpvbmdtaW4gTGVpKOmbt+Wul+awkSkgPGxlaXpvbmdtaW5AZ21haWwuY29tPlxuICogaHR0cDovL3VjZG9rLmNvbVxuICogTUlUIExpY2Vuc2UsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbGVpem9uZ21pbi9qcy14c3MvYmxvYi9tYXN0ZXIvTElDRU5TRSBmb3IgZGV0YWlsc1xuICovXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbnZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvO1xufTtcblxudmFyIGxpYiQxID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIF9kZWZhdWx0JDEgPSB7fTtcblxudmFyIGxpYiA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBfZGVmYXVsdCA9IHt9O1xuXG4vKipcbiAqIGNzc2ZpbHRlclxuICpcbiAqIEBhdXRob3Ig6ICB6Zu3PGxlaXpvbmdtaW5AZ21haWwuY29tPlxuICovXG5cbmZ1bmN0aW9uIGdldERlZmF1bHRXaGl0ZUxpc3QkMSAoKSB7XG4gIC8vIOeZveWQjeWNleWAvOivtOaYju+8mlxuICAvLyB0cnVlOiDlhYHorrjor6XlsZ7mgKdcbiAgLy8gRnVuY3Rpb246IGZ1bmN0aW9uICh2YWwpIHsgfSDov5Tlm550cnVl6KGo56S65YWB6K646K+l5bGe5oCn77yM5YW25LuW5YC85Z2H6KGo56S65LiN5YWB6K64XG4gIC8vIFJlZ0V4cDogcmVnZXhwLnRlc3QodmFsKSDov5Tlm550cnVl6KGo56S65YWB6K646K+l5bGe5oCn77yM5YW25LuW5YC85Z2H6KGo56S65LiN5YWB6K64XG4gIC8vIOmZpOS4iumdouWIl+WHuueahOWAvOWkluWdh+ihqOekuuS4jeWFgeiuuFxuICB2YXIgd2hpdGVMaXN0ID0ge307XG5cbiAgd2hpdGVMaXN0WydhbGlnbi1jb250ZW50J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2FsaWduLWl0ZW1zJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2FsaWduLXNlbGYnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnYWxpZ25tZW50LWFkanVzdCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydhbGlnbm1lbnQtYmFzZWxpbmUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBiYXNlbGluZVxuICB3aGl0ZUxpc3RbJ2FsbCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydhbmNob3ItcG9pbnQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYW5pbWF0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ2FuaW1hdGlvbi1kZWxheSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0WydhbmltYXRpb24tZGlyZWN0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnYW5pbWF0aW9uLWR1cmF0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ2FuaW1hdGlvbi1maWxsLW1vZGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDFcbiAgd2hpdGVMaXN0WydhbmltYXRpb24tbmFtZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydhbmltYXRpb24tcGxheS1zdGF0ZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IHJ1bm5pbmdcbiAgd2hpdGVMaXN0WydhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZWFzZVxuICB3aGl0ZUxpc3RbJ2F6aW11dGgnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBjZW50ZXJcbiAgd2hpdGVMaXN0WydiYWNrZmFjZS12aXNpYmlsaXR5J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogdmlzaWJsZVxuICB3aGl0ZUxpc3RbJ2JhY2tncm91bmQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydiYWNrZ3JvdW5kLWF0dGFjaG1lbnQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IHNjcm9sbFxuICB3aGl0ZUxpc3RbJ2JhY2tncm91bmQtY2xpcCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogYm9yZGVyLWJveFxuICB3aGl0ZUxpc3RbJ2JhY2tncm91bmQtY29sb3InXSA9IHRydWU7IC8vIGRlZmF1bHQ6IHRyYW5zcGFyZW50XG4gIHdoaXRlTGlzdFsnYmFja2dyb3VuZC1pbWFnZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2JhY2tncm91bmQtb3JpZ2luJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBwYWRkaW5nLWJveFxuICB3aGl0ZUxpc3RbJ2JhY2tncm91bmQtcG9zaXRpb24nXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDAlIDAlXG4gIHdoaXRlTGlzdFsnYmFja2dyb3VuZC1yZXBlYXQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IHJlcGVhdFxuICB3aGl0ZUxpc3RbJ2JhY2tncm91bmQtc2l6ZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2Jhc2VsaW5lLXNoaWZ0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYmFzZWxpbmVcbiAgd2hpdGVMaXN0WydiaW5kaW5nJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2JsZWVkJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogNnB0XG4gIHdoaXRlTGlzdFsnYm9va21hcmstbGFiZWwnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBjb250ZW50KClcbiAgd2hpdGVMaXN0Wydib29rbWFyay1sZXZlbCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wydib29rbWFyay1zdGF0ZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG9wZW5cbiAgd2hpdGVMaXN0Wydib3JkZXInXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0Wydib3JkZXItYm90dG9tJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWJvdHRvbS1jb2xvciddID0gdHJ1ZTsgLy8gZGVmYXVsdDogY3VycmVudCBjb2xvclxuICB3aGl0ZUxpc3RbJ2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0Wydib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1cyddID0gdHJ1ZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ2JvcmRlci1ib3R0b20tc3R5bGUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wydib3JkZXItYm90dG9tLXdpZHRoJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBtZWRpdW1cbiAgd2hpdGVMaXN0Wydib3JkZXItY29sbGFwc2UnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IHNlcGFyYXRlXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWNvbG9yJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWltYWdlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWltYWdlLW91dHNldCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ2JvcmRlci1pbWFnZS1yZXBlYXQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IHN0cmV0Y2hcbiAgd2hpdGVMaXN0Wydib3JkZXItaW1hZ2Utc2xpY2UnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDEwMCVcbiAgd2hpdGVMaXN0Wydib3JkZXItaW1hZ2Utc291cmNlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWltYWdlLXdpZHRoJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAxXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWxlZnQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0Wydib3JkZXItbGVmdC1jb2xvciddID0gdHJ1ZTsgLy8gZGVmYXVsdDogY3VycmVudCBjb2xvclxuICB3aGl0ZUxpc3RbJ2JvcmRlci1sZWZ0LXN0eWxlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWxlZnQtd2lkdGgnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ2JvcmRlci1yYWRpdXMnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0Wydib3JkZXItcmlnaHQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0Wydib3JkZXItcmlnaHQtY29sb3InXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGN1cnJlbnQgY29sb3JcbiAgd2hpdGVMaXN0Wydib3JkZXItcmlnaHQtc3R5bGUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wydib3JkZXItcmlnaHQtd2lkdGgnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ2JvcmRlci1zcGFjaW5nJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsnYm9yZGVyLXN0eWxlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnYm9yZGVyLXRvcCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ2JvcmRlci10b3AtY29sb3InXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGN1cnJlbnQgY29sb3JcbiAgd2hpdGVMaXN0Wydib3JkZXItdG9wLWxlZnQtcmFkaXVzJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsnYm9yZGVyLXRvcC1yaWdodC1yYWRpdXMnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0Wydib3JkZXItdG9wLXN0eWxlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYm9yZGVyLXRvcC13aWR0aCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbWVkaXVtXG4gIHdoaXRlTGlzdFsnYm9yZGVyLXdpZHRoJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnYm90dG9tJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2JveC1kZWNvcmF0aW9uLWJyZWFrJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBzbGljZVxuICB3aGl0ZUxpc3RbJ2JveC1zaGFkb3cnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wydib3gtc2l6aW5nJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBjb250ZW50LWJveFxuICB3aGl0ZUxpc3RbJ2JveC1zbmFwJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYm94LXN1cHByZXNzJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBzaG93XG4gIHdoaXRlTGlzdFsnYnJlYWstYWZ0ZXInXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydicmVhay1iZWZvcmUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydicmVhay1pbnNpZGUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydjYXB0aW9uLXNpZGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiB0b3BcbiAgd2hpdGVMaXN0WydjaGFpbnMnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnY2xlYXInXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydjbGlwJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2NsaXAtcGF0aCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydjbGlwLXJ1bGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub256ZXJvXG4gIHdoaXRlTGlzdFsnY29sb3InXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGltcGxlbWVudGF0aW9uIGRlcGVuZGVudFxuICB3aGl0ZUxpc3RbJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyddID0gdHJ1ZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2NvbHVtbi1jb3VudCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wydjb2x1bW4tZmlsbCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGJhbGFuY2VcbiAgd2hpdGVMaXN0Wydjb2x1bW4tZ2FwJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnY29sdW1uLXJ1bGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnY29sdW1uLXJ1bGUtY29sb3InXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBjdXJyZW50IGNvbG9yXG4gIHdoaXRlTGlzdFsnY29sdW1uLXJ1bGUtc3R5bGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBtZWRpdW1cbiAgd2hpdGVMaXN0Wydjb2x1bW4tcnVsZS13aWR0aCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ2NvbHVtbi1zcGFuJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2NvbHVtbi13aWR0aCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wydjb2x1bW5zJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ2NvbnRhaW4nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnY29udGVudCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2NvdW50ZXItaW5jcmVtZW50J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2NvdW50ZXItcmVzZXQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnY291bnRlci1zZXQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnY3JvcCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydjdWUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnY3VlLWFmdGVyJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2N1ZS1iZWZvcmUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnY3Vyc29yJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2RpcmVjdGlvbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGx0clxuICB3aGl0ZUxpc3RbJ2Rpc3BsYXknXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydkaXNwbGF5LWluc2lkZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2Rpc3BsYXktbGlzdCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2Rpc3BsYXktb3V0c2lkZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogaW5saW5lLWxldmVsXG4gIHdoaXRlTGlzdFsnZG9taW5hbnQtYmFzZWxpbmUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnZWxldmF0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbGV2ZWxcbiAgd2hpdGVMaXN0WydlbXB0eS1jZWxscyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IHNob3dcbiAgd2hpdGVMaXN0WydmaWx0ZXInXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnZmxleCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydmbGV4LWJhc2lzJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2ZsZXgtZGlyZWN0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogcm93XG4gIHdoaXRlTGlzdFsnZmxleC1mbG93J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ2ZsZXgtZ3JvdyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0WydmbGV4LXNocmluayddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDFcbiAgd2hpdGVMaXN0WydmbGV4LXdyYXAnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub3dyYXBcbiAgd2hpdGVMaXN0WydmbG9hdCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydmbG9hdC1vZmZzZXQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiAwIDBcbiAgd2hpdGVMaXN0WydmbG9vZC1jb2xvciddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGJsYWNrXG4gIHdoaXRlTGlzdFsnZmxvb2Qtb3BhY2l0eSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDFcbiAgd2hpdGVMaXN0WydmbG93LWZyb20nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnZmxvdy1pbnRvJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2ZvbnQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0Wydmb250LWZhbWlseSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogaW1wbGVtZW50YXRpb24gZGVwZW5kZW50XG4gIHdoaXRlTGlzdFsnZm9udC1mZWF0dXJlLXNldHRpbmdzJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0Wydmb250LWtlcm5pbmcnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wydmb250LWxhbmd1YWdlLW92ZXJyaWRlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0Wydmb250LXNpemUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ2ZvbnQtc2l6ZS1hZGp1c3QnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wydmb250LXN0cmV0Y2gnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ZvbnQtc3R5bGUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ZvbnQtc3ludGhlc2lzJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiB3ZWlnaHQgc3R5bGVcbiAgd2hpdGVMaXN0Wydmb250LXZhcmlhbnQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ZvbnQtdmFyaWFudC1hbHRlcm5hdGVzJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0Wydmb250LXZhcmlhbnQtY2FwcyddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnZm9udC12YXJpYW50LWVhc3QtYXNpYW4nXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ZvbnQtdmFyaWFudC1saWdhdHVyZXMnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ZvbnQtdmFyaWFudC1udW1lcmljJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0Wydmb250LXZhcmlhbnQtcG9zaXRpb24nXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ZvbnQtd2VpZ2h0J10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0WydncmlkJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ2dyaWQtYXJlYSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydncmlkLWF1dG8tY29sdW1ucyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydncmlkLWF1dG8tZmxvdyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydncmlkLWF1dG8tcm93cyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydncmlkLWNvbHVtbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydncmlkLWNvbHVtbi1lbmQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnZ3JpZC1jb2x1bW4tc3RhcnQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnZ3JpZC1yb3cnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnZ3JpZC1yb3ctZW5kJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2dyaWQtcm93LXN0YXJ0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2dyaWQtdGVtcGxhdGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnZ3JpZC10ZW1wbGF0ZS1hcmVhcyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydncmlkLXRlbXBsYXRlLWNvbHVtbnMnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnZ3JpZC10ZW1wbGF0ZS1yb3dzJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2hhbmdpbmctcHVuY3R1YXRpb24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnaGVpZ2h0J10gPSB0cnVlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnaHlwaGVucyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1hbnVhbFxuICB3aGl0ZUxpc3RbJ2ljb24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnaW1hZ2Utb3JpZW50YXRpb24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnaW1hZ2UtcmVzb2x1dGlvbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ltZS1tb2RlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2luaXRpYWwtbGV0dGVycyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2lubGluZS1ib3gtYWxpZ24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBsYXN0XG4gIHdoaXRlTGlzdFsnanVzdGlmeS1jb250ZW50J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2p1c3RpZnktaXRlbXMnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnanVzdGlmeS1zZWxmJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2xlZnQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnbGV0dGVyLXNwYWNpbmcnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2xpZ2h0aW5nLWNvbG9yJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiB3aGl0ZVxuICB3aGl0ZUxpc3RbJ2xpbmUtYm94LWNvbnRhaW4nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBibG9jayBpbmxpbmUgcmVwbGFjZWRcbiAgd2hpdGVMaXN0WydsaW5lLWJyZWFrJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2xpbmUtZ3JpZCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1hdGNoLXBhcmVudFxuICB3aGl0ZUxpc3RbJ2xpbmUtaGVpZ2h0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnbGluZS1zbmFwJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2xpbmUtc3RhY2tpbmcnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnbGluZS1zdGFja2luZy1ydWJ5J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZXhjbHVkZS1ydWJ5XG4gIHdoaXRlTGlzdFsnbGluZS1zdGFja2luZy1zaGlmdCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGNvbnNpZGVyLXNoaWZ0c1xuICB3aGl0ZUxpc3RbJ2xpbmUtc3RhY2tpbmctc3RyYXRlZ3knXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBpbmxpbmUtbGluZS1oZWlnaHRcbiAgd2hpdGVMaXN0WydsaXN0LXN0eWxlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnbGlzdC1zdHlsZS1pbWFnZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2xpc3Qtc3R5bGUtcG9zaXRpb24nXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG91dHNpZGVcbiAgd2hpdGVMaXN0WydsaXN0LXN0eWxlLXR5cGUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRpc2NcbiAgd2hpdGVMaXN0WydtYXJnaW4nXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydtYXJnaW4tYm90dG9tJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsnbWFyZ2luLWxlZnQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0WydtYXJnaW4tcmlnaHQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0WydtYXJnaW4tdG9wJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsnbWFya2VyLW9mZnNldCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydtYXJrZXItc2lkZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGxpc3QtaXRlbVxuICB3aGl0ZUxpc3RbJ21hcmtzJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ21hc2snXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBib3JkZXItYm94XG4gIHdoaXRlTGlzdFsnbWFzay1ib3gnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBzZWUgaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnbWFzay1ib3gtb3V0c2V0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ21hc2stYm94LXJlcGVhdCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IHN0cmV0Y2hcbiAgd2hpdGVMaXN0WydtYXNrLWJveC1zbGljZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDAgZmlsbFxuICB3aGl0ZUxpc3RbJ21hc2stYm94LXNvdXJjZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydtYXNrLWJveC13aWR0aCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydtYXNrLWNsaXAnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBib3JkZXItYm94XG4gIHdoaXRlTGlzdFsnbWFzay1pbWFnZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydtYXNrLW9yaWdpbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGJvcmRlci1ib3hcbiAgd2hpdGVMaXN0WydtYXNrLXBvc2l0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogY2VudGVyXG4gIHdoaXRlTGlzdFsnbWFzay1yZXBlYXQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBuby1yZXBlYXRcbiAgd2hpdGVMaXN0WydtYXNrLXNpemUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBib3JkZXItYm94XG4gIHdoaXRlTGlzdFsnbWFzay1zb3VyY2UtdHlwZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydtYXNrLXR5cGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBsdW1pbmFuY2VcbiAgd2hpdGVMaXN0WydtYXgtaGVpZ2h0J10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnbWF4LWxpbmVzJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ21heC13aWR0aCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ21pbi1oZWlnaHQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0WydtaW4td2lkdGgnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0Wydtb3ZlLXRvJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnbmF2LWRvd24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnbmF2LWluZGV4J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ25hdi1sZWZ0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ25hdi1yaWdodCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WyduYXYtdXAnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnb2JqZWN0LWZpdCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGZpbGxcbiAgd2hpdGVMaXN0WydvYmplY3QtcG9zaXRpb24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiA1MCUgNTAlXG4gIHdoaXRlTGlzdFsnb3BhY2l0eSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDFcbiAgd2hpdGVMaXN0WydvcmRlciddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0WydvcnBoYW5zJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMlxuICB3aGl0ZUxpc3RbJ291dGxpbmUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnb3V0bGluZS1jb2xvciddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGludmVydFxuICB3aGl0ZUxpc3RbJ291dGxpbmUtb2Zmc2V0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ291dGxpbmUtc3R5bGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnb3V0bGluZS13aWR0aCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ292ZXJmbG93J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ292ZXJmbG93LXdyYXAnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0WydvdmVyZmxvdy14J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogdmlzaWJsZVxuICB3aGl0ZUxpc3RbJ292ZXJmbG93LXknXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiB2aXNpYmxlXG4gIHdoaXRlTGlzdFsncGFkZGluZyddID0gdHJ1ZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ3BhZGRpbmctYm90dG9tJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsncGFkZGluZy1sZWZ0J10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsncGFkZGluZy1yaWdodCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ3BhZGRpbmctdG9wJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsncGFnZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydwYWdlLWJyZWFrLWFmdGVyJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3BhZ2UtYnJlYWstYmVmb3JlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3BhZ2UtYnJlYWstaW5zaWRlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3BhZ2UtcG9saWN5J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogc3RhcnRcbiAgd2hpdGVMaXN0WydwYXVzZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGltcGxlbWVudGF0aW9uIGRlcGVuZGVudFxuICB3aGl0ZUxpc3RbJ3BhdXNlLWFmdGVyJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogaW1wbGVtZW50YXRpb24gZGVwZW5kZW50XG4gIHdoaXRlTGlzdFsncGF1c2UtYmVmb3JlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogaW1wbGVtZW50YXRpb24gZGVwZW5kZW50XG4gIHdoaXRlTGlzdFsncGVyc3BlY3RpdmUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsncGVyc3BlY3RpdmUtb3JpZ2luJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogNTAlIDUwJVxuICB3aGl0ZUxpc3RbJ3BpdGNoJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbWVkaXVtXG4gIHdoaXRlTGlzdFsncGl0Y2gtcmFuZ2UnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiA1MFxuICB3aGl0ZUxpc3RbJ3BsYXktZHVyaW5nJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3Bvc2l0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogc3RhdGljXG4gIHdoaXRlTGlzdFsncHJlc2VudGF0aW9uLWxldmVsJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ3F1b3RlcyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IHRleHRcbiAgd2hpdGVMaXN0WydyZWdpb24tZnJhZ21lbnQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsncmVzaXplJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ3Jlc3QnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsncmVzdC1hZnRlciddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydyZXN0LWJlZm9yZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydyaWNobmVzcyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDUwXG4gIHdoaXRlTGlzdFsncmlnaHQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsncm90YXRpb24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsncm90YXRpb24tcG9pbnQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiA1MCUgNTAlXG4gIHdoaXRlTGlzdFsncnVieS1hbGlnbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydydWJ5LW1lcmdlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogc2VwYXJhdGVcbiAgd2hpdGVMaXN0WydydWJ5LXBvc2l0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYmVmb3JlXG4gIHdoaXRlTGlzdFsnc2hhcGUtaW1hZ2UtdGhyZXNob2xkJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMC4wXG4gIHdoaXRlTGlzdFsnc2hhcGUtb3V0c2lkZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydzaGFwZS1tYXJnaW4nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsnc2l6ZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydzcGVhayddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydzcGVhay1hcyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ3NwZWFrLWhlYWRlciddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG9uY2VcbiAgd2hpdGVMaXN0WydzcGVhay1udW1lcmFsJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogY29udGludW91c1xuICB3aGl0ZUxpc3RbJ3NwZWFrLXB1bmN0dWF0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ3NwZWVjaC1yYXRlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbWVkaXVtXG4gIHdoaXRlTGlzdFsnc3RyZXNzJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogNTBcbiAgd2hpdGVMaXN0WydzdHJpbmctc2V0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ3RhYi1zaXplJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogOFxuICB3aGl0ZUxpc3RbJ3RhYmxlLWxheW91dCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wyd0ZXh0LWFsaWduJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBzdGFydFxuICB3aGl0ZUxpc3RbJ3RleHQtYWxpZ24tbGFzdCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3RleHQtY29tYmluZS11cHJpZ2h0J10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsndGV4dC1kZWNvcmF0aW9uJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsndGV4dC1kZWNvcmF0aW9uLWNvbG9yJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBjdXJyZW50Q29sb3JcbiAgd2hpdGVMaXN0Wyd0ZXh0LWRlY29yYXRpb24tbGluZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ3RleHQtZGVjb3JhdGlvbi1za2lwJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBvYmplY3RzXG4gIHdoaXRlTGlzdFsndGV4dC1kZWNvcmF0aW9uLXN0eWxlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBzb2xpZFxuICB3aGl0ZUxpc3RbJ3RleHQtZW1waGFzaXMnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0Wyd0ZXh0LWVtcGhhc2lzLWNvbG9yJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBjdXJyZW50Q29sb3JcbiAgd2hpdGVMaXN0Wyd0ZXh0LWVtcGhhc2lzLXBvc2l0aW9uJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBvdmVyIHJpZ2h0XG4gIHdoaXRlTGlzdFsndGV4dC1lbXBoYXNpcy1zdHlsZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ3RleHQtaGVpZ2h0J10gPSB0cnVlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsndGV4dC1pbmRlbnQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0Wyd0ZXh0LWp1c3RpZnknXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wyd0ZXh0LW9yaWVudGF0aW9uJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBtaXhlZFxuICB3aGl0ZUxpc3RbJ3RleHQtb3ZlcmZsb3cnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGNsaXBcbiAgd2hpdGVMaXN0Wyd0ZXh0LXNoYWRvdyddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ3RleHQtc3BhY2UtY29sbGFwc2UnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGNvbGxhcHNlXG4gIHdoaXRlTGlzdFsndGV4dC10cmFuc2Zvcm0nXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wyd0ZXh0LXVuZGVybGluZS1wb3NpdGlvbiddID0gdHJ1ZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3RleHQtd3JhcCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsndG9wJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3RyYW5zZm9ybSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wyd0cmFuc2Zvcm0tb3JpZ2luJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogNTAlIDUwJSAwXG4gIHdoaXRlTGlzdFsndHJhbnNmb3JtLXN0eWxlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZmxhdFxuICB3aGl0ZUxpc3RbJ3RyYW5zaXRpb24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsndHJhbnNpdGlvbi1kZWxheSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDBzXG4gIHdoaXRlTGlzdFsndHJhbnNpdGlvbi1kdXJhdGlvbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDBzXG4gIHdoaXRlTGlzdFsndHJhbnNpdGlvbi1wcm9wZXJ0eSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGFsbFxuICB3aGl0ZUxpc3RbJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZWFzZVxuICB3aGl0ZUxpc3RbJ3VuaWNvZGUtYmlkaSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ3ZlcnRpY2FsLWFsaWduJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYmFzZWxpbmVcbiAgd2hpdGVMaXN0Wyd2aXNpYmlsaXR5J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogdmlzaWJsZVxuICB3aGl0ZUxpc3RbJ3ZvaWNlLWJhbGFuY2UnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBjZW50ZXJcbiAgd2hpdGVMaXN0Wyd2b2ljZS1kdXJhdGlvbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wyd2b2ljZS1mYW1pbHknXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnRcbiAgd2hpdGVMaXN0Wyd2b2ljZS1waXRjaCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ3ZvaWNlLXJhbmdlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbWVkaXVtXG4gIHdoaXRlTGlzdFsndm9pY2UtcmF0ZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ3ZvaWNlLXN0cmVzcyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ3ZvaWNlLXZvbHVtZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ3ZvbHVtZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ3doaXRlLXNwYWNlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnd2lkb3dzJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMlxuICB3aGl0ZUxpc3RbJ3dpZHRoJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnd2lsbC1jaGFuZ2UnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnd29yZC1icmVhayddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnd29yZC1zcGFjaW5nJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0Wyd3b3JkLXdyYXAnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ3dyYXAtZmxvdyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wyd3cmFwLXRocm91Z2gnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiB3cmFwXG4gIHdoaXRlTGlzdFsnd3JpdGluZy1tb2RlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogaG9yaXpvbnRhbC10YlxuICB3aGl0ZUxpc3RbJ3otaW5kZXgnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG5cbiAgcmV0dXJuIHdoaXRlTGlzdDtcbn1cblxuXG4vKipcbiAqIOWMuemFjeWIsOeZveWQjeWNleS4iueahOS4gOS4quWxnuaAp+aXtlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9uQXR0ciAobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgLy8gZG8gbm90aGluZ1xufVxuXG4vKipcbiAqIOWMuemFjeWIsOS4jeWcqOeZveWQjeWNleS4iueahOS4gOS4quWxnuaAp+aXtlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9uSWdub3JlQXR0ciAobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgLy8gZG8gbm90aGluZ1xufVxuXG52YXIgUkVHRVhQX1VSTF9KQVZBU0NSSVBUID0gL2phdmFzY3JpcHRcXHMqXFw6L2ltZztcblxuLyoqXG4gKiDov4fmu6TlsZ7mgKflgLxcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNhZmVBdHRyVmFsdWUkMShuYW1lLCB2YWx1ZSkge1xuICBpZiAoUkVHRVhQX1VSTF9KQVZBU0NSSVBULnRlc3QodmFsdWUpKSByZXR1cm4gJyc7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuXG5fZGVmYXVsdC53aGl0ZUxpc3QgPSBnZXREZWZhdWx0V2hpdGVMaXN0JDEoKTtcbl9kZWZhdWx0LmdldERlZmF1bHRXaGl0ZUxpc3QgPSBnZXREZWZhdWx0V2hpdGVMaXN0JDE7XG5fZGVmYXVsdC5vbkF0dHIgPSBvbkF0dHI7XG5fZGVmYXVsdC5vbklnbm9yZUF0dHIgPSBvbklnbm9yZUF0dHI7XG5fZGVmYXVsdC5zYWZlQXR0clZhbHVlID0gc2FmZUF0dHJWYWx1ZSQxO1xuXG52YXIgdXRpbCQxID0ge1xuICBpbmRleE9mOiBmdW5jdGlvbiAoYXJyLCBpdGVtKSB7XG4gICAgdmFyIGksIGo7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICByZXR1cm4gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGogPSBhcnIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2ldID09PSBpdGVtKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0sXG4gIGZvckVhY2g6IGZ1bmN0aW9uIChhcnIsIGZuLCBzY29wZSkge1xuICAgIHZhciBpLCBqO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xuICAgICAgcmV0dXJuIGFyci5mb3JFYWNoKGZuLCBzY29wZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGogPSBhcnIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHNjb3BlLCBhcnJbaV0sIGksIGFycik7XG4gICAgfVxuICB9LFxuICB0cmltOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKFN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuICAgICAgcmV0dXJuIHN0ci50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKF5cXHMqKXwoXFxzKiQpL2csICcnKTtcbiAgfSxcbiAgdHJpbVJpZ2h0OiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKFN0cmluZy5wcm90b3R5cGUudHJpbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW1SaWdodCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhcXHMqJCkvZywgJycpO1xuICB9XG59O1xuXG4vKipcbiAqIGNzc2ZpbHRlclxuICpcbiAqIEBhdXRob3Ig6ICB6Zu3PGxlaXpvbmdtaW5AZ21haWwuY29tPlxuICovXG5cbnZhciBfJDMgPSB1dGlsJDE7XG5cblxuLyoqXG4gKiDop6PmnpBzdHlsZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQXR0ciDlpITnkIblsZ7mgKfnmoTlh73mlbBcbiAqICAg5Y+C5pWw5qC85byP77yaIGZ1bmN0aW9uIChzb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24sIG5hbWUsIHZhbHVlLCBzb3VyY2UpXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3R5bGUkMSAoY3NzLCBvbkF0dHIpIHtcbiAgY3NzID0gXyQzLnRyaW1SaWdodChjc3MpO1xuICBpZiAoY3NzW2Nzcy5sZW5ndGggLSAxXSAhPT0gJzsnKSBjc3MgKz0gJzsnO1xuICB2YXIgY3NzTGVuZ3RoID0gY3NzLmxlbmd0aDtcbiAgdmFyIGlzUGFyZW50aGVzaXNPcGVuID0gZmFsc2U7XG4gIHZhciBsYXN0UG9zID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmV0Q1NTID0gJyc7XG5cbiAgZnVuY3Rpb24gYWRkTmV3QXR0ciAoKSB7XG4gICAgLy8g5aaC5p6c5rKh5pyJ5q2j5bi455qE6Zet5ZCI5ZyG5ous5Y+377yM5YiZ55u05o6l5b+955Wl5b2T5YmN5bGe5oCnXG4gICAgaWYgKCFpc1BhcmVudGhlc2lzT3Blbikge1xuICAgICAgdmFyIHNvdXJjZSA9IF8kMy50cmltKGNzcy5zbGljZShsYXN0UG9zLCBpKSk7XG4gICAgICB2YXIgaiA9IHNvdXJjZS5pbmRleE9mKCc6Jyk7XG4gICAgICBpZiAoaiAhPT0gLTEpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfJDMudHJpbShzb3VyY2Uuc2xpY2UoMCwgaikpO1xuICAgICAgICB2YXIgdmFsdWUgPSBfJDMudHJpbShzb3VyY2Uuc2xpY2UoaiArIDEpKTtcbiAgICAgICAgLy8g5b+F6aG75pyJ5bGe5oCn5ZCN56ewXG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgdmFyIHJldCA9IG9uQXR0cihsYXN0UG9zLCByZXRDU1MubGVuZ3RoLCBuYW1lLCB2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICBpZiAocmV0KSByZXRDU1MgKz0gcmV0ICsgJzsgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsYXN0UG9zID0gaSArIDE7XG4gIH1cblxuICBmb3IgKDsgaSA8IGNzc0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBjc3NbaV07XG4gICAgaWYgKGMgPT09ICcvJyAmJiBjc3NbaSArIDFdID09PSAnKicpIHtcbiAgICAgIC8vIOWkh+azqOW8gOWni1xuICAgICAgdmFyIGogPSBjc3MuaW5kZXhPZignKi8nLCBpICsgMik7XG4gICAgICAvLyDlpoLmnpzmsqHmnInmraPluLjnmoTlpIfms6jnu5PmnZ/vvIzliJnlkI7pnaLnmoTpg6jliIblhajpg6jot7Pov4dcbiAgICAgIGlmIChqID09PSAtMSkgYnJlYWs7XG4gICAgICAvLyDnm7TmjqXlsIblvZPliY3kvY3nva7osIPliLDlpIfms6jnu5PlsL7vvIzlubbkuJTliJ3lp4vljJbnirbmgIFcbiAgICAgIGkgPSBqICsgMTtcbiAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgIGlzUGFyZW50aGVzaXNPcGVuID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjID09PSAnKCcpIHtcbiAgICAgIGlzUGFyZW50aGVzaXNPcGVuID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGMgPT09ICcpJykge1xuICAgICAgaXNQYXJlbnRoZXNpc09wZW4gPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGMgPT09ICc7Jykge1xuICAgICAgaWYgKGlzUGFyZW50aGVzaXNPcGVuKSA7IGVsc2Uge1xuICAgICAgICBhZGROZXdBdHRyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjID09PSAnXFxuJykge1xuICAgICAgYWRkTmV3QXR0cigpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfJDMudHJpbShyZXRDU1MpO1xufVxuXG52YXIgcGFyc2VyJDIgPSBwYXJzZVN0eWxlJDE7XG5cbi8qKlxuICogY3NzZmlsdGVyXG4gKlxuICogQGF1dGhvciDogIHpm7c8bGVpem9uZ21pbkBnbWFpbC5jb20+XG4gKi9cblxudmFyIERFRkFVTFQkMSA9IF9kZWZhdWx0O1xudmFyIHBhcnNlU3R5bGUgPSBwYXJzZXIkMjtcblxuXG4vKipcbiAqIOi/lOWbnuWAvOaYr+WQpuS4uuepulxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCQxIChvYmopIHtcbiAgcmV0dXJuIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpO1xufVxuXG4vKipcbiAqIOa1heaLt+i0neWvueixoVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0NvcHlPYmplY3QkMSAob2JqKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICByZXRbaV0gPSBvYmpbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiDliJvlu7pDU1Pov4fmu6TlmahcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAtIHtPYmplY3R9IHdoaXRlTGlzdFxuICogICAtIHtGdW5jdGlvbn0gb25BdHRyXG4gKiAgIC0ge0Z1bmN0aW9ufSBvbklnbm9yZUF0dHJcbiAqICAgLSB7RnVuY3Rpb259IHNhZmVBdHRyVmFsdWVcbiAqL1xuZnVuY3Rpb24gRmlsdGVyQ1NTJDIgKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IHNoYWxsb3dDb3B5T2JqZWN0JDEob3B0aW9ucyB8fCB7fSk7XG4gIG9wdGlvbnMud2hpdGVMaXN0ID0gb3B0aW9ucy53aGl0ZUxpc3QgfHwgREVGQVVMVCQxLndoaXRlTGlzdDtcbiAgb3B0aW9ucy5vbkF0dHIgPSBvcHRpb25zLm9uQXR0ciB8fCBERUZBVUxUJDEub25BdHRyO1xuICBvcHRpb25zLm9uSWdub3JlQXR0ciA9IG9wdGlvbnMub25JZ25vcmVBdHRyIHx8IERFRkFVTFQkMS5vbklnbm9yZUF0dHI7XG4gIG9wdGlvbnMuc2FmZUF0dHJWYWx1ZSA9IG9wdGlvbnMuc2FmZUF0dHJWYWx1ZSB8fCBERUZBVUxUJDEuc2FmZUF0dHJWYWx1ZTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbn1cblxuRmlsdGVyQ1NTJDIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIOWFvOWuueWQhOenjeWlh+iRqei+k+WFpVxuICBjc3MgPSBjc3MgfHwgJyc7XG4gIGNzcyA9IGNzcy50b1N0cmluZygpO1xuICBpZiAoIWNzcykgcmV0dXJuICcnO1xuXG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcbiAgdmFyIHdoaXRlTGlzdCA9IG9wdGlvbnMud2hpdGVMaXN0O1xuICB2YXIgb25BdHRyID0gb3B0aW9ucy5vbkF0dHI7XG4gIHZhciBvbklnbm9yZUF0dHIgPSBvcHRpb25zLm9uSWdub3JlQXR0cjtcbiAgdmFyIHNhZmVBdHRyVmFsdWUgPSBvcHRpb25zLnNhZmVBdHRyVmFsdWU7XG5cbiAgdmFyIHJldENTUyA9IHBhcnNlU3R5bGUoY3NzLCBmdW5jdGlvbiAoc291cmNlUG9zaXRpb24sIHBvc2l0aW9uLCBuYW1lLCB2YWx1ZSwgc291cmNlKSB7XG5cbiAgICB2YXIgY2hlY2sgPSB3aGl0ZUxpc3RbbmFtZV07XG4gICAgdmFyIGlzV2hpdGUgPSBmYWxzZTtcbiAgICBpZiAoY2hlY2sgPT09IHRydWUpIGlzV2hpdGUgPSBjaGVjaztcbiAgICBlbHNlIGlmICh0eXBlb2YgY2hlY2sgPT09ICdmdW5jdGlvbicpIGlzV2hpdGUgPSBjaGVjayh2YWx1ZSk7XG4gICAgZWxzZSBpZiAoY2hlY2sgaW5zdGFuY2VvZiBSZWdFeHApIGlzV2hpdGUgPSBjaGVjay50ZXN0KHZhbHVlKTtcbiAgICBpZiAoaXNXaGl0ZSAhPT0gdHJ1ZSkgaXNXaGl0ZSA9IGZhbHNlO1xuXG4gICAgLy8g5aaC5p6c6L+H5ruk5ZCOIHZhbHVlIOS4uuepuuWImeebtOaOpeW/veeVpVxuICAgIHZhbHVlID0gc2FmZUF0dHJWYWx1ZShuYW1lLCB2YWx1ZSk7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuXG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIGlzV2hpdGU6IGlzV2hpdGVcbiAgICB9O1xuXG4gICAgaWYgKGlzV2hpdGUpIHtcblxuICAgICAgdmFyIHJldCA9IG9uQXR0cihuYW1lLCB2YWx1ZSwgb3B0cyk7XG4gICAgICBpZiAoaXNOdWxsJDEocmV0KSkge1xuICAgICAgICByZXR1cm4gbmFtZSArICc6JyArIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHZhciByZXQgPSBvbklnbm9yZUF0dHIobmFtZSwgdmFsdWUsIG9wdHMpO1xuICAgICAgaWYgKCFpc051bGwkMShyZXQpKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXRDU1M7XG59O1xuXG5cbnZhciBjc3MgPSBGaWx0ZXJDU1MkMjtcblxuLyoqXG4gKiBjc3NmaWx0ZXJcbiAqXG4gKiBAYXV0aG9yIOiAgembtzxsZWl6b25nbWluQGdtYWlsLmNvbT5cbiAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHR2YXIgREVGQVVMVCA9IF9kZWZhdWx0O1xuXHR2YXIgRmlsdGVyQ1NTID0gY3NzO1xuXG5cblx0LyoqXG5cdCAqIFhTU+i/h+a7pFxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY3NzIOimgei/h+a7pOeahENTU+S7o+eggVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDpgInpobnvvJp3aGl0ZUxpc3QsIG9uQXR0ciwgb25JZ25vcmVBdHRyXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGZpbHRlckNTUyAoaHRtbCwgb3B0aW9ucykge1xuXHQgIHZhciB4c3MgPSBuZXcgRmlsdGVyQ1NTKG9wdGlvbnMpO1xuXHQgIHJldHVybiB4c3MucHJvY2VzcyhodG1sKTtcblx0fVxuXG5cblx0Ly8g6L6T5Ye6XG5cdGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZpbHRlckNTUztcblx0ZXhwb3J0cy5GaWx0ZXJDU1MgPSBGaWx0ZXJDU1M7XG5cdGZvciAodmFyIGkgaW4gREVGQVVMVCkgZXhwb3J0c1tpXSA9IERFRkFVTFRbaV07XG59IChsaWIsIGxpYi5leHBvcnRzKSk7XG5cbnZhciB1dGlsID0ge1xuICBpbmRleE9mOiBmdW5jdGlvbiAoYXJyLCBpdGVtKSB7XG4gICAgdmFyIGksIGo7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICByZXR1cm4gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGogPSBhcnIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2ldID09PSBpdGVtKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0sXG4gIGZvckVhY2g6IGZ1bmN0aW9uIChhcnIsIGZuLCBzY29wZSkge1xuICAgIHZhciBpLCBqO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xuICAgICAgcmV0dXJuIGFyci5mb3JFYWNoKGZuLCBzY29wZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGogPSBhcnIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHNjb3BlLCBhcnJbaV0sIGksIGFycik7XG4gICAgfVxuICB9LFxuICB0cmltOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKFN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuICAgICAgcmV0dXJuIHN0ci50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKF5cXHMqKXwoXFxzKiQpL2csIFwiXCIpO1xuICB9LFxuICBzcGFjZUluZGV4OiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIHJlZyA9IC9cXHN8XFxufFxcdC87XG4gICAgdmFyIG1hdGNoID0gcmVnLmV4ZWMoc3RyKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaC5pbmRleCA6IC0xO1xuICB9LFxufTtcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzXG4gKlxuICogQGF1dGhvciBab25nbWluIExlaTxsZWl6b25nbWluQGdtYWlsLmNvbT5cbiAqL1xuXG52YXIgRmlsdGVyQ1NTJDEgPSBsaWIuZXhwb3J0cy5GaWx0ZXJDU1M7XG52YXIgZ2V0RGVmYXVsdENTU1doaXRlTGlzdCA9IGxpYi5leHBvcnRzLmdldERlZmF1bHRXaGl0ZUxpc3Q7XG52YXIgXyQyID0gdXRpbDtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFdoaXRlTGlzdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBhOiBbXCJ0YXJnZXRcIiwgXCJocmVmXCIsIFwidGl0bGVcIl0sXG4gICAgYWJicjogW1widGl0bGVcIl0sXG4gICAgYWRkcmVzczogW10sXG4gICAgYXJlYTogW1wic2hhcGVcIiwgXCJjb29yZHNcIiwgXCJocmVmXCIsIFwiYWx0XCJdLFxuICAgIGFydGljbGU6IFtdLFxuICAgIGFzaWRlOiBbXSxcbiAgICBhdWRpbzogW1xuICAgICAgXCJhdXRvcGxheVwiLFxuICAgICAgXCJjb250cm9sc1wiLFxuICAgICAgXCJjcm9zc29yaWdpblwiLFxuICAgICAgXCJsb29wXCIsXG4gICAgICBcIm11dGVkXCIsXG4gICAgICBcInByZWxvYWRcIixcbiAgICAgIFwic3JjXCIsXG4gICAgXSxcbiAgICBiOiBbXSxcbiAgICBiZGk6IFtcImRpclwiXSxcbiAgICBiZG86IFtcImRpclwiXSxcbiAgICBiaWc6IFtdLFxuICAgIGJsb2NrcXVvdGU6IFtcImNpdGVcIl0sXG4gICAgYnI6IFtdLFxuICAgIGNhcHRpb246IFtdLFxuICAgIGNlbnRlcjogW10sXG4gICAgY2l0ZTogW10sXG4gICAgY29kZTogW10sXG4gICAgY29sOiBbXCJhbGlnblwiLCBcInZhbGlnblwiLCBcInNwYW5cIiwgXCJ3aWR0aFwiXSxcbiAgICBjb2xncm91cDogW1wiYWxpZ25cIiwgXCJ2YWxpZ25cIiwgXCJzcGFuXCIsIFwid2lkdGhcIl0sXG4gICAgZGQ6IFtdLFxuICAgIGRlbDogW1wiZGF0ZXRpbWVcIl0sXG4gICAgZGV0YWlsczogW1wib3BlblwiXSxcbiAgICBkaXY6IFtdLFxuICAgIGRsOiBbXSxcbiAgICBkdDogW10sXG4gICAgZW06IFtdLFxuICAgIGZpZ2NhcHRpb246IFtdLFxuICAgIGZpZ3VyZTogW10sXG4gICAgZm9udDogW1wiY29sb3JcIiwgXCJzaXplXCIsIFwiZmFjZVwiXSxcbiAgICBmb290ZXI6IFtdLFxuICAgIGgxOiBbXSxcbiAgICBoMjogW10sXG4gICAgaDM6IFtdLFxuICAgIGg0OiBbXSxcbiAgICBoNTogW10sXG4gICAgaDY6IFtdLFxuICAgIGhlYWRlcjogW10sXG4gICAgaHI6IFtdLFxuICAgIGk6IFtdLFxuICAgIGltZzogW1wic3JjXCIsIFwiYWx0XCIsIFwidGl0bGVcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXSxcbiAgICBpbnM6IFtcImRhdGV0aW1lXCJdLFxuICAgIGxpOiBbXSxcbiAgICBtYXJrOiBbXSxcbiAgICBuYXY6IFtdLFxuICAgIG9sOiBbXSxcbiAgICBwOiBbXSxcbiAgICBwcmU6IFtdLFxuICAgIHM6IFtdLFxuICAgIHNlY3Rpb246IFtdLFxuICAgIHNtYWxsOiBbXSxcbiAgICBzcGFuOiBbXSxcbiAgICBzdWI6IFtdLFxuICAgIHN1bW1hcnk6IFtdLFxuICAgIHN1cDogW10sXG4gICAgc3Ryb25nOiBbXSxcbiAgICBzdHJpa2U6IFtdLFxuICAgIHRhYmxlOiBbXCJ3aWR0aFwiLCBcImJvcmRlclwiLCBcImFsaWduXCIsIFwidmFsaWduXCJdLFxuICAgIHRib2R5OiBbXCJhbGlnblwiLCBcInZhbGlnblwiXSxcbiAgICB0ZDogW1wid2lkdGhcIiwgXCJyb3dzcGFuXCIsIFwiY29sc3BhblwiLCBcImFsaWduXCIsIFwidmFsaWduXCJdLFxuICAgIHRmb290OiBbXCJhbGlnblwiLCBcInZhbGlnblwiXSxcbiAgICB0aDogW1wid2lkdGhcIiwgXCJyb3dzcGFuXCIsIFwiY29sc3BhblwiLCBcImFsaWduXCIsIFwidmFsaWduXCJdLFxuICAgIHRoZWFkOiBbXCJhbGlnblwiLCBcInZhbGlnblwiXSxcbiAgICB0cjogW1wicm93c3BhblwiLCBcImFsaWduXCIsIFwidmFsaWduXCJdLFxuICAgIHR0OiBbXSxcbiAgICB1OiBbXSxcbiAgICB1bDogW10sXG4gICAgdmlkZW86IFtcbiAgICAgIFwiYXV0b3BsYXlcIixcbiAgICAgIFwiY29udHJvbHNcIixcbiAgICAgIFwiY3Jvc3NvcmlnaW5cIixcbiAgICAgIFwibG9vcFwiLFxuICAgICAgXCJtdXRlZFwiLFxuICAgICAgXCJwbGF5c2lubGluZVwiLFxuICAgICAgXCJwb3N0ZXJcIixcbiAgICAgIFwicHJlbG9hZFwiLFxuICAgICAgXCJzcmNcIixcbiAgICAgIFwiaGVpZ2h0XCIsXG4gICAgICBcIndpZHRoXCIsXG4gICAgXSxcbiAgfTtcbn1cblxudmFyIGRlZmF1bHRDU1NGaWx0ZXIgPSBuZXcgRmlsdGVyQ1NTJDEoKTtcblxuLyoqXG4gKiBkZWZhdWx0IG9uVGFnIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRhZ1xuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9uVGFnKHRhZywgaHRtbCwgb3B0aW9ucykge1xuICAvLyBkbyBub3RoaW5nXG59XG5cbi8qKlxuICogZGVmYXVsdCBvbklnbm9yZVRhZyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YWdcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBvbklnbm9yZVRhZyh0YWcsIGh0bWwsIG9wdGlvbnMpIHtcbiAgLy8gZG8gbm90aGluZ1xufVxuXG4vKipcbiAqIGRlZmF1bHQgb25UYWdBdHRyIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRhZ1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBvblRhZ0F0dHIodGFnLCBuYW1lLCB2YWx1ZSkge1xuICAvLyBkbyBub3RoaW5nXG59XG5cbi8qKlxuICogZGVmYXVsdCBvbklnbm9yZVRhZ0F0dHIgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFnXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9uSWdub3JlVGFnQXR0cih0YWcsIG5hbWUsIHZhbHVlKSB7XG4gIC8vIGRvIG5vdGhpbmdcbn1cblxuLyoqXG4gKiBkZWZhdWx0IGVzY2FwZUh0bWwgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICovXG5mdW5jdGlvbiBlc2NhcGVIdG1sKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwucmVwbGFjZShSRUdFWFBfTFQsIFwiJmx0O1wiKS5yZXBsYWNlKFJFR0VYUF9HVCwgXCImZ3Q7XCIpO1xufVxuXG4vKipcbiAqIGRlZmF1bHQgc2FmZUF0dHJWYWx1ZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YWdcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjc3NGaWx0ZXJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc2FmZUF0dHJWYWx1ZSh0YWcsIG5hbWUsIHZhbHVlLCBjc3NGaWx0ZXIpIHtcbiAgLy8gdW5lc2NhcGUgYXR0cmlidXRlIHZhbHVlIGZpcnN0bHlcbiAgdmFsdWUgPSBmcmllbmRseUF0dHJWYWx1ZSh2YWx1ZSk7XG5cbiAgaWYgKG5hbWUgPT09IFwiaHJlZlwiIHx8IG5hbWUgPT09IFwic3JjXCIpIHtcbiAgICAvLyBmaWx0ZXIgYGhyZWZgIGFuZCBgc3JjYCBhdHRyaWJ1dGVcbiAgICAvLyBvbmx5IGFsbG93IHRoZSB2YWx1ZSB0aGF0IHN0YXJ0cyB3aXRoIGBodHRwOi8vYCB8IGBodHRwczovL2AgfCBgbWFpbHRvOmAgfCBgL2AgfCBgI2BcbiAgICB2YWx1ZSA9IF8kMi50cmltKHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT09IFwiI1wiKSByZXR1cm4gXCIjXCI7XG4gICAgaWYgKFxuICAgICAgIShcbiAgICAgICAgdmFsdWUuc3Vic3RyKDAsIDcpID09PSBcImh0dHA6Ly9cIiB8fFxuICAgICAgICB2YWx1ZS5zdWJzdHIoMCwgOCkgPT09IFwiaHR0cHM6Ly9cIiB8fFxuICAgICAgICB2YWx1ZS5zdWJzdHIoMCwgNykgPT09IFwibWFpbHRvOlwiIHx8XG4gICAgICAgIHZhbHVlLnN1YnN0cigwLCA0KSA9PT0gXCJ0ZWw6XCIgfHxcbiAgICAgICAgdmFsdWUuc3Vic3RyKDAsIDExKSA9PT0gXCJkYXRhOmltYWdlL1wiIHx8XG4gICAgICAgIHZhbHVlLnN1YnN0cigwLCA2KSA9PT0gXCJmdHA6Ly9cIiB8fFxuICAgICAgICB2YWx1ZS5zdWJzdHIoMCwgMikgPT09IFwiLi9cIiB8fFxuICAgICAgICB2YWx1ZS5zdWJzdHIoMCwgMykgPT09IFwiLi4vXCIgfHxcbiAgICAgICAgdmFsdWVbMF0gPT09IFwiI1wiIHx8XG4gICAgICAgIHZhbHVlWzBdID09PSBcIi9cIlxuICAgICAgKVxuICAgICkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiYmFja2dyb3VuZFwiKSB7XG4gICAgLy8gZmlsdGVyIGBiYWNrZ3JvdW5kYCBhdHRyaWJ1dGUgKG1heWJlIG5vIHVzZSlcbiAgICAvLyBgamF2YXNjcmlwdDpgXG4gICAgUkVHRVhQX0RFRkFVTFRfT05fVEFHX0FUVFJfNC5sYXN0SW5kZXggPSAwO1xuICAgIGlmIChSRUdFWFBfREVGQVVMVF9PTl9UQUdfQVRUUl80LnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgLy8gYGV4cHJlc3Npb24oKWBcbiAgICBSRUdFWFBfREVGQVVMVF9PTl9UQUdfQVRUUl83Lmxhc3RJbmRleCA9IDA7XG4gICAgaWYgKFJFR0VYUF9ERUZBVUxUX09OX1RBR19BVFRSXzcudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvLyBgdXJsKClgXG4gICAgUkVHRVhQX0RFRkFVTFRfT05fVEFHX0FUVFJfOC5sYXN0SW5kZXggPSAwO1xuICAgIGlmIChSRUdFWFBfREVGQVVMVF9PTl9UQUdfQVRUUl84LnRlc3QodmFsdWUpKSB7XG4gICAgICBSRUdFWFBfREVGQVVMVF9PTl9UQUdfQVRUUl80Lmxhc3RJbmRleCA9IDA7XG4gICAgICBpZiAoUkVHRVhQX0RFRkFVTFRfT05fVEFHX0FUVFJfNC50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNzc0ZpbHRlciAhPT0gZmFsc2UpIHtcbiAgICAgIGNzc0ZpbHRlciA9IGNzc0ZpbHRlciB8fCBkZWZhdWx0Q1NTRmlsdGVyO1xuICAgICAgdmFsdWUgPSBjc3NGaWx0ZXIucHJvY2Vzcyh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNjYXBlIGA8PlwiYCBiZWZvcmUgcmV0dXJuc1xuICB2YWx1ZSA9IGVzY2FwZUF0dHJWYWx1ZSh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gUmVnRXhwIGxpc3RcbnZhciBSRUdFWFBfTFQgPSAvPC9nO1xudmFyIFJFR0VYUF9HVCA9IC8+L2c7XG52YXIgUkVHRVhQX1FVT1RFID0gL1wiL2c7XG52YXIgUkVHRVhQX1FVT1RFXzIgPSAvJnF1b3Q7L2c7XG52YXIgUkVHRVhQX0FUVFJfVkFMVUVfMSA9IC8mIyhbYS16QS1aMC05XSopOz8vZ2ltO1xudmFyIFJFR0VYUF9BVFRSX1ZBTFVFX0NPTE9OID0gLyZjb2xvbjs/L2dpbTtcbnZhciBSRUdFWFBfQVRUUl9WQUxVRV9ORVdMSU5FID0gLyZuZXdsaW5lOz8vZ2ltO1xuLy8gdmFyIFJFR0VYUF9ERUZBVUxUX09OX1RBR19BVFRSXzMgPSAvXFwvXFwqfFxcKlxcLy9nbTtcbnZhciBSRUdFWFBfREVGQVVMVF9PTl9UQUdfQVRUUl80ID1cbiAgLygoalxccyphXFxzKnZcXHMqYXx2XFxzKmJ8bFxccyppXFxzKnZcXHMqZSlcXHMqc1xccypjXFxzKnJcXHMqaVxccypwXFxzKnRcXHMqfG1cXHMqb1xccypjXFxzKmhcXHMqYSk6L2dpO1xuLy8gdmFyIFJFR0VYUF9ERUZBVUxUX09OX1RBR19BVFRSXzUgPSAvXltcXHNcIidgXSooZFxccyphXFxzKnRcXHMqYVxccyopXFw6L2dpO1xuLy8gdmFyIFJFR0VYUF9ERUZBVUxUX09OX1RBR19BVFRSXzYgPSAvXltcXHNcIidgXSooZFxccyphXFxzKnRcXHMqYVxccyopXFw6XFxzKmltYWdlXFwvL2dpO1xudmFyIFJFR0VYUF9ERUZBVUxUX09OX1RBR19BVFRSXzcgPVxuICAvZVxccyp4XFxzKnBcXHMqclxccyplXFxzKnNcXHMqc1xccyppXFxzKm9cXHMqblxccypcXCguKi9naTtcbnZhciBSRUdFWFBfREVGQVVMVF9PTl9UQUdfQVRUUl84ID0gL3VcXHMqclxccypsXFxzKlxcKC4qL2dpO1xuXG4vKipcbiAqIGVzY2FwZSBkb3VibGUgcXVvdGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiBlc2NhcGVRdW90ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR0VYUF9RVU9URSwgXCImcXVvdDtcIik7XG59XG5cbi8qKlxuICogdW5lc2NhcGUgZG91YmxlIHF1b3RlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGVRdW90ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR0VYUF9RVU9URV8yLCAnXCInKTtcbn1cblxuLyoqXG4gKiBlc2NhcGUgaHRtbCBlbnRpdGllc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlSHRtbEVudGl0aWVzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoUkVHRVhQX0FUVFJfVkFMVUVfMSwgZnVuY3Rpb24gcmVwbGFjZVVuaWNvZGUoc3RyLCBjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGVbMF0gPT09IFwieFwiIHx8IGNvZGVbMF0gPT09IFwiWFwiXG4gICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoY29kZS5zdWJzdHIoMSksIDE2KSlcbiAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjb2RlLCAxMCkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBlc2NhcGUgaHRtbDUgbmV3IGRhbmdlciBlbnRpdGllc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlRGFuZ2VySHRtbDVFbnRpdGllcyhzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKFJFR0VYUF9BVFRSX1ZBTFVFX0NPTE9OLCBcIjpcIilcbiAgICAucmVwbGFjZShSRUdFWFBfQVRUUl9WQUxVRV9ORVdMSU5FLCBcIiBcIik7XG59XG5cbi8qKlxuICogY2xlYXIgbm9ucHJpbnRhYmxlIGNoYXJhY3RlcnNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNsZWFyTm9uUHJpbnRhYmxlQ2hhcmFjdGVyKHN0cikge1xuICB2YXIgc3RyMiA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzdHIyICs9IHN0ci5jaGFyQ29kZUF0KGkpIDwgMzIgPyBcIiBcIiA6IHN0ci5jaGFyQXQoaSk7XG4gIH1cbiAgcmV0dXJuIF8kMi50cmltKHN0cjIpO1xufVxuXG4vKipcbiAqIGdldCBmcmllbmRseSBhdHRyaWJ1dGUgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZyaWVuZGx5QXR0clZhbHVlKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZVF1b3RlKHN0cik7XG4gIHN0ciA9IGVzY2FwZUh0bWxFbnRpdGllcyhzdHIpO1xuICBzdHIgPSBlc2NhcGVEYW5nZXJIdG1sNUVudGl0aWVzKHN0cik7XG4gIHN0ciA9IGNsZWFyTm9uUHJpbnRhYmxlQ2hhcmFjdGVyKHN0cik7XG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogdW5lc2NhcGUgYXR0cmlidXRlIHZhbHVlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVBdHRyVmFsdWUoc3RyKSB7XG4gIHN0ciA9IGVzY2FwZVF1b3RlKHN0cik7XG4gIHN0ciA9IGVzY2FwZUh0bWwoc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBgb25JZ25vcmVUYWdgIGZ1bmN0aW9uIGZvciByZW1vdmluZyBhbGwgdGhlIHRhZ3MgdGhhdCBhcmUgbm90IGluIHdoaXRlbGlzdFxuICovXG5mdW5jdGlvbiBvbklnbm9yZVRhZ1N0cmlwQWxsKCkge1xuICByZXR1cm4gXCJcIjtcbn1cblxuLyoqXG4gKiByZW1vdmUgdGFnIGJvZHlcbiAqIHNwZWNpZnkgYSBgdGFnc2AgbGlzdCwgaWYgdGhlIHRhZyBpcyBub3QgaW4gdGhlIGB0YWdzYCBsaXN0IHRoZW4gcHJvY2VzcyBieSB0aGUgc3BlY2lmeSBmdW5jdGlvbiAob3B0aW9uYWwpXG4gKlxuICogQHBhcmFtIHthcnJheX0gdGFnc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gbmV4dFxuICovXG5mdW5jdGlvbiBTdHJpcFRhZ0JvZHkodGFncywgbmV4dCkge1xuICBpZiAodHlwZW9mIG5leHQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIG5leHQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIHZhciBpc1JlbW92ZUFsbFRhZyA9ICFBcnJheS5pc0FycmF5KHRhZ3MpO1xuICBmdW5jdGlvbiBpc1JlbW92ZVRhZyh0YWcpIHtcbiAgICBpZiAoaXNSZW1vdmVBbGxUYWcpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBfJDIuaW5kZXhPZih0YWdzLCB0YWcpICE9PSAtMTtcbiAgfVxuXG4gIHZhciByZW1vdmVMaXN0ID0gW107XG4gIHZhciBwb3NTdGFydCA9IGZhbHNlO1xuXG4gIHJldHVybiB7XG4gICAgb25JZ25vcmVUYWc6IGZ1bmN0aW9uICh0YWcsIGh0bWwsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChpc1JlbW92ZVRhZyh0YWcpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlzQ2xvc2luZykge1xuICAgICAgICAgIHZhciByZXQgPSBcIlsvcmVtb3ZlZF1cIjtcbiAgICAgICAgICB2YXIgZW5kID0gb3B0aW9ucy5wb3NpdGlvbiArIHJldC5sZW5ndGg7XG4gICAgICAgICAgcmVtb3ZlTGlzdC5wdXNoKFtcbiAgICAgICAgICAgIHBvc1N0YXJ0ICE9PSBmYWxzZSA/IHBvc1N0YXJ0IDogb3B0aW9ucy5wb3NpdGlvbixcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBwb3NTdGFydCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFwb3NTdGFydCkge1xuICAgICAgICAgICAgcG9zU3RhcnQgPSBvcHRpb25zLnBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJbcmVtb3ZlZF1cIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5leHQodGFnLCBodG1sLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgIHZhciByZXRodG1sID0gXCJcIjtcbiAgICAgIHZhciBsYXN0UG9zID0gMDtcbiAgICAgIF8kMi5mb3JFYWNoKHJlbW92ZUxpc3QsIGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0aHRtbCArPSBodG1sLnNsaWNlKGxhc3RQb3MsIHBvc1swXSk7XG4gICAgICAgIGxhc3RQb3MgPSBwb3NbMV07XG4gICAgICB9KTtcbiAgICAgIHJldGh0bWwgKz0gaHRtbC5zbGljZShsYXN0UG9zKTtcbiAgICAgIHJldHVybiByZXRodG1sO1xuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogcmVtb3ZlIGh0bWwgY29tbWVudHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpcENvbW1lbnRUYWcoaHRtbCkge1xuICB2YXIgcmV0SHRtbCA9IFwiXCI7XG4gIHZhciBsYXN0UG9zID0gMDtcbiAgd2hpbGUgKGxhc3RQb3MgPCBodG1sLmxlbmd0aCkge1xuICAgIHZhciBpID0gaHRtbC5pbmRleE9mKFwiPCEtLVwiLCBsYXN0UG9zKTtcbiAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgIHJldEh0bWwgKz0gaHRtbC5zbGljZShsYXN0UG9zKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXRIdG1sICs9IGh0bWwuc2xpY2UobGFzdFBvcywgaSk7XG4gICAgdmFyIGogPSBodG1sLmluZGV4T2YoXCItLT5cIiwgaSk7XG4gICAgaWYgKGogPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGFzdFBvcyA9IGogKyAzO1xuICB9XG4gIHJldHVybiByZXRIdG1sO1xufVxuXG4vKipcbiAqIHJlbW92ZSBpbnZpc2libGUgY2hhcmFjdGVyc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cmlwQmxhbmtDaGFyKGh0bWwpIHtcbiAgdmFyIGNoYXJzID0gaHRtbC5zcGxpdChcIlwiKTtcbiAgY2hhcnMgPSBjaGFycy5maWx0ZXIoZnVuY3Rpb24gKGNoYXIpIHtcbiAgICB2YXIgYyA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoYyA9PT0gMTI3KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGMgPD0gMzEpIHtcbiAgICAgIGlmIChjID09PSAxMCB8fCBjID09PSAxMykgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7XG59XG5cbl9kZWZhdWx0JDEud2hpdGVMaXN0ID0gZ2V0RGVmYXVsdFdoaXRlTGlzdCgpO1xuX2RlZmF1bHQkMS5nZXREZWZhdWx0V2hpdGVMaXN0ID0gZ2V0RGVmYXVsdFdoaXRlTGlzdDtcbl9kZWZhdWx0JDEub25UYWcgPSBvblRhZztcbl9kZWZhdWx0JDEub25JZ25vcmVUYWcgPSBvbklnbm9yZVRhZztcbl9kZWZhdWx0JDEub25UYWdBdHRyID0gb25UYWdBdHRyO1xuX2RlZmF1bHQkMS5vbklnbm9yZVRhZ0F0dHIgPSBvbklnbm9yZVRhZ0F0dHI7XG5fZGVmYXVsdCQxLnNhZmVBdHRyVmFsdWUgPSBzYWZlQXR0clZhbHVlO1xuX2RlZmF1bHQkMS5lc2NhcGVIdG1sID0gZXNjYXBlSHRtbDtcbl9kZWZhdWx0JDEuZXNjYXBlUXVvdGUgPSBlc2NhcGVRdW90ZTtcbl9kZWZhdWx0JDEudW5lc2NhcGVRdW90ZSA9IHVuZXNjYXBlUXVvdGU7XG5fZGVmYXVsdCQxLmVzY2FwZUh0bWxFbnRpdGllcyA9IGVzY2FwZUh0bWxFbnRpdGllcztcbl9kZWZhdWx0JDEuZXNjYXBlRGFuZ2VySHRtbDVFbnRpdGllcyA9IGVzY2FwZURhbmdlckh0bWw1RW50aXRpZXM7XG5fZGVmYXVsdCQxLmNsZWFyTm9uUHJpbnRhYmxlQ2hhcmFjdGVyID0gY2xlYXJOb25QcmludGFibGVDaGFyYWN0ZXI7XG5fZGVmYXVsdCQxLmZyaWVuZGx5QXR0clZhbHVlID0gZnJpZW5kbHlBdHRyVmFsdWU7XG5fZGVmYXVsdCQxLmVzY2FwZUF0dHJWYWx1ZSA9IGVzY2FwZUF0dHJWYWx1ZTtcbl9kZWZhdWx0JDEub25JZ25vcmVUYWdTdHJpcEFsbCA9IG9uSWdub3JlVGFnU3RyaXBBbGw7XG5fZGVmYXVsdCQxLlN0cmlwVGFnQm9keSA9IFN0cmlwVGFnQm9keTtcbl9kZWZhdWx0JDEuc3RyaXBDb21tZW50VGFnID0gc3RyaXBDb21tZW50VGFnO1xuX2RlZmF1bHQkMS5zdHJpcEJsYW5rQ2hhciA9IHN0cmlwQmxhbmtDaGFyO1xuX2RlZmF1bHQkMS5jc3NGaWx0ZXIgPSBkZWZhdWx0Q1NTRmlsdGVyO1xuX2RlZmF1bHQkMS5nZXREZWZhdWx0Q1NTV2hpdGVMaXN0ID0gZ2V0RGVmYXVsdENTU1doaXRlTGlzdDtcblxudmFyIHBhcnNlciQxID0ge307XG5cbi8qKlxuICogU2ltcGxlIEhUTUwgUGFyc2VyXG4gKlxuICogQGF1dGhvciBab25nbWluIExlaTxsZWl6b25nbWluQGdtYWlsLmNvbT5cbiAqL1xuXG52YXIgXyQxID0gdXRpbDtcblxuLyoqXG4gKiBnZXQgdGFnIG5hbWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBlLmcuICc8YSBoZWY9XCIjXCI+J1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRUYWdOYW1lKGh0bWwpIHtcbiAgdmFyIGkgPSBfJDEuc3BhY2VJbmRleChodG1sKTtcbiAgdmFyIHRhZ05hbWU7XG4gIGlmIChpID09PSAtMSkge1xuICAgIHRhZ05hbWUgPSBodG1sLnNsaWNlKDEsIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB0YWdOYW1lID0gaHRtbC5zbGljZSgxLCBpICsgMSk7XG4gIH1cbiAgdGFnTmFtZSA9IF8kMS50cmltKHRhZ05hbWUpLnRvTG93ZXJDYXNlKCk7XG4gIGlmICh0YWdOYW1lLnNsaWNlKDAsIDEpID09PSBcIi9cIikgdGFnTmFtZSA9IHRhZ05hbWUuc2xpY2UoMSk7XG4gIGlmICh0YWdOYW1lLnNsaWNlKC0xKSA9PT0gXCIvXCIpIHRhZ05hbWUgPSB0YWdOYW1lLnNsaWNlKDAsIC0xKTtcbiAgcmV0dXJuIHRhZ05hbWU7XG59XG5cbi8qKlxuICogaXMgY2xvc2UgdGFnP1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIOWmgu+8mic8YSBoZWY9XCIjXCI+J1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDbG9zaW5nKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwuc2xpY2UoMCwgMikgPT09IFwiPC9cIjtcbn1cblxuLyoqXG4gKiBwYXJzZSBpbnB1dCBodG1sIGFuZCByZXR1cm5zIHByb2Nlc3NlZCBodG1sXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uVGFnIGUuZy4gZnVuY3Rpb24gKHNvdXJjZVBvc2l0aW9uLCBwb3NpdGlvbiwgdGFnLCBodG1sLCBpc0Nsb3NpbmcpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlc2NhcGVIdG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGFnJDEoaHRtbCwgb25UYWcsIGVzY2FwZUh0bWwpIHtcblxuICB2YXIgcmV0aHRtbCA9IFwiXCI7XG4gIHZhciBsYXN0UG9zID0gMDtcbiAgdmFyIHRhZ1N0YXJ0ID0gZmFsc2U7XG4gIHZhciBxdW90ZVN0YXJ0ID0gZmFsc2U7XG4gIHZhciBjdXJyZW50UG9zID0gMDtcbiAgdmFyIGxlbiA9IGh0bWwubGVuZ3RoO1xuICB2YXIgY3VycmVudFRhZ05hbWUgPSBcIlwiO1xuICB2YXIgY3VycmVudEh0bWwgPSBcIlwiO1xuXG4gIGNoYXJpdGVyYXRvcjogZm9yIChjdXJyZW50UG9zID0gMDsgY3VycmVudFBvcyA8IGxlbjsgY3VycmVudFBvcysrKSB7XG4gICAgdmFyIGMgPSBodG1sLmNoYXJBdChjdXJyZW50UG9zKTtcbiAgICBpZiAodGFnU3RhcnQgPT09IGZhbHNlKSB7XG4gICAgICBpZiAoYyA9PT0gXCI8XCIpIHtcbiAgICAgICAgdGFnU3RhcnQgPSBjdXJyZW50UG9zO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHF1b3RlU3RhcnQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChjID09PSBcIjxcIikge1xuICAgICAgICAgIHJldGh0bWwgKz0gZXNjYXBlSHRtbChodG1sLnNsaWNlKGxhc3RQb3MsIGN1cnJlbnRQb3MpKTtcbiAgICAgICAgICB0YWdTdGFydCA9IGN1cnJlbnRQb3M7XG4gICAgICAgICAgbGFzdFBvcyA9IGN1cnJlbnRQb3M7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgcmV0aHRtbCArPSBlc2NhcGVIdG1sKGh0bWwuc2xpY2UobGFzdFBvcywgdGFnU3RhcnQpKTtcbiAgICAgICAgICBjdXJyZW50SHRtbCA9IGh0bWwuc2xpY2UodGFnU3RhcnQsIGN1cnJlbnRQb3MgKyAxKTtcbiAgICAgICAgICBjdXJyZW50VGFnTmFtZSA9IGdldFRhZ05hbWUoY3VycmVudEh0bWwpO1xuICAgICAgICAgIHJldGh0bWwgKz0gb25UYWcoXG4gICAgICAgICAgICB0YWdTdGFydCxcbiAgICAgICAgICAgIHJldGh0bWwubGVuZ3RoLFxuICAgICAgICAgICAgY3VycmVudFRhZ05hbWUsXG4gICAgICAgICAgICBjdXJyZW50SHRtbCxcbiAgICAgICAgICAgIGlzQ2xvc2luZyhjdXJyZW50SHRtbClcbiAgICAgICAgICApO1xuICAgICAgICAgIGxhc3RQb3MgPSBjdXJyZW50UG9zICsgMTtcbiAgICAgICAgICB0YWdTdGFydCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSAnXCInIHx8IGMgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICAgIHZhciBpYyA9IGh0bWwuY2hhckF0KGN1cnJlbnRQb3MgLSBpKTtcblxuICAgICAgICAgIHdoaWxlIChpYy50cmltKCkgPT09IFwiXCIgfHwgaWMgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICBpZiAoaWMgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgIHF1b3RlU3RhcnQgPSBjO1xuICAgICAgICAgICAgICBjb250aW51ZSBjaGFyaXRlcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpYyA9IGh0bWwuY2hhckF0KGN1cnJlbnRQb3MgLSArK2kpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGMgPT09IHF1b3RlU3RhcnQpIHtcbiAgICAgICAgICBxdW90ZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGxhc3RQb3MgPCBodG1sLmxlbmd0aCkge1xuICAgIHJldGh0bWwgKz0gZXNjYXBlSHRtbChodG1sLnN1YnN0cihsYXN0UG9zKSk7XG4gIH1cblxuICByZXR1cm4gcmV0aHRtbDtcbn1cblxudmFyIFJFR0VYUF9JTExFR0FMX0FUVFJfTkFNRSA9IC9bXmEtekEtWjAtOVxcXFxfOi4tXS9naW07XG5cbi8qKlxuICogcGFyc2UgaW5wdXQgYXR0cmlidXRlcyBhbmQgcmV0dXJucyBwcm9jZXNzZWQgYXR0cmlidXRlc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIGUuZy4gYGhyZWY9XCIjXCIgdGFyZ2V0PVwiX2JsYW5rXCJgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkF0dHIgZS5nLiBgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKWBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcGFyc2VBdHRyJDEoaHRtbCwgb25BdHRyKSB7XG5cbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgbGFzdE1hcmtQb3MgPSAwO1xuICB2YXIgcmV0QXR0cnMgPSBbXTtcbiAgdmFyIHRtcE5hbWUgPSBmYWxzZTtcbiAgdmFyIGxlbiA9IGh0bWwubGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGFkZEF0dHIobmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gXyQxLnRyaW0obmFtZSk7XG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShSRUdFWFBfSUxMRUdBTF9BVFRSX05BTUUsIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG5hbWUubGVuZ3RoIDwgMSkgcmV0dXJuO1xuICAgIHZhciByZXQgPSBvbkF0dHIobmFtZSwgdmFsdWUgfHwgXCJcIik7XG4gICAgaWYgKHJldCkgcmV0QXR0cnMucHVzaChyZXQpO1xuICB9XG5cbiAgLy8g6YCQ5Liq5YiG5p6Q5a2X56ymXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGh0bWwuY2hhckF0KGkpO1xuICAgIHZhciB2LCBqO1xuICAgIGlmICh0bXBOYW1lID09PSBmYWxzZSAmJiBjID09PSBcIj1cIikge1xuICAgICAgdG1wTmFtZSA9IGh0bWwuc2xpY2UobGFzdFBvcywgaSk7XG4gICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICBsYXN0TWFya1BvcyA9IGh0bWwuY2hhckF0KGxhc3RQb3MpID09PSAnXCInIHx8IGh0bWwuY2hhckF0KGxhc3RQb3MpID09PSBcIidcIiA/IGxhc3RQb3MgOiBmaW5kTmV4dFF1b3RhdGlvbk1hcmsoaHRtbCwgaSArIDEpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0bXBOYW1lICE9PSBmYWxzZSkge1xuICAgICAgaWYgKFxuICAgICAgICBpID09PSBsYXN0TWFya1Bvc1xuICAgICAgKSB7XG4gICAgICAgIGogPSBodG1sLmluZGV4T2YoYywgaSArIDEpO1xuICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ID0gXyQxLnRyaW0oaHRtbC5zbGljZShsYXN0TWFya1BvcyArIDEsIGopKTtcbiAgICAgICAgICBhZGRBdHRyKHRtcE5hbWUsIHYpO1xuICAgICAgICAgIHRtcE5hbWUgPSBmYWxzZTtcbiAgICAgICAgICBpID0gajtcbiAgICAgICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKC9cXHN8XFxufFxcdC8udGVzdChjKSkge1xuICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXFxzfFxcbnxcXHQvZywgXCIgXCIpO1xuICAgICAgaWYgKHRtcE5hbWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGogPSBmaW5kTmV4dEVxdWFsKGh0bWwsIGkpO1xuICAgICAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgICB2ID0gXyQxLnRyaW0oaHRtbC5zbGljZShsYXN0UG9zLCBpKSk7XG4gICAgICAgICAgYWRkQXR0cih2KTtcbiAgICAgICAgICB0bXBOYW1lID0gZmFsc2U7XG4gICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkgPSBqIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaiA9IGZpbmRCZWZvcmVFcXVhbChodG1sLCBpIC0gMSk7XG4gICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgIHYgPSBfJDEudHJpbShodG1sLnNsaWNlKGxhc3RQb3MsIGkpKTtcbiAgICAgICAgICB2ID0gc3RyaXBRdW90ZVdyYXAodik7XG4gICAgICAgICAgYWRkQXR0cih0bXBOYW1lLCB2KTtcbiAgICAgICAgICB0bXBOYW1lID0gZmFsc2U7XG4gICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhc3RQb3MgPCBodG1sLmxlbmd0aCkge1xuICAgIGlmICh0bXBOYW1lID09PSBmYWxzZSkge1xuICAgICAgYWRkQXR0cihodG1sLnNsaWNlKGxhc3RQb3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQXR0cih0bXBOYW1lLCBzdHJpcFF1b3RlV3JhcChfJDEudHJpbShodG1sLnNsaWNlKGxhc3RQb3MpKSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfJDEudHJpbShyZXRBdHRycy5qb2luKFwiIFwiKSk7XG59XG5cbmZ1bmN0aW9uIGZpbmROZXh0RXF1YWwoc3RyLCBpKSB7XG4gIGZvciAoOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBzdHJbaV07XG4gICAgaWYgKGMgPT09IFwiIFwiKSBjb250aW51ZTtcbiAgICBpZiAoYyA9PT0gXCI9XCIpIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kTmV4dFF1b3RhdGlvbk1hcmsoc3RyLCBpKSB7XG4gIGZvciAoOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBzdHJbaV07XG4gICAgaWYgKGMgPT09IFwiIFwiKSBjb250aW51ZTtcbiAgICBpZiAoYyA9PT0gXCInXCIgfHwgYyA9PT0gJ1wiJykgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRCZWZvcmVFcXVhbChzdHIsIGkpIHtcbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IHN0cltpXTtcbiAgICBpZiAoYyA9PT0gXCIgXCIpIGNvbnRpbnVlO1xuICAgIGlmIChjID09PSBcIj1cIikgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzUXVvdGVXcmFwU3RyaW5nKHRleHQpIHtcbiAgaWYgKFxuICAgICh0ZXh0WzBdID09PSAnXCInICYmIHRleHRbdGV4dC5sZW5ndGggLSAxXSA9PT0gJ1wiJykgfHxcbiAgICAodGV4dFswXSA9PT0gXCInXCIgJiYgdGV4dFt0ZXh0Lmxlbmd0aCAtIDFdID09PSBcIidcIilcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwUXVvdGVXcmFwKHRleHQpIHtcbiAgaWYgKGlzUXVvdGVXcmFwU3RyaW5nKHRleHQpKSB7XG4gICAgcmV0dXJuIHRleHQuc3Vic3RyKDEsIHRleHQubGVuZ3RoIC0gMik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbn1cblxucGFyc2VyJDEucGFyc2VUYWcgPSBwYXJzZVRhZyQxO1xucGFyc2VyJDEucGFyc2VBdHRyID0gcGFyc2VBdHRyJDE7XG5cbi8qKlxuICogZmlsdGVyIHhzc1xuICpcbiAqIEBhdXRob3IgWm9uZ21pbiBMZWk8bGVpem9uZ21pbkBnbWFpbC5jb20+XG4gKi9cblxudmFyIEZpbHRlckNTUyA9IGxpYi5leHBvcnRzLkZpbHRlckNTUztcbnZhciBERUZBVUxUID0gX2RlZmF1bHQkMTtcbnZhciBwYXJzZXIgPSBwYXJzZXIkMTtcbnZhciBwYXJzZVRhZyA9IHBhcnNlci5wYXJzZVRhZztcbnZhciBwYXJzZUF0dHIgPSBwYXJzZXIucGFyc2VBdHRyO1xudmFyIF8gPSB1dGlsO1xuXG4vKipcbiAqIHJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bGwob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGw7XG59XG5cbi8qKlxuICogZ2V0IGF0dHJpYnV0ZXMgZm9yIGEgdGFnXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgLSB7U3RyaW5nfSBodG1sXG4gKiAgIC0ge0Jvb2xlYW59IGNsb3NpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cnMoaHRtbCkge1xuICB2YXIgaSA9IF8uc3BhY2VJbmRleChodG1sKTtcbiAgaWYgKGkgPT09IC0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGh0bWw6IFwiXCIsXG4gICAgICBjbG9zaW5nOiBodG1sW2h0bWwubGVuZ3RoIC0gMl0gPT09IFwiL1wiLFxuICAgIH07XG4gIH1cbiAgaHRtbCA9IF8udHJpbShodG1sLnNsaWNlKGkgKyAxLCAtMSkpO1xuICB2YXIgaXNDbG9zaW5nID0gaHRtbFtodG1sLmxlbmd0aCAtIDFdID09PSBcIi9cIjtcbiAgaWYgKGlzQ2xvc2luZykgaHRtbCA9IF8udHJpbShodG1sLnNsaWNlKDAsIC0xKSk7XG4gIHJldHVybiB7XG4gICAgaHRtbDogaHRtbCxcbiAgICBjbG9zaW5nOiBpc0Nsb3NpbmcsXG4gIH07XG59XG5cbi8qKlxuICogc2hhbGxvdyBjb3B5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBzaGFsbG93Q29weU9iamVjdChvYmopIHtcbiAgdmFyIHJldCA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIHJldFtpXSA9IG9ialtpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBrZXlzVG9Mb3dlckNhc2Uob2JqKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpbaV0pKSB7XG4gICAgICByZXRbaS50b0xvd2VyQ2FzZSgpXSA9IG9ialtpXS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udG9Mb3dlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRbaS50b0xvd2VyQ2FzZSgpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBGaWx0ZXJYU1MgY2xhc3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgIHdoaXRlTGlzdCAob3IgYWxsb3dMaXN0KSwgb25UYWcsIG9uVGFnQXR0ciwgb25JZ25vcmVUYWcsXG4gKiAgICAgICAgb25JZ25vcmVUYWdBdHRyLCBzYWZlQXR0clZhbHVlLCBlc2NhcGVIdG1sXG4gKiAgICAgICAgc3RyaXBJZ25vcmVUYWdCb2R5LCBhbGxvd0NvbW1lbnRUYWcsIHN0cmlwQmxhbmtDaGFyXG4gKiAgICAgICAgY3Nze3doaXRlTGlzdCwgb25BdHRyLCBvbklnbm9yZUF0dHJ9IGBjc3M9ZmFsc2VgIG1lYW5zIGRvbid0IHVzZSBgY3NzZmlsdGVyYFxuICovXG5mdW5jdGlvbiBGaWx0ZXJYU1Mob3B0aW9ucykge1xuICBvcHRpb25zID0gc2hhbGxvd0NvcHlPYmplY3Qob3B0aW9ucyB8fCB7fSk7XG5cbiAgaWYgKG9wdGlvbnMuc3RyaXBJZ25vcmVUYWcpIHtcbiAgICBpZiAob3B0aW9ucy5vbklnbm9yZVRhZykge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ05vdGVzOiBjYW5ub3QgdXNlIHRoZXNlIHR3byBvcHRpb25zIFwic3RyaXBJZ25vcmVUYWdcIiBhbmQgXCJvbklnbm9yZVRhZ1wiIGF0IHRoZSBzYW1lIHRpbWUnXG4gICAgICApO1xuICAgIH1cbiAgICBvcHRpb25zLm9uSWdub3JlVGFnID0gREVGQVVMVC5vbklnbm9yZVRhZ1N0cmlwQWxsO1xuICB9XG4gIGlmIChvcHRpb25zLndoaXRlTGlzdCB8fCBvcHRpb25zLmFsbG93TGlzdCkge1xuICAgIG9wdGlvbnMud2hpdGVMaXN0ID0ga2V5c1RvTG93ZXJDYXNlKG9wdGlvbnMud2hpdGVMaXN0IHx8IG9wdGlvbnMuYWxsb3dMaXN0KTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLndoaXRlTGlzdCA9IERFRkFVTFQud2hpdGVMaXN0O1xuICB9XG5cbiAgb3B0aW9ucy5vblRhZyA9IG9wdGlvbnMub25UYWcgfHwgREVGQVVMVC5vblRhZztcbiAgb3B0aW9ucy5vblRhZ0F0dHIgPSBvcHRpb25zLm9uVGFnQXR0ciB8fCBERUZBVUxULm9uVGFnQXR0cjtcbiAgb3B0aW9ucy5vbklnbm9yZVRhZyA9IG9wdGlvbnMub25JZ25vcmVUYWcgfHwgREVGQVVMVC5vbklnbm9yZVRhZztcbiAgb3B0aW9ucy5vbklnbm9yZVRhZ0F0dHIgPSBvcHRpb25zLm9uSWdub3JlVGFnQXR0ciB8fCBERUZBVUxULm9uSWdub3JlVGFnQXR0cjtcbiAgb3B0aW9ucy5zYWZlQXR0clZhbHVlID0gb3B0aW9ucy5zYWZlQXR0clZhbHVlIHx8IERFRkFVTFQuc2FmZUF0dHJWYWx1ZTtcbiAgb3B0aW9ucy5lc2NhcGVIdG1sID0gb3B0aW9ucy5lc2NhcGVIdG1sIHx8IERFRkFVTFQuZXNjYXBlSHRtbDtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICBpZiAob3B0aW9ucy5jc3MgPT09IGZhbHNlKSB7XG4gICAgdGhpcy5jc3NGaWx0ZXIgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmNzcyA9IG9wdGlvbnMuY3NzIHx8IHt9O1xuICAgIHRoaXMuY3NzRmlsdGVyID0gbmV3IEZpbHRlckNTUyhvcHRpb25zLmNzcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBzdGFydCBwcm9jZXNzIGFuZCByZXR1cm5zIHJlc3VsdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbkZpbHRlclhTUy5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChodG1sKSB7XG4gIC8vIGNvbXBhdGlibGUgd2l0aCB0aGUgaW5wdXRcbiAgaHRtbCA9IGh0bWwgfHwgXCJcIjtcbiAgaHRtbCA9IGh0bWwudG9TdHJpbmcoKTtcbiAgaWYgKCFodG1sKSByZXR1cm4gXCJcIjtcblxuICB2YXIgbWUgPSB0aGlzO1xuICB2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gIHZhciB3aGl0ZUxpc3QgPSBvcHRpb25zLndoaXRlTGlzdDtcbiAgdmFyIG9uVGFnID0gb3B0aW9ucy5vblRhZztcbiAgdmFyIG9uSWdub3JlVGFnID0gb3B0aW9ucy5vbklnbm9yZVRhZztcbiAgdmFyIG9uVGFnQXR0ciA9IG9wdGlvbnMub25UYWdBdHRyO1xuICB2YXIgb25JZ25vcmVUYWdBdHRyID0gb3B0aW9ucy5vbklnbm9yZVRhZ0F0dHI7XG4gIHZhciBzYWZlQXR0clZhbHVlID0gb3B0aW9ucy5zYWZlQXR0clZhbHVlO1xuICB2YXIgZXNjYXBlSHRtbCA9IG9wdGlvbnMuZXNjYXBlSHRtbDtcbiAgdmFyIGNzc0ZpbHRlciA9IG1lLmNzc0ZpbHRlcjtcblxuICAvLyByZW1vdmUgaW52aXNpYmxlIGNoYXJhY3RlcnNcbiAgaWYgKG9wdGlvbnMuc3RyaXBCbGFua0NoYXIpIHtcbiAgICBodG1sID0gREVGQVVMVC5zdHJpcEJsYW5rQ2hhcihodG1sKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBodG1sIGNvbW1lbnRzXG4gIGlmICghb3B0aW9ucy5hbGxvd0NvbW1lbnRUYWcpIHtcbiAgICBodG1sID0gREVGQVVMVC5zdHJpcENvbW1lbnRUYWcoaHRtbCk7XG4gIH1cblxuICAvLyBpZiBlbmFibGUgc3RyaXBJZ25vcmVUYWdCb2R5XG4gIHZhciBzdHJpcElnbm9yZVRhZ0JvZHkgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMuc3RyaXBJZ25vcmVUYWdCb2R5KSB7XG4gICAgc3RyaXBJZ25vcmVUYWdCb2R5ID0gREVGQVVMVC5TdHJpcFRhZ0JvZHkoXG4gICAgICBvcHRpb25zLnN0cmlwSWdub3JlVGFnQm9keSxcbiAgICAgIG9uSWdub3JlVGFnXG4gICAgKTtcbiAgICBvbklnbm9yZVRhZyA9IHN0cmlwSWdub3JlVGFnQm9keS5vbklnbm9yZVRhZztcbiAgfVxuXG4gIHZhciByZXRIdG1sID0gcGFyc2VUYWcoXG4gICAgaHRtbCxcbiAgICBmdW5jdGlvbiAoc291cmNlUG9zaXRpb24sIHBvc2l0aW9uLCB0YWcsIGh0bWwsIGlzQ2xvc2luZykge1xuICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgIHNvdXJjZVBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICBpc0Nsb3Npbmc6IGlzQ2xvc2luZyxcbiAgICAgICAgaXNXaGl0ZTogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdoaXRlTGlzdCwgdGFnKSxcbiAgICAgIH07XG5cbiAgICAgIC8vIGNhbGwgYG9uVGFnKClgXG4gICAgICB2YXIgcmV0ID0gb25UYWcodGFnLCBodG1sLCBpbmZvKTtcbiAgICAgIGlmICghaXNOdWxsKHJldCkpIHJldHVybiByZXQ7XG5cbiAgICAgIGlmIChpbmZvLmlzV2hpdGUpIHtcbiAgICAgICAgaWYgKGluZm8uaXNDbG9zaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIFwiPC9cIiArIHRhZyArIFwiPlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMoaHRtbCk7XG4gICAgICAgIHZhciB3aGl0ZUF0dHJMaXN0ID0gd2hpdGVMaXN0W3RhZ107XG4gICAgICAgIHZhciBhdHRyc0h0bWwgPSBwYXJzZUF0dHIoYXR0cnMuaHRtbCwgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gY2FsbCBgb25UYWdBdHRyKClgXG4gICAgICAgICAgdmFyIGlzV2hpdGVBdHRyID0gXy5pbmRleE9mKHdoaXRlQXR0ckxpc3QsIG5hbWUpICE9PSAtMTtcbiAgICAgICAgICB2YXIgcmV0ID0gb25UYWdBdHRyKHRhZywgbmFtZSwgdmFsdWUsIGlzV2hpdGVBdHRyKTtcbiAgICAgICAgICBpZiAoIWlzTnVsbChyZXQpKSByZXR1cm4gcmV0O1xuXG4gICAgICAgICAgaWYgKGlzV2hpdGVBdHRyKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGBzYWZlQXR0clZhbHVlKClgXG4gICAgICAgICAgICB2YWx1ZSA9IHNhZmVBdHRyVmFsdWUodGFnLCBuYW1lLCB2YWx1ZSwgY3NzRmlsdGVyKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmFtZSArICc9XCInICsgdmFsdWUgKyAnXCInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhbGwgYG9uSWdub3JlVGFnQXR0cigpYFxuICAgICAgICAgICAgcmV0ID0gb25JZ25vcmVUYWdBdHRyKHRhZywgbmFtZSwgdmFsdWUsIGlzV2hpdGVBdHRyKTtcbiAgICAgICAgICAgIGlmICghaXNOdWxsKHJldCkpIHJldHVybiByZXQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBidWlsZCBuZXcgdGFnIGh0bWxcbiAgICAgICAgaHRtbCA9IFwiPFwiICsgdGFnO1xuICAgICAgICBpZiAoYXR0cnNIdG1sKSBodG1sICs9IFwiIFwiICsgYXR0cnNIdG1sO1xuICAgICAgICBpZiAoYXR0cnMuY2xvc2luZykgaHRtbCArPSBcIiAvXCI7XG4gICAgICAgIGh0bWwgKz0gXCI+XCI7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2FsbCBgb25JZ25vcmVUYWcoKWBcbiAgICAgICAgcmV0ID0gb25JZ25vcmVUYWcodGFnLCBodG1sLCBpbmZvKTtcbiAgICAgICAgaWYgKCFpc051bGwocmV0KSkgcmV0dXJuIHJldDtcbiAgICAgICAgcmV0dXJuIGVzY2FwZUh0bWwoaHRtbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlc2NhcGVIdG1sXG4gICk7XG5cbiAgLy8gaWYgZW5hYmxlIHN0cmlwSWdub3JlVGFnQm9keVxuICBpZiAoc3RyaXBJZ25vcmVUYWdCb2R5KSB7XG4gICAgcmV0SHRtbCA9IHN0cmlwSWdub3JlVGFnQm9keS5yZW1vdmUocmV0SHRtbCk7XG4gIH1cblxuICByZXR1cm4gcmV0SHRtbDtcbn07XG5cbnZhciB4c3MgPSBGaWx0ZXJYU1M7XG5cbi8qKlxuICogeHNzXG4gKlxuICogQGF1dGhvciBab25nbWluIExlaTxsZWl6b25nbWluQGdtYWlsLmNvbT5cbiAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHR2YXIgREVGQVVMVCA9IF9kZWZhdWx0JDE7XG5cdHZhciBwYXJzZXIgPSBwYXJzZXIkMTtcblx0dmFyIEZpbHRlclhTUyA9IHhzcztcblxuXHQvKipcblx0ICogZmlsdGVyIHhzcyBmdW5jdGlvblxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB7IHdoaXRlTGlzdCwgb25UYWcsIG9uVGFnQXR0ciwgb25JZ25vcmVUYWcsIG9uSWdub3JlVGFnQXR0ciwgc2FmZUF0dHJWYWx1ZSwgZXNjYXBlSHRtbCB9XG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGZpbHRlclhTUyhodG1sLCBvcHRpb25zKSB7XG5cdCAgdmFyIHhzcyA9IG5ldyBGaWx0ZXJYU1Mob3B0aW9ucyk7XG5cdCAgcmV0dXJuIHhzcy5wcm9jZXNzKGh0bWwpO1xuXHR9XG5cblx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZmlsdGVyWFNTO1xuXHRleHBvcnRzLmZpbHRlclhTUyA9IGZpbHRlclhTUztcblx0ZXhwb3J0cy5GaWx0ZXJYU1MgPSBGaWx0ZXJYU1M7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICBmb3IgKHZhciBpIGluIERFRkFVTFQpIHtcblx0ICAgIGV4cG9ydHNbaV0gPSBERUZBVUxUW2ldO1xuXHQgIH1cblx0ICBmb3IgKHZhciBqIGluIHBhcnNlcikge1xuXHQgICAgZXhwb3J0c1tqXSA9IHBhcnNlcltqXTtcblx0ICB9XG5cdH0pKCk7XG5cblx0Ly8gdXNpbmcgYHhzc2Agb24gdGhlIFdlYldvcmtlciwgb3V0cHV0IGBmaWx0ZXJYU1NgIHRvIHRoZSBnbG9iYWxzXG5cdGZ1bmN0aW9uIGlzV29ya2VyRW52KCkge1xuXHQgIHJldHVybiAoXG5cdCAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHQgICAgdHlwZW9mIERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdCAgICBzZWxmIGluc3RhbmNlb2YgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVcblx0ICApO1xuXHR9XG5cdGlmIChpc1dvcmtlckVudigpKSB7XG5cdCAgc2VsZi5maWx0ZXJYU1MgPSBtb2R1bGUuZXhwb3J0cztcblx0fVxufSAobGliJDEsIGxpYiQxLmV4cG9ydHMpKTtcblxuLyogQ29weXJpZ2h0IChjKSAyMDIwIEVudmlyb25tZW50YWwgU3lzdGVtcyBSZXNlYXJjaCBJbnN0aXR1dGUsIEluYy5cbiAqIEFwYWNoZS0yLjBcbiAqXG4gKiBqcy14c3NcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE4IFpvbmdtaW4gTGVpKOmbt+Wul+awkSkgPGxlaXpvbmdtaW5AZ21haWwuY29tPlxuICogaHR0cDovL3VjZG9rLmNvbVxuICogVGhlIE1JVCBMaWNlbnNlLCBzZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9sZWl6b25nbWluL2pzLXhzcy9ibG9iL21hc3Rlci9MSUNFTlNFIGZvciBkZXRhaWxzXG4gKiAqL1xuLyoqXG4gKiBUaGUgU2FuaXRpemVyIENsYXNzXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIFNhbml0aXplclxuICovXG52YXIgU2FuaXRpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNhbml0aXplcihmaWx0ZXJPcHRpb25zLCBleHRlbmREZWZhdWx0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBTdXBwb3J0ZWQgSFRNTCBTcGVjOiBodHRwczovL2RvYy5hcmNnaXMuY29tL2VuL2FyY2dpcy1vbmxpbmUvcmVmZXJlbmNlL3N1cHBvcnRlZC1odG1sLmh0bVxuICAgICAgICB0aGlzLmFyY2dpc1doaXRlTGlzdCA9IHtcbiAgICAgICAgICAgIGE6IFtcImhyZWZcIiwgXCJzdHlsZVwiLCBcInRhcmdldFwiXSxcbiAgICAgICAgICAgIGFiYnI6IFtcInRpdGxlXCJdLFxuICAgICAgICAgICAgYXVkaW86IFtcImF1dG9wbGF5XCIsIFwiY29udHJvbHNcIiwgXCJsb29wXCIsIFwibXV0ZWRcIiwgXCJwcmVsb2FkXCJdLFxuICAgICAgICAgICAgYjogW10sXG4gICAgICAgICAgICBicjogW10sXG4gICAgICAgICAgICBkZDogW1wic3R5bGVcIl0sXG4gICAgICAgICAgICBkaXY6IFtcImFsaWduXCIsIFwic3R5bGVcIl0sXG4gICAgICAgICAgICBkbDogW1wic3R5bGVcIl0sXG4gICAgICAgICAgICBkdDogW1wic3R5bGVcIl0sXG4gICAgICAgICAgICBlbTogW10sXG4gICAgICAgICAgICBmaWdjYXB0aW9uOiBbXCJzdHlsZVwiXSxcbiAgICAgICAgICAgIGZpZ3VyZTogW1wic3R5bGVcIl0sXG4gICAgICAgICAgICBmb250OiBbXCJjb2xvclwiLCBcImZhY2VcIiwgXCJzaXplXCIsIFwic3R5bGVcIl0sXG4gICAgICAgICAgICBoMTogW1wic3R5bGVcIl0sXG4gICAgICAgICAgICBoMjogW1wic3R5bGVcIl0sXG4gICAgICAgICAgICBoMzogW1wic3R5bGVcIl0sXG4gICAgICAgICAgICBoNDogW1wic3R5bGVcIl0sXG4gICAgICAgICAgICBoNTogW1wic3R5bGVcIl0sXG4gICAgICAgICAgICBoNjogW1wic3R5bGVcIl0sXG4gICAgICAgICAgICBocjogW10sXG4gICAgICAgICAgICBpOiBbXSxcbiAgICAgICAgICAgIGltZzogW1wiYWx0XCIsIFwiYm9yZGVyXCIsIFwiaGVpZ2h0XCIsIFwic3JjXCIsIFwic3R5bGVcIiwgXCJ3aWR0aFwiXSxcbiAgICAgICAgICAgIGxpOiBbXSxcbiAgICAgICAgICAgIG9sOiBbXSxcbiAgICAgICAgICAgIHA6IFtcInN0eWxlXCJdLFxuICAgICAgICAgICAgc291cmNlOiBbXCJtZWRpYVwiLCBcInNyY1wiLCBcInR5cGVcIl0sXG4gICAgICAgICAgICBzcGFuOiBbXCJzdHlsZVwiXSxcbiAgICAgICAgICAgIHN0cm9uZzogW10sXG4gICAgICAgICAgICBzdWI6IFtcInN0eWxlXCJdLFxuICAgICAgICAgICAgc3VwOiBbXCJzdHlsZVwiXSxcbiAgICAgICAgICAgIHRhYmxlOiBbXCJib3JkZXJcIiwgXCJjZWxscGFkZGluZ1wiLCBcImNlbGxzcGFjaW5nXCIsIFwiaGVpZ2h0XCIsIFwic3R5bGVcIiwgXCJ3aWR0aFwiXSxcbiAgICAgICAgICAgIHRib2R5OiBbXSxcbiAgICAgICAgICAgIHRyOiBbXCJhbGlnblwiLCBcImhlaWdodFwiLCBcInN0eWxlXCIsIFwidmFsaWduXCJdLFxuICAgICAgICAgICAgdGQ6IFtcbiAgICAgICAgICAgICAgICBcImFsaWduXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xzcGFuXCIsXG4gICAgICAgICAgICAgICAgXCJoZWlnaHRcIixcbiAgICAgICAgICAgICAgICBcIm5vd3JhcFwiLFxuICAgICAgICAgICAgICAgIFwicm93c3BhblwiLFxuICAgICAgICAgICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgICAgICAgICBcInZhbGlnblwiLFxuICAgICAgICAgICAgICAgIFwid2lkdGhcIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0aDogW1xuICAgICAgICAgICAgICAgIFwiYWxpZ25cIixcbiAgICAgICAgICAgICAgICBcImNvbHNwYW5cIixcbiAgICAgICAgICAgICAgICBcImhlaWdodFwiLFxuICAgICAgICAgICAgICAgIFwibm93cmFwXCIsXG4gICAgICAgICAgICAgICAgXCJyb3dzcGFuXCIsXG4gICAgICAgICAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICAgICAgICAgIFwidmFsaWduXCIsXG4gICAgICAgICAgICAgICAgXCJ3aWR0aFwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHU6IFtdLFxuICAgICAgICAgICAgdWw6IFtdLFxuICAgICAgICAgICAgdmlkZW86IFtcbiAgICAgICAgICAgICAgICBcImF1dG9wbGF5XCIsXG4gICAgICAgICAgICAgICAgXCJjb250cm9sc1wiLFxuICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJsb29wXCIsXG4gICAgICAgICAgICAgICAgXCJtdXRlZFwiLFxuICAgICAgICAgICAgICAgIFwicG9zdGVyXCIsXG4gICAgICAgICAgICAgICAgXCJwcmVsb2FkXCIsXG4gICAgICAgICAgICAgICAgXCJ3aWR0aFwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hbGxvd2VkUHJvdG9jb2xzID0gW1xuICAgICAgICAgICAgXCJodHRwXCIsXG4gICAgICAgICAgICBcImh0dHBzXCIsXG4gICAgICAgICAgICBcIm1haWx0b1wiLFxuICAgICAgICAgICAgXCJpZm9ybVwiLFxuICAgICAgICAgICAgXCJ0ZWxcIixcbiAgICAgICAgICAgIFwiZmxvd1wiLFxuICAgICAgICAgICAgXCJsZm1vYmlsZVwiLFxuICAgICAgICAgICAgXCJhcmNnaXMtbmF2aWdhdG9yXCIsXG4gICAgICAgICAgICBcImFyY2dpcy1hcHBzdHVkaW8tcGxheWVyXCIsXG4gICAgICAgICAgICBcImFyY2dpcy1zdXJ2ZXkxMjNcIixcbiAgICAgICAgICAgIFwiYXJjZ2lzLWNvbGxlY3RvclwiLFxuICAgICAgICAgICAgXCJhcmNnaXMtd29ya2ZvcmNlXCIsXG4gICAgICAgICAgICBcImFyY2dpcy1leHBsb3JlclwiLFxuICAgICAgICAgICAgXCJhcmNnaXMtdHJlazJ0aGVyZVwiLFxuICAgICAgICAgICAgXCJhcmNnaXMtcXVpY2tjYXB0dXJlXCIsXG4gICAgICAgICAgICBcIm1zcGJpXCIsXG4gICAgICAgICAgICBcImNvbWdvb2dsZW1hcHNcIixcbiAgICAgICAgICAgIFwicGRmZWZpbGVcIixcbiAgICAgICAgICAgIFwicGRmZWh0dHBcIixcbiAgICAgICAgICAgIFwicGRmZWh0dHBzXCIsXG4gICAgICAgICAgICBcImJveGFwcFwiLFxuICAgICAgICAgICAgXCJib3hlbW1cIixcbiAgICAgICAgICAgIFwiYXdiXCIsXG4gICAgICAgICAgICBcImF3YnNcIixcbiAgICAgICAgICAgIFwiZ3JvcGVuXCIsXG4gICAgICAgICAgICBcInJhZGFyc2NvcGVcIixcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgYWxsb3dDb21tZW50VGFnOiB0cnVlLFxuICAgICAgICAgICAgc2FmZUF0dHJWYWx1ZTogZnVuY3Rpb24gKHRhZywgbmFtZSwgdmFsdWUsIGNzc0ZpbHRlcikge1xuICAgICAgICAgICAgICAgIC8vIFRha2Ugb3ZlciBzYWZlIGF0dHJpYnV0ZSBmaWx0ZXJpbmcgZm9yIGBhYCBgaHJlZmAsIGBpbWdgIGBzcmNgLFxuICAgICAgICAgICAgICAgIC8vIGFuZCBgc291cmNlYCBgc3JjYCBhdHRyaWJ1dGVzLCBvdGhlcndpc2UgcGFzcyBvbnRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgYFhTUy5zYWZlQXR0clZhbHVlYCBtZXRob2QuXG4gICAgICAgICAgICAgICAgaWYgKCh0YWcgPT09IFwiYVwiICYmIG5hbWUgPT09IFwiaHJlZlwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAoKHRhZyA9PT0gXCJpbWdcIiB8fCB0YWcgPT09IFwic291cmNlXCIpICYmIG5hbWUgPT09IFwic3JjXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zYW5pdGl6ZVVybCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsaWIkMS5leHBvcnRzLnNhZmVBdHRyVmFsdWUodGFnLCBuYW1lLCB2YWx1ZSwgY3NzRmlsdGVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2VudGl0eU1hcCA9IHtcbiAgICAgICAgICAgIFwiJlwiOiBcIiYjeDM4O1wiLFxuICAgICAgICAgICAgXCI8XCI6IFwiJiN4M0M7XCIsXG4gICAgICAgICAgICBcIj5cIjogXCImI3gzRTtcIixcbiAgICAgICAgICAgICdcIic6IFwiJiN4MjI7XCIsXG4gICAgICAgICAgICBcIidcIjogXCImI3gyNztcIixcbiAgICAgICAgICAgIFwiL1wiOiBcIiYjeDJGO1wiLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgeHNzRmlsdGVyT3B0aW9ucztcbiAgICAgICAgaWYgKGZpbHRlck9wdGlvbnMgJiYgIWV4dGVuZERlZmF1bHRzKSB7XG4gICAgICAgICAgICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdHNcbiAgICAgICAgICAgIHhzc0ZpbHRlck9wdGlvbnMgPSBmaWx0ZXJPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlck9wdGlvbnMgJiYgZXh0ZW5kRGVmYXVsdHMpIHtcbiAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgZGVmYXVsdHNcbiAgICAgICAgICAgIHhzc0ZpbHRlck9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHRoaXMuYXJjZ2lzRmlsdGVyT3B0aW9ucyk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhmaWx0ZXJPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIndoaXRlTGlzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgd2hpdGVsaXN0IGJ5IGNvbmNhdGVuYXRpbmcgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgIHhzc0ZpbHRlck9wdGlvbnMud2hpdGVMaXN0ID0gX3RoaXMuX2V4dGVuZE9iamVjdE9mQXJyYXlzKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFyY2dpc1doaXRlTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlck9wdGlvbnMud2hpdGVMaXN0IHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHhzc0ZpbHRlck9wdGlvbnNba2V5XSA9IGZpbHRlck9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIHRoZSBkZWZhdWx0c1xuICAgICAgICAgICAgeHNzRmlsdGVyT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodGhpcy5hcmNnaXNGaWx0ZXJPcHRpb25zKTtcbiAgICAgICAgICAgIHhzc0ZpbHRlck9wdGlvbnMud2hpdGVMaXN0ID0gdGhpcy5hcmNnaXNXaGl0ZUxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54c3NGaWx0ZXJPcHRpb25zID0geHNzRmlsdGVyT3B0aW9ucztcbiAgICAgICAgLy8gTWFrZSB0aGlzIHJlYWRhYmxlIHRvIHRlc3RzXG4gICAgICAgIHRoaXMuX3hzc0ZpbHRlciA9IG5ldyBsaWIkMS5leHBvcnRzLkZpbHRlclhTUyh4c3NGaWx0ZXJPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2FuaXRpemVzIHZhbHVlIHRvIHJlbW92ZSBpbnZhbGlkIEhUTUwgdGFncy5cbiAgICAgKlxuICAgICAqIE5vdGU6IElmIHRoZSB2YWx1ZSBwYXNzZWQgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIEpTT04gZGF0YSB0eXBlIChTdHJpbmcsXG4gICAgICogTnVtYmVyLCBKU09OIE9iamVjdCwgQXJyYXksIEJvb2xlYW4sIG9yIG51bGwpLCB0aGUgdmFsdWUgd2lsbCBiZSBudWxsaWZpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIHNhbml0aXplLlxuICAgICAqIEByZXR1cm5zIHthbnl9IFRoZSBzYW5pdGl6ZWQgdmFsdWUuXG4gICAgICogQG1lbWJlcm9mIFNhbml0aXplclxuICAgICAqL1xuICAgIFNhbml0aXplci5wcm90b3R5cGUuc2FuaXRpemUgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl94c3NGaWx0ZXIucHJvY2Vzcyh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZXJhdGVPdmVyT2JqZWN0KHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dVbmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhbml0aXplcyBhIFVSTCBzdHJpbmcgZm9sbG93aW5nIHRoZSBhbGxvd2VkIHByb3RvY29scyBhbmQgc2FuaXRpemF0aW9uIHJ1bGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBVUkwgdG8gc2FuaXRpemUuXG4gICAgICogQHBhcmFtIHt7IGlzUHJvdG9jb2xSZXF1aXJlZDogYm9vbGVhbiB9fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgVVJMIGNoZWNraW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzYW5pdGl6ZWQgVVJMIGlmIGl0J3MgdmFsaWQsIG9yIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgVVJMIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgU2FuaXRpemVyLnByb3RvdHlwZS5zYW5pdGl6ZVVybCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EgPSAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pLmlzUHJvdG9jb2xSZXF1aXJlZCwgaXNQcm90b2NvbFJlcXVpcmVkID0gX2EgPT09IHZvaWQgMCA/IHRydWUgOiBfYTtcbiAgICAgICAgdmFyIHByb3RvY29sID0gdGhpcy5fdHJpbSh2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUuaW5kZXhPZihcIjpcIikpKTtcbiAgICAgICAgdmFyIGlzUm9vdFVybCA9IHZhbHVlID09PSAnLyc7XG4gICAgICAgIHZhciBpc1VybEZyYWdtZW50ID0gL14jLy50ZXN0KHZhbHVlKTtcbiAgICAgICAgdmFyIGlzVmFsaWRQcm90b2NvbCA9IHByb3RvY29sICYmIHRoaXMuYWxsb3dlZFByb3RvY29scy5pbmRleE9mKHByb3RvY29sLnRvTG93ZXJDYXNlKCkpID4gLTE7XG4gICAgICAgIGlmIChpc1Jvb3RVcmwgfHwgaXNVcmxGcmFnbWVudCB8fCBpc1ZhbGlkUHJvdG9jb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBsaWIkMS5leHBvcnRzLmVzY2FwZUF0dHJWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm90b2NvbCAmJiAhaXNQcm90b2NvbFJlcXVpcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGliJDEuZXhwb3J0cy5lc2NhcGVBdHRyVmFsdWUoXCJodHRwczovL1wiLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2FuaXRpemVzIGFuIEhUTUwgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgdGFnbmFtZSBvZiB0aGUgSFRNTCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgVGhlIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBIVE1MIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSByYXcgdmFsdWUgdG8gYmUgdXNlZCBmb3IgdGhlIEhUTUwgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7WFNTLklDU1NGaWx0ZXJ9IFtjc3NGaWx0ZXJdIFRoZSBDU1MgZmlsdGVyIHRvIGJlIHVzZWQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHNhbml0aXplZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogQG1lbWJlcm9mIFNhbml0aXplclxuICAgICAqL1xuICAgIFNhbml0aXplci5wcm90b3R5cGUuc2FuaXRpemVIVE1MQXR0cmlidXRlID0gZnVuY3Rpb24gKHRhZywgYXR0cmlidXRlLCB2YWx1ZSwgY3NzRmlsdGVyKSB7XG4gICAgICAgIC8vIHVzZSB0aGUgY3VzdG9tIHNhZmVBdHRyVmFsdWUgZnVuY3Rpb24gaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnhzc0ZpbHRlck9wdGlvbnMuc2FmZUF0dHJWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54c3NGaWx0ZXJPcHRpb25zLnNhZmVBdHRyVmFsdWUodGFnLCBhdHRyaWJ1dGUsIHZhbHVlLCBcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc2FmZUF0dHJWYWx1ZSBkb2VzIGhhbmRsZSB1bmRlZmluZWQgY3NzRmlsdGVyXG4gICAgICAgICAgICBjc3NGaWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBzYWZlQXR0clZhbHVlIGRvZXMgaGFuZGxlIHVuZGVmaW5lZCBjc3NGaWx0ZXJcbiAgICAgICAgcmV0dXJuIGxpYiQxLmV4cG9ydHMuc2FmZUF0dHJWYWx1ZSh0YWcsIGF0dHJpYnV0ZSwgdmFsdWUsIGNzc0ZpbHRlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSB2YWx1ZSBvbmx5IGNvbnRhaW5zIHZhbGlkIEhUTUwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJvZiBTYW5pdGl6ZXJcbiAgICAgKi9cbiAgICBTYW5pdGl6ZXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBzYW5pdGl6ZWQgPSB0aGlzLnNhbml0aXplKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVmFsaWQ6IHZhbHVlID09PSBzYW5pdGl6ZWQsXG4gICAgICAgICAgICBzYW5pdGl6ZWQ6IHNhbml0aXplZCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIGZvbGxvd2luZyBjaGFyYWN0ZXJzLCBgJiA8ID4gXFxcIiAnIC9gIHRvIHRoZWlyIGhleGFkZWNpbWFsIEhUTUwgZW50aXR5IGNvZGUuXG4gICAgICogRXhhbXBsZTogXCImbWlkZG90O1wiID0+IFwiJiN4Mzg7bWlkZG90O1wiXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCBzdHJpbmcgdmFsdWUuXG4gICAgICogQG1lbWJlcm9mIFNhbml0aXplclxuICAgICAqL1xuICAgIFNhbml0aXplci5wcm90b3R5cGUuZW5jb2RlSFRNTCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKC9bJjw+XCInXFwvXS9nLCBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9lbnRpdHlNYXBbc107XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhbGwgbm9uLWFscGhhbnVtZXJpYyBBU0NJSSBjaGFyYWN0ZXJzIHRvIHRoZWlyIGhleGFkZWNpbWFsIEhUTUwgZW50aXR5IGNvZGVzLlxuICAgICAqIEV4YW1wbGU6IFwiYWxlcnQoZG9jdW1lbnQuY29va2llKVwiID0+IFwiYWxlcnQmI3gyODtkb2N1bWVudCYjeDJlO2Nvb2tpZSYjeDI5O1wiXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCBzdHJpbmcgdmFsdWUuXG4gICAgICogQG1lbWJlcm9mIFNhbml0aXplclxuICAgICAqL1xuICAgIFNhbml0aXplci5wcm90b3R5cGUuZW5jb2RlQXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBhbHBoYW51bWVyaWNSRSA9IC9eW2EtekEtWjAtOV0kLztcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSkucmVwbGFjZSgvW1xceDAwLVxceEZGXS9nLCBmdW5jdGlvbiAoYywgaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gIWFscGhhbnVtZXJpY1JFLnRlc3QoYylcbiAgICAgICAgICAgICAgICA/IFwiJiN4XCIuY29uY2F0KE51bWJlcih2YWx1ZS5jaGFyQ29kZUF0KGlkeCkpLnRvU3RyaW5nKDE2KSwgXCI7XCIpXG4gICAgICAgICAgICAgICAgOiBjO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4dGVuZHMgYW4gb2JqZWN0IG9mIGFycmF5cyBieSBieSBjb25jYXRlbmF0aW5nIGFycmF5cyBvZiB0aGUgc2FtZSBvYmplY3RcbiAgICAgKiBrZXlzLiBJZiB0aGUgaWYgdGhlIHByZXZpb3VzIGtleSdzIHZhbHVlIGlzIG5vdCBhbiBhcnJheSwgdGhlIG5leHQga2V5J3NcbiAgICAgKiB2YWx1ZSB3aWxsIHJlcGxhY2UgdGhlIHByZXZpb3VzIGtleS4gVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgZXh0ZW5kaW5nIHRoZVxuICAgICAqIHdoaXRlTGlzdCBpbiB0aGUgWFNTIGZpbHRlciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5PHt9Pn0gb2JqZWN0cyBBbiBhcnJheSBvZiBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHt7fX0gVGhlIGV4dGVuZGVkIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyb2YgU2FuaXRpemVyXG4gICAgICovXG4gICAgU2FuaXRpemVyLnByb3RvdHlwZS5fZXh0ZW5kT2JqZWN0T2ZBcnJheXMgPSBmdW5jdGlvbiAob2JqZWN0cykge1xuICAgICAgICB2YXIgZmluYWxPYmogPSB7fTtcbiAgICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pICYmIEFycmF5LmlzQXJyYXkoZmluYWxPYmpba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxPYmpba2V5XSA9IGZpbmFsT2JqW2tleV0uY29uY2F0KG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsT2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaW5hbE9iajtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEl0ZXJhdGUgb3ZlciBhIHBsYWluIG9iamVjdCBvciBhcnJheSB0byBkZWVwbHkgc2FuaXRpemUgZWFjaCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7KG9iamVjdCB8IG51bGwpfSBUaGUgc2FuaXRpemVkIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyb2YgU2FuaXRpemVyXG4gICAgICovXG4gICAgU2FuaXRpemVyLnByb3RvdHlwZS5faXRlcmF0ZU92ZXJPYmplY3QgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaGFzQ2hhbmdlZF8xID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZE9iaiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkT2JqID0gb2JqLnJlZHVjZShmdW5jdGlvbiAocHJldiwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRpb24gPSBfdGhpcy52YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2LmNvbmNhdChbdmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoYW5nZWRfMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldi5jb25jYXQoW3ZhbGlkYXRpb24uc2FuaXRpemVkXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dVbmRlZmluZWQgJiYgdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRPYmogPSBrZXlzLnJlZHVjZShmdW5jdGlvbiAocHJldiwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGlvbiA9IF90aGlzLnZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb24uaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldltrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGFuZ2VkXzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldltrZXldID0gdmFsaWRhdGlvbi5zYW5pdGl6ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0NoYW5nZWRfMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpbSB3aGl0ZXNwYWNlIGZyb20gdGhlIHN0YXJ0IGFuZCBlbmRzIG9mIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWwgVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBTYW5pdGl6ZXIucHJvdG90eXBlLl90cmltID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlIFRoaXMgaXMgdXNlZCBieSBKZXN0LFxuICAgICAgICAvLyBidXQgVHlwZVNjcmlwdCBlcnJvcnMgc2luY2UgaXQgYXNzdW1lcyBgdHJpbWAgaXMgYWx3YXlzIGF2YWlsYWJsZS5cbiAgICAgICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUudHJpbVxuICAgICAgICAgICAgPyB2YWwudHJpbSgpXG4gICAgICAgICAgICA6IHZhbC5yZXBsYWNlKC8oXlxccyopfChcXHMqJCkvZywgXCJcIik7XG4gICAgfTtcbiAgICByZXR1cm4gU2FuaXRpemVyO1xufSgpKTtcblxuZXhwb3J0IHsgU2FuaXRpemVyLCBTYW5pdGl6ZXIgYXMgZGVmYXVsdCB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuNC4yXG4gKi9cbmltcG9ydCB7IGcgYXMgZ3VpZCB9IGZyb20gJy4vZ3VpZC5qcyc7XG5cbmNvbnN0IGF1dG9Nb2RlID0gXCJjYWxjaXRlLW1vZGUtYXV0b1wiO1xuY29uc3QgZGFya01vZGUgPSBcImNhbGNpdGUtbW9kZS1kYXJrXCI7XG5jb25zdCBsaWdodE1vZGUgPSBcImNhbGNpdGUtbW9kZS1saWdodFwiO1xuY29uc3QgQ1NTX1VUSUxJVFkgPSB7XG4gIGF1dG9Nb2RlLFxuICBkYXJrTW9kZSxcbiAgbGlnaHRNb2RlLFxuICBydGw6IFwiY2FsY2l0ZS0tcnRsXCIsXG4gIGNhbGNpdGVBbmltYXRlOiBcImNhbGNpdGUtYW5pbWF0ZVwiLFxuICBjYWxjaXRlQW5pbWF0ZUluOiBcImNhbGNpdGUtYW5pbWF0ZV9faW5cIixcbiAgY2FsY2l0ZUFuaW1hdGVJblVwOiBcImNhbGNpdGUtYW5pbWF0ZV9faW4tdXBcIixcbiAgY2FsY2l0ZUFuaW1hdGVJbkRvd246IFwiY2FsY2l0ZS1hbmltYXRlX19pbi1kb3duXCIsXG4gIGNhbGNpdGVBbmltYXRlSW5SaWdodDogXCJjYWxjaXRlLWFuaW1hdGVfX2luLXJpZ2h0XCIsXG4gIGNhbGNpdGVBbmltYXRlSW5MZWZ0OiBcImNhbGNpdGUtYW5pbWF0ZV9faW4tbGVmdFwiLFxuICBjYWxjaXRlQW5pbWF0ZUluU2NhbGU6IFwiY2FsY2l0ZS1hbmltYXRlX19pbi1zY2FsZVwiXG59O1xuXG4vKiFcbiogdGFiYmFibGUgNi4xLjJcbiogQGxpY2Vuc2UgTUlULCBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC90YWJiYWJsZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xuLy8gTk9URTogc2VwYXJhdGUgYDpub3QoKWAgc2VsZWN0b3JzIGhhcyBicm9hZGVyIGJyb3dzZXIgc3VwcG9ydCB0aGFuIHRoZSBuZXdlclxuLy8gIGA6bm90KFtpbmVydF0sIFtpbmVydF0gKilgIChGZWIgMjAyMylcbi8vIENBUkVGVUw6IEpTRG9tIGRvZXMgbm90IHN1cHBvcnQgYDpub3QoW2luZXJ0XSAqKWAgYXMgYSBzZWxlY3RvcjsgdXNpbmcgaXQgY2F1c2VzXG4vLyAgdGhlIGVudGlyZSBxdWVyeSB0byBmYWlsLCByZXN1bHRpbmcgaW4gbm8gbm9kZXMgZm91bmQsIHdoaWNoIHdpbGwgYnJlYWsgYSBsb3Rcbi8vICBvZiB0aGluZ3MuLi4gc28gd2UgaGF2ZSB0byByZWx5IG9uIEpTIHRvIGlkZW50aWZ5IG5vZGVzIGluc2lkZSBhbiBpbmVydCBjb250YWluZXJcbnZhciBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbJ2lucHV0Om5vdChbaW5lcnRdKScsICdzZWxlY3Q6bm90KFtpbmVydF0pJywgJ3RleHRhcmVhOm5vdChbaW5lcnRdKScsICdhW2hyZWZdOm5vdChbaW5lcnRdKScsICdidXR0b246bm90KFtpbmVydF0pJywgJ1t0YWJpbmRleF06bm90KHNsb3QpOm5vdChbaW5lcnRdKScsICdhdWRpb1tjb250cm9sc106bm90KFtpbmVydF0pJywgJ3ZpZGVvW2NvbnRyb2xzXTpub3QoW2luZXJ0XSknLCAnW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSk6bm90KFtpbmVydF0pJywgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlOm5vdChbaW5lcnRdKScsICdkZXRhaWxzOm5vdChbaW5lcnRdKSddO1xudmFyIGNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovY2FuZGlkYXRlU2VsZWN0b3JzLmpvaW4oJywnKTtcbnZhciBOb0VsZW1lbnQgPSB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCc7XG52YXIgbWF0Y2hlcyA9IE5vRWxlbWVudCA/IGZ1bmN0aW9uICgpIHt9IDogRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG52YXIgZ2V0Um9vdE5vZGUkMSA9ICFOb0VsZW1lbnQgJiYgRWxlbWVudC5wcm90b3R5cGUuZ2V0Um9vdE5vZGUgPyBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkZ2V0Um9vdE5vZGU7XG4gIHJldHVybiBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZWxlbWVudCRnZXRSb290Tm9kZSA9IGVsZW1lbnQuZ2V0Um9vdE5vZGUpID09PSBudWxsIHx8IF9lbGVtZW50JGdldFJvb3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZWxlbWVudCRnZXRSb290Tm9kZS5jYWxsKGVsZW1lbnQpO1xufSA6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIG5vZGUgaXMgaW5lcnQgb3IgaW4gYW4gaW5lcnQgYW5jZXN0b3IuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtub2RlXVxuICogQHBhcmFtIHtib29sZWFufSBbbG9va1VwXSBJZiB0cnVlIGFuZCBgbm9kZWAgaXMgbm90IGluZXJ0LCBsb29rcyB1cCBhdCBhbmNlc3RvcnMgdG9cbiAqICBzZWUgaWYgYW55IG9mIHRoZW0gYXJlIGluZXJ0LiBJZiBmYWxzZSwgb25seSBgbm9kZWAgaXRzZWxmIGlzIGNvbnNpZGVyZWQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBpbmVydCBpdHNlbGYgb3IgYnkgd2F5IG9mIGJlaW5nIGluIGFuIGluZXJ0IGFuY2VzdG9yLlxuICogIEZhbHNlIGlmIGBub2RlYCBpcyBmYWxzeS5cbiAqL1xudmFyIGlzSW5lcnQgPSBmdW5jdGlvbiBpc0luZXJ0KG5vZGUsIGxvb2tVcCkge1xuICB2YXIgX25vZGUkZ2V0QXR0cmlidXRlO1xuICBpZiAobG9va1VwID09PSB2b2lkIDApIHtcbiAgICBsb29rVXAgPSB0cnVlO1xuICB9XG4gIC8vIENBUkVGVUw6IEpTRG9tIGRvZXMgbm90IHN1cHBvcnQgaW5lcnQgYXQgYWxsLCBzbyB3ZSBjYW4ndCB1c2UgdGhlIGBIVE1MRWxlbWVudC5pbmVydGBcbiAgLy8gIEpTIEFQSSBwcm9wZXJ0eTsgd2UgaGF2ZSB0byBjaGVjayB0aGUgYXR0cmlidXRlLCB3aGljaCBjYW4gZWl0aGVyIGJlIGVtcHR5IG9yICd0cnVlJztcbiAgLy8gIGlmIGl0J3MgYG51bGxgIChub3Qgc3BlY2lmaWVkKSBvciAnZmFsc2UnLCBpdCdzIGFuIGFjdGl2ZSBlbGVtZW50XG4gIHZhciBpbmVydEF0dCA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGdldEF0dHJpYnV0ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRnZXRBdHRyaWJ1dGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGdldEF0dHJpYnV0ZS5jYWxsKG5vZGUsICdpbmVydCcpO1xuICB2YXIgaW5lcnQgPSBpbmVydEF0dCA9PT0gJycgfHwgaW5lcnRBdHQgPT09ICd0cnVlJztcblxuICAvLyBOT1RFOiB0aGlzIGNvdWxkIGFsc28gYmUgaGFuZGxlZCB3aXRoIGBub2RlLm1hdGNoZXMoJ1tpbmVydF0sIDppcyhbaW5lcnRdICopJylgXG4gIC8vICBpZiBpdCB3ZXJlbid0IGZvciBgbWF0Y2hlcygpYCBub3QgYmVpbmcgYSBmdW5jdGlvbiBvbiBzaGFkb3cgcm9vdHM7IHRoZSBmb2xsb3dpbmdcbiAgLy8gIGNvZGUgd29ya3MgZm9yIGFueSBraW5kIG9mIG5vZGVcbiAgLy8gQ0FSRUZVTDogSlNEb20gZG9lcyBub3QgYXBwZWFyIHRvIHN1cHBvcnQgY2VydGFpbiBzZWxlY3RvcnMgbGlrZSBgOm5vdChbaW5lcnRdICopYFxuICAvLyAgc28gaXQgbGlrZWx5IHdvdWxkIG5vdCBzdXBwb3J0IGA6aXMoW2luZXJ0XSAqKWAgZWl0aGVyLi4uXG4gIHZhciByZXN1bHQgPSBpbmVydCB8fCBsb29rVXAgJiYgbm9kZSAmJiBpc0luZXJ0KG5vZGUucGFyZW50Tm9kZSk7IC8vIHJlY3Vyc2l2ZVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBub2RlJ3MgY29udGVudCBpcyBlZGl0YWJsZS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gW25vZGVdXG4gKiBAcmV0dXJucyBUcnVlIGlmIGl0J3MgY29udGVudC1lZGl0YWJsZTsgZmFsc2UgaWYgaXQncyBub3Qgb3IgYG5vZGVgIGlzIGZhbHN5LlxuICovXG52YXIgaXNDb250ZW50RWRpdGFibGUgPSBmdW5jdGlvbiBpc0NvbnRlbnRFZGl0YWJsZShub2RlKSB7XG4gIHZhciBfbm9kZSRnZXRBdHRyaWJ1dGUyO1xuICAvLyBDQVJFRlVMOiBKU0RvbSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgSFRNTEVsZW1lbnQuaXNDb250ZW50RWRpdGFibGVgIEFQSSBzbyB3ZSBoYXZlXG4gIC8vICB0byB1c2UgdGhlIGF0dHJpYnV0ZSBkaXJlY3RseSB0byBjaGVjayBmb3IgdGhpcywgd2hpY2ggY2FuIGVpdGhlciBiZSBlbXB0eSBvciAndHJ1ZSc7XG4gIC8vICBpZiBpdCdzIGBudWxsYCAobm90IHNwZWNpZmllZCkgb3IgJ2ZhbHNlJywgaXQncyBhIG5vbi1lZGl0YWJsZSBlbGVtZW50XG4gIHZhciBhdHRWYWx1ZSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGdldEF0dHJpYnV0ZTIgPSBub2RlLmdldEF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX25vZGUkZ2V0QXR0cmlidXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkZ2V0QXR0cmlidXRlMi5jYWxsKG5vZGUsICdjb250ZW50ZWRpdGFibGUnKTtcbiAgcmV0dXJuIGF0dFZhbHVlID09PSAnJyB8fCBhdHRWYWx1ZSA9PT0gJ3RydWUnO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIGNvbnRhaW5lciB0byBjaGVjayBpblxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgdG8gY2hlY2tcbiAqIEBwYXJhbSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xuICogQHJldHVybnMge0VsZW1lbnRbXX1cbiAqL1xudmFyIGdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiBnZXRDYW5kaWRhdGVzKGVsLCBpbmNsdWRlQ29udGFpbmVyLCBmaWx0ZXIpIHtcbiAgLy8gZXZlbiBpZiBgaW5jbHVkZUNvbnRhaW5lcj1mYWxzZWAsIHdlIHN0aWxsIGhhdmUgdG8gY2hlY2sgaXQgZm9yIGluZXJ0bmVzcyBiZWNhdXNlXG4gIC8vICBpZiBpdCdzIGluZXJ0LCBhbGwgaXRzIGNoaWxkcmVuIGFyZSBpbmVydFxuICBpZiAoaXNJbmVydChlbCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoZWwucXVlcnlTZWxlY3RvckFsbChjYW5kaWRhdGVTZWxlY3RvcikpO1xuICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gIH1cbiAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgR2V0U2hhZG93Um9vdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrIGZvciBzaGFkb3cgcm9vdFxuICogQHJldHVybnMge1NoYWRvd1Jvb3R8Ym9vbGVhbn0gU2hhZG93Um9vdCBpZiBhdmFpbGFibGUgb3IgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgc2hhZG93Um9vdCBpcyBhdHRhY2hlZCBidXQgbm90IGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTaGFkb3dSb290RmlsdGVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHNoYWRvd0hvc3ROb2RlIHRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHNoYWRvdyBjb250ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIHNoYWRvdyByb290IGNvdWxkIHBvdGVudGlhbGx5IGNvbnRhaW4gdmFsaWQgY2FuZGlkYXRlcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbmRpZGF0ZVNjb3BlXG4gKiBAcHJvcGVydHkge0VsZW1lbnR9IHNjb3BlUGFyZW50IGNvbnRhaW5zIGlubmVyIGNhbmRpZGF0ZXNcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudFtdfSBjYW5kaWRhdGVzIGxpc3Qgb2YgY2FuZGlkYXRlcyBmb3VuZCBpbiB0aGUgc2NvcGUgcGFyZW50XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJdGVyYXRpdmVPcHRpb25zXG4gKiBAcHJvcGVydHkge0dldFNoYWRvd1Jvb3R8Ym9vbGVhbn0gZ2V0U2hhZG93Um9vdCB0cnVlIGlmIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQ7IGZhbHN5IGlmIG5vdDtcbiAqICBpZiBhIGZ1bmN0aW9uLCBpbXBsaWVzIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQgYW5kIGVpdGhlciByZXR1cm5zIHRoZSBzaGFkb3cgcm9vdCBvZiBhbiBlbGVtZW50XG4gKiAgb3IgYSBib29sZWFuIHN0YXRpbmcgaWYgaXQgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyByb290XG4gKiBAcHJvcGVydHkgeyhub2RlOiBFbGVtZW50KSA9PiBib29sZWFufSBmaWx0ZXIgZmlsdGVyIGNhbmRpZGF0ZXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmxhdHRlbiBpZiB0cnVlIHRoZW4gcmVzdWx0IHdpbGwgZmxhdHRlbiBhbnkgQ2FuZGlkYXRlU2NvcGUgaW50byB0aGUgcmV0dXJuZWQgbGlzdFxuICogQHByb3BlcnR5IHtTaGFkb3dSb290RmlsdGVyfSBzaGFkb3dSb290RmlsdGVyIGZpbHRlciBzaGFkb3cgcm9vdHM7XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnRbXX0gZWxlbWVudHMgbGlzdCBvZiBlbGVtZW50IGNvbnRhaW5lcnMgdG8gbWF0Y2ggY2FuZGlkYXRlcyBmcm9tXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciBsaXN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0l0ZXJhdGl2ZU9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheS48RWxlbWVudHxDYW5kaWRhdGVTY29wZT59XG4gKi9cbnZhciBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkgPSBmdW5jdGlvbiBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoZWxlbWVudHMsIGluY2x1ZGVDb250YWluZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgdmFyIGVsZW1lbnRzVG9DaGVjayA9IEFycmF5LmZyb20oZWxlbWVudHMpO1xuICB3aGlsZSAoZWxlbWVudHNUb0NoZWNrLmxlbmd0aCkge1xuICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNUb0NoZWNrLnNoaWZ0KCk7XG4gICAgaWYgKGlzSW5lcnQoZWxlbWVudCwgZmFsc2UpKSB7XG4gICAgICAvLyBubyBuZWVkIHRvIGxvb2sgdXAgc2luY2Ugd2UncmUgZHJpbGxpbmcgZG93blxuICAgICAgLy8gYW55dGhpbmcgaW5zaWRlIHRoaXMgY29udGFpbmVyIHdpbGwgYWxzbyBiZSBpbmVydFxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdTTE9UJykge1xuICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2xvdCBzY29wZSAoc2xvdCBpdHNlbGYgY2Fubm90IGJlIGZvY3VzYWJsZSlcbiAgICAgIHZhciBhc3NpZ25lZCA9IGVsZW1lbnQuYXNzaWduZWRFbGVtZW50cygpO1xuICAgICAgdmFyIGNvbnRlbnQgPSBhc3NpZ25lZC5sZW5ndGggPyBhc3NpZ25lZCA6IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICB2YXIgbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShjb250ZW50LCB0cnVlLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoLmFwcGx5KGNhbmRpZGF0ZXMsIG5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBzY29wZVBhcmVudDogZWxlbWVudCxcbiAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayBjYW5kaWRhdGUgZWxlbWVudFxuICAgICAgdmFyIHZhbGlkQ2FuZGlkYXRlID0gbWF0Y2hlcy5jYWxsKGVsZW1lbnQsIGNhbmRpZGF0ZVNlbGVjdG9yKTtcbiAgICAgIGlmICh2YWxpZENhbmRpZGF0ZSAmJiBvcHRpb25zLmZpbHRlcihlbGVtZW50KSAmJiAoaW5jbHVkZUNvbnRhaW5lciB8fCAhZWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gaXRlcmF0ZSBvdmVyIHNoYWRvdyBjb250ZW50IGlmIHBvc3NpYmxlXG4gICAgICB2YXIgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdCB8fFxuICAgICAgLy8gY2hlY2sgZm9yIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xuICAgICAgdHlwZW9mIG9wdGlvbnMuZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLmdldFNoYWRvd1Jvb3QoZWxlbWVudCk7XG5cbiAgICAgIC8vIG5vIGluZXJ0IGxvb2sgdXAgYmVjYXVzZSB3ZSdyZSBhbHJlYWR5IGRyaWxsaW5nIGRvd24gYW5kIGNoZWNraW5nIGZvciBpbmVydG5lc3NcbiAgICAgIC8vICBvbiB0aGUgd2F5IGRvd24sIHNvIGFsbCBjb250YWluZXJzIHRvIHRoaXMgcm9vdCBub2RlIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlblxuICAgICAgLy8gIHZldHRlZCBhcyBub24taW5lcnRcbiAgICAgIHZhciB2YWxpZFNoYWRvd1Jvb3QgPSAhaXNJbmVydChzaGFkb3dSb290LCBmYWxzZSkgJiYgKCFvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIgfHwgb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyKGVsZW1lbnQpKTtcbiAgICAgIGlmIChzaGFkb3dSb290ICYmIHZhbGlkU2hhZG93Um9vdCkge1xuICAgICAgICAvLyBhZGQgc2hhZG93IGRvbSBzY29wZSBJSUYgYSBzaGFkb3cgcm9vdCBub2RlIHdhcyBnaXZlbjsgb3RoZXJ3aXNlLCBhbiB1bmRpc2Nsb3NlZFxuICAgICAgICAvLyAgc2hhZG93IGV4aXN0cywgc28gbG9vayBhdCBsaWdodCBkb20gY2hpbGRyZW4gYXMgZmFsbGJhY2sgQlVUIGNyZWF0ZSBhIHNjb3BlIGZvciBhbnlcbiAgICAgICAgLy8gIGNoaWxkIGNhbmRpZGF0ZXMgZm91bmQgYmVjYXVzZSB0aGV5J3JlIGxpa2VseSBzbG90dGVkIGVsZW1lbnRzIChlbGVtZW50cyB0aGF0IGFyZVxuICAgICAgICAvLyAgY2hpbGRyZW4gb2YgdGhlIHdlYiBjb21wb25lbnQgZWxlbWVudCAod2hpY2ggaGFzIHRoZSBzaGFkb3cpLCBpbiB0aGUgbGlnaHQgZG9tLCBidXRcbiAgICAgICAgLy8gIHNsb3R0ZWQgc29tZXdoZXJlIF9pbnNpZGVfIHRoZSB1bmRpc2Nsb3NlZCBzaGFkb3cpIC0tIHRoZSBzY29wZSBpcyBjcmVhdGVkIGJlbG93LFxuICAgICAgICAvLyAgX2FmdGVyXyB3ZSByZXR1cm4gZnJvbSB0aGlzIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgIHZhciBfbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShzaGFkb3dSb290ID09PSB0cnVlID8gZWxlbWVudC5jaGlsZHJlbiA6IHNoYWRvd1Jvb3QuY2hpbGRyZW4sIHRydWUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoLmFwcGx5KGNhbmRpZGF0ZXMsIF9uZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgICAgc2NvcGVQYXJlbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICBjYW5kaWRhdGVzOiBfbmVzdGVkQ2FuZGlkYXRlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVyZSdzIG5vdCBzaGFkb3cgc28ganVzdCBkaWcgaW50byB0aGUgZWxlbWVudCdzIChsaWdodCBkb20pIGNoaWxkcmVuXG4gICAgICAgIC8vICBfX3dpdGhvdXRfXyBnaXZpbmcgdGhlIGVsZW1lbnQgc3BlY2lhbCBzY29wZSB0cmVhdG1lbnRcbiAgICAgICAgZWxlbWVudHNUb0NoZWNrLnVuc2hpZnQuYXBwbHkoZWxlbWVudHNUb0NoZWNrLCBlbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xudmFyIGdldFRhYmluZGV4ID0gZnVuY3Rpb24gZ2V0VGFiaW5kZXgobm9kZSwgaXNTY29wZSkge1xuICBpZiAobm9kZS50YWJJbmRleCA8IDApIHtcbiAgICAvLyBpbiBDaHJvbWUsIDxkZXRhaWxzLz4sIDxhdWRpbyBjb250cm9scy8+IGFuZCA8dmlkZW8gY29udHJvbHMvPiBlbGVtZW50cyBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAtMSB3aGVuIHRoZSAndGFiaW5kZXgnIGF0dHJpYnV0ZSBpc24ndCBzcGVjaWZpZWQgaW4gdGhlIERPTSxcbiAgICAvLyB5ZXQgdGhleSBhcmUgc3RpbGwgcGFydCBvZiB0aGUgcmVndWxhciB0YWIgb3JkZXI7IGluIEZGLCB0aGV5IGdldCBhIGRlZmF1bHRcbiAgICAvLyBgdGFiSW5kZXhgIG9mIDA7IHNpbmNlIENocm9tZSBzdGlsbCBwdXRzIHRob3NlIGVsZW1lbnRzIGluIHRoZSByZWd1bGFyIHRhYlxuICAgIC8vIG9yZGVyLCBjb25zaWRlciB0aGVpciB0YWIgaW5kZXggdG8gYmUgMC5cbiAgICAvLyBBbHNvIGJyb3dzZXJzIGRvIG5vdCByZXR1cm4gYHRhYkluZGV4YCBjb3JyZWN0bHkgZm9yIGNvbnRlbnRFZGl0YWJsZSBub2RlcztcbiAgICAvLyBzbyBpZiB0aGV5IGRvbid0IGhhdmUgYSB0YWJpbmRleCBhdHRyaWJ1dGUgc3BlY2lmaWNhbGx5IHNldCwgYXNzdW1lIGl0J3MgMC5cbiAgICAvL1xuICAgIC8vIGlzU2NvcGUgaXMgcG9zaXRpdmUgZm9yIGN1c3RvbSBlbGVtZW50IHdpdGggc2hhZG93IHJvb3Qgb3Igc2xvdCB0aGF0IGJ5IGRlZmF1bHRcbiAgICAvLyBoYXZlIHRhYkluZGV4IC0xLCBidXQgbmVlZCB0byBiZSBzb3J0ZWQgYnkgZG9jdW1lbnQgb3JkZXIgaW4gb3JkZXIgZm9yIHRoZWlyXG4gICAgLy8gY29udGVudCB0byBiZSBpbnNlcnRlZCBpbiB0aGUgY29ycmVjdCBwb3NpdGlvblxuICAgIGlmICgoaXNTY29wZSB8fCAvXihBVURJT3xWSURFT3xERVRBSUxTKSQvLnRlc3Qobm9kZS50YWdOYW1lKSB8fCBpc0NvbnRlbnRFZGl0YWJsZShub2RlKSkgJiYgaXNOYU4ocGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZS50YWJJbmRleDtcbn07XG52YXIgc29ydE9yZGVyZWRUYWJiYWJsZXMgPSBmdW5jdGlvbiBzb3J0T3JkZXJlZFRhYmJhYmxlcyhhLCBiKSB7XG4gIHJldHVybiBhLnRhYkluZGV4ID09PSBiLnRhYkluZGV4ID8gYS5kb2N1bWVudE9yZGVyIC0gYi5kb2N1bWVudE9yZGVyIDogYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XG59O1xudmFyIGlzSW5wdXQgPSBmdW5jdGlvbiBpc0lucHV0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0lOUFVUJztcbn07XG52YXIgaXNIaWRkZW5JbnB1dCA9IGZ1bmN0aW9uIGlzSGlkZGVuSW5wdXQobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdoaWRkZW4nO1xufTtcbnZhciBpc0RldGFpbHNXaXRoU3VtbWFyeSA9IGZ1bmN0aW9uIGlzRGV0YWlsc1dpdGhTdW1tYXJ5KG5vZGUpIHtcbiAgdmFyIHIgPSBub2RlLnRhZ05hbWUgPT09ICdERVRBSUxTJyAmJiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkobm9kZS5jaGlsZHJlbikuc29tZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQudGFnTmFtZSA9PT0gJ1NVTU1BUlknO1xuICB9KTtcbiAgcmV0dXJuIHI7XG59O1xudmFyIGdldENoZWNrZWRSYWRpbyA9IGZ1bmN0aW9uIGdldENoZWNrZWRSYWRpbyhub2RlcywgZm9ybSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldLmNoZWNrZWQgJiYgbm9kZXNbaV0uZm9ybSA9PT0gZm9ybSkge1xuICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgIH1cbiAgfVxufTtcbnZhciBpc1RhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiBpc1RhYmJhYmxlUmFkaW8obm9kZSkge1xuICBpZiAoIW5vZGUubmFtZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciByYWRpb1Njb3BlID0gbm9kZS5mb3JtIHx8IGdldFJvb3ROb2RlJDEobm9kZSk7XG4gIHZhciBxdWVyeVJhZGlvcyA9IGZ1bmN0aW9uIHF1ZXJ5UmFkaW9zKG5hbWUpIHtcbiAgICByZXR1cm4gcmFkaW9TY29wZS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBuYW1lICsgJ1wiXScpO1xuICB9O1xuICB2YXIgcmFkaW9TZXQ7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkNTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLCBlcnIubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHZhciBjaGVja2VkID0gZ2V0Q2hlY2tlZFJhZGlvKHJhZGlvU2V0LCBub2RlLmZvcm0pO1xuICByZXR1cm4gIWNoZWNrZWQgfHwgY2hlY2tlZCA9PT0gbm9kZTtcbn07XG52YXIgaXNSYWRpbyA9IGZ1bmN0aW9uIGlzUmFkaW8obm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdyYWRpbyc7XG59O1xudmFyIGlzTm9uVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIHJldHVybiBpc1JhZGlvKG5vZGUpICYmICFpc1RhYmJhYmxlUmFkaW8obm9kZSk7XG59O1xuXG4vLyBkZXRlcm1pbmVzIGlmIGEgbm9kZSBpcyB1bHRpbWF0ZWx5IGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cncyBkb2N1bWVudFxudmFyIGlzTm9kZUF0dGFjaGVkID0gZnVuY3Rpb24gaXNOb2RlQXR0YWNoZWQobm9kZSkge1xuICB2YXIgX25vZGVSb290O1xuICAvLyBUaGUgcm9vdCBub2RlIGlzIHRoZSBzaGFkb3cgcm9vdCBpZiB0aGUgbm9kZSBpcyBpbiBhIHNoYWRvdyBET007IHNvbWUgZG9jdW1lbnQgb3RoZXJ3aXNlXG4gIC8vICAoYnV0IE5PVCBfdGhlXyBkb2N1bWVudDsgc2VlIHNlY29uZCAnSWYnIGNvbW1lbnQgYmVsb3cgZm9yIG1vcmUpLlxuICAvLyBJZiByb290Tm9kZSBpcyBzaGFkb3cgcm9vdCwgaXQnbGwgaGF2ZSBhIGhvc3QsIHdoaWNoIGlzIHRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBzaGFkb3dcbiAgLy8gIGlzIGF0dGFjaGVkLCBhbmQgdGhlIG9uZSB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgaW4gdGhlIGRvY3VtZW50IG9yIG5vdCAoYmVjYXVzZSB0aGVcbiAgLy8gIHNoYWRvdywgYW5kIGFsbCBub2RlcyBpdCBjb250YWlucywgaXMgbmV2ZXIgY29uc2lkZXJlZCBpbiB0aGUgZG9jdW1lbnQgc2luY2Ugc2hhZG93c1xuICAvLyAgYmVoYXZlIGxpa2Ugc2VsZi1jb250YWluZWQgRE9NczsgYnV0IGlmIHRoZSBzaGFkb3cncyBIT1NULCB3aGljaCBpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudCxcbiAgLy8gIGlzIGhpZGRlbiwgb3IgaXMgbm90IGluIHRoZSBkb2N1bWVudCBpdHNlbGYgYnV0IGlzIGRldGFjaGVkLCBpdCB3aWxsIGFmZmVjdCB0aGUgc2hhZG93J3NcbiAgLy8gIHZpc2liaWxpdHksIGluY2x1ZGluZyBhbGwgdGhlIG5vZGVzIGl0IGNvbnRhaW5zKS4gVGhlIGhvc3QgY291bGQgYmUgYW55IG5vcm1hbCBub2RlLFxuICAvLyAgb3IgYSBjdXN0b20gZWxlbWVudCAoaS5lLiB3ZWIgY29tcG9uZW50KS4gRWl0aGVyIHdheSwgdGhhdCdzIHRoZSBvbmUgdGhhdCBpcyBjb25zaWRlcmVkXG4gIC8vICBwYXJ0IG9mIHRoZSBkb2N1bWVudCwgbm90IHRoZSBzaGFkb3cgcm9vdCwgbm9yIGFueSBvZiBpdHMgY2hpbGRyZW4gKGkuZS4gdGhlIG5vZGUgYmVpbmdcbiAgLy8gIHRlc3RlZCkuXG4gIC8vIFRvIGZ1cnRoZXIgY29tcGxpY2F0ZSB0aGluZ3MsIHdlIGhhdmUgdG8gbG9vayBhbGwgdGhlIHdheSB1cCB1bnRpbCB3ZSBmaW5kIGEgc2hhZG93IEhPU1RcbiAgLy8gIHRoYXQgaXMgYXR0YWNoZWQgKG9yIGZpbmQgbm9uZSkgYmVjYXVzZSB0aGUgbm9kZSBtaWdodCBiZSBpbiBuZXN0ZWQgc2hhZG93cy4uLlxuICAvLyBJZiByb290Tm9kZSBpcyBub3QgYSBzaGFkb3cgcm9vdCwgaXQgd29uJ3QgaGF2ZSBhIGhvc3QsIGFuZCBzbyByb290Tm9kZSBzaG91bGQgYmUgdGhlXG4gIC8vICBkb2N1bWVudCAocGVyIHRoZSBkb2NzKSBhbmQgd2hpbGUgaXQncyBhIERvY3VtZW50LXR5cGUgb2JqZWN0LCB0aGF0IGRvY3VtZW50IGRvZXMgbm90XG4gIC8vICBhcHBlYXIgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG5vZGUncyBgb3duZXJEb2N1bWVudGAgZm9yIHNvbWUgcmVhc29uLCBzbyBpdCdzIHNhZmVyXG4gIC8vICB0byBpZ25vcmUgdGhlIHJvb3ROb2RlIGF0IHRoaXMgcG9pbnQsIGFuZCB1c2UgYG5vZGUub3duZXJEb2N1bWVudGAuIE90aGVyd2lzZSxcbiAgLy8gIHVzaW5nIGByb290Tm9kZS5jb250YWlucyhub2RlKWAgd2lsbCBfYWx3YXlzXyBiZSB0cnVlIHdlJ2xsIGdldCBmYWxzZS1wb3NpdGl2ZXMgd2hlblxuICAvLyAgbm9kZSBpcyBhY3R1YWxseSBkZXRhY2hlZC5cbiAgLy8gTk9URTogSWYgYG5vZGVSb290SG9zdGAgb3IgYG5vZGVgIGhhcHBlbnMgdG8gYmUgdGhlIGBkb2N1bWVudGAgaXRzZWxmICh3aGljaCBpcyBwb3NzaWJsZVxuICAvLyAgaWYgYSB0YWJiYWJsZS9mb2N1c2FibGUgbm9kZSB3YXMgcXVpY2tseSBhZGRlZCB0byB0aGUgRE9NLCBmb2N1c2VkLCBhbmQgdGhlbiByZW1vdmVkXG4gIC8vICBmcm9tIHRoZSBET00gYXMgaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC1yZWFjdC9pc3N1ZXMvOTA1KSwgdGhlblxuICAvLyAgYG93bmVyRG9jdW1lbnRgIHdpbGwgYmUgYG51bGxgLCBoZW5jZSB0aGUgb3B0aW9uYWwgY2hhaW5pbmcgb24gaXQuXG4gIHZhciBub2RlUm9vdCA9IG5vZGUgJiYgZ2V0Um9vdE5vZGUkMShub2RlKTtcbiAgdmFyIG5vZGVSb290SG9zdCA9IChfbm9kZVJvb3QgPSBub2RlUm9vdCkgPT09IG51bGwgfHwgX25vZGVSb290ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZVJvb3QuaG9zdDtcblxuICAvLyBpbiBzb21lIGNhc2VzLCBhIGRldGFjaGVkIG5vZGUgd2lsbCByZXR1cm4gaXRzZWxmIGFzIHRoZSByb290IGluc3RlYWQgb2YgYSBkb2N1bWVudCBvclxuICAvLyAgc2hhZG93IHJvb3Qgb2JqZWN0LCBpbiB3aGljaCBjYXNlLCB3ZSBzaG91bGRuJ3QgdHJ5IHRvIGxvb2sgZnVydGhlciB1cCB0aGUgaG9zdCBjaGFpblxuICB2YXIgYXR0YWNoZWQgPSBmYWxzZTtcbiAgaWYgKG5vZGVSb290ICYmIG5vZGVSb290ICE9PSBub2RlKSB7XG4gICAgdmFyIF9ub2RlUm9vdEhvc3QsIF9ub2RlUm9vdEhvc3Qkb3duZXJEbywgX25vZGUkb3duZXJEb2N1bWVudDtcbiAgICBhdHRhY2hlZCA9ICEhKChfbm9kZVJvb3RIb3N0ID0gbm9kZVJvb3RIb3N0KSAhPT0gbnVsbCAmJiBfbm9kZVJvb3RIb3N0ICE9PSB2b2lkIDAgJiYgKF9ub2RlUm9vdEhvc3Qkb3duZXJEbyA9IF9ub2RlUm9vdEhvc3Qub3duZXJEb2N1bWVudCkgIT09IG51bGwgJiYgX25vZGVSb290SG9zdCRvd25lckRvICE9PSB2b2lkIDAgJiYgX25vZGVSb290SG9zdCRvd25lckRvLmNvbnRhaW5zKG5vZGVSb290SG9zdCkgfHwgbm9kZSAhPT0gbnVsbCAmJiBub2RlICE9PSB2b2lkIDAgJiYgKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9ub2RlJG93bmVyRG9jdW1lbnQgIT09IHZvaWQgMCAmJiBfbm9kZSRvd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGUpKTtcbiAgICB3aGlsZSAoIWF0dGFjaGVkICYmIG5vZGVSb290SG9zdCkge1xuICAgICAgdmFyIF9ub2RlUm9vdDIsIF9ub2RlUm9vdEhvc3QyLCBfbm9kZVJvb3RIb3N0MiRvd25lckQ7XG4gICAgICAvLyBzaW5jZSBpdCdzIG5vdCBhdHRhY2hlZCBhbmQgd2UgaGF2ZSBhIHJvb3QgaG9zdCwgdGhlIG5vZGUgTVVTVCBiZSBpbiBhIG5lc3RlZCBzaGFkb3cgRE9NLFxuICAgICAgLy8gIHdoaWNoIG1lYW5zIHdlIG5lZWQgdG8gZ2V0IHRoZSBob3N0J3MgaG9zdCBhbmQgY2hlY2sgaWYgdGhhdCBwYXJlbnQgaG9zdCBpcyBjb250YWluZWRcbiAgICAgIC8vICBpbiAoaS5lLiBhdHRhY2hlZCB0bykgdGhlIGRvY3VtZW50XG4gICAgICBub2RlUm9vdCA9IGdldFJvb3ROb2RlJDEobm9kZVJvb3RIb3N0KTtcbiAgICAgIG5vZGVSb290SG9zdCA9IChfbm9kZVJvb3QyID0gbm9kZVJvb3QpID09PSBudWxsIHx8IF9ub2RlUm9vdDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlUm9vdDIuaG9zdDtcbiAgICAgIGF0dGFjaGVkID0gISEoKF9ub2RlUm9vdEhvc3QyID0gbm9kZVJvb3RIb3N0KSAhPT0gbnVsbCAmJiBfbm9kZVJvb3RIb3N0MiAhPT0gdm9pZCAwICYmIChfbm9kZVJvb3RIb3N0MiRvd25lckQgPSBfbm9kZVJvb3RIb3N0Mi5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfbm9kZVJvb3RIb3N0MiRvd25lckQgIT09IHZvaWQgMCAmJiBfbm9kZVJvb3RIb3N0MiRvd25lckQuY29udGFpbnMobm9kZVJvb3RIb3N0KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhdHRhY2hlZDtcbn07XG52YXIgaXNaZXJvQXJlYSA9IGZ1bmN0aW9uIGlzWmVyb0FyZWEobm9kZSkge1xuICB2YXIgX25vZGUkZ2V0Qm91bmRpbmdDbGllID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICB3aWR0aCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZS53aWR0aCxcbiAgICBoZWlnaHQgPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUuaGVpZ2h0O1xuICByZXR1cm4gd2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwO1xufTtcbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uIGlzSGlkZGVuKG5vZGUsIF9yZWYpIHtcbiAgdmFyIGRpc3BsYXlDaGVjayA9IF9yZWYuZGlzcGxheUNoZWNrLFxuICAgIGdldFNoYWRvd1Jvb3QgPSBfcmVmLmdldFNoYWRvd1Jvb3Q7XG4gIC8vIE5PVEU6IHZpc2liaWxpdHkgd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBub2RlIGlzIGRldGFjaGVkIGZyb20gdGhlIGRvY3VtZW50XG4gIC8vICAoc2VlIG5vdGVzIGFib3V0IHRoaXMgZnVydGhlciBkb3duKSwgd2hpY2ggbWVhbnMgd2Ugd2lsbCBjb25zaWRlciBpdCB2aXNpYmxlXG4gIC8vICAodGhpcyBpcyBsZWdhY3kgYmVoYXZpb3IgZnJvbSBhIHZlcnkgbG9uZyB3YXkgYmFjaylcbiAgLy8gTk9URTogd2UgY2hlY2sgdGhpcyByZWdhcmRsZXNzIG9mIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIGJlY2F1c2UgdGhpcyBpcyBhXG4gIC8vICBfdmlzaWJpbGl0eV8gY2hlY2ssIG5vdCBhIF9kaXNwbGF5XyBjaGVja1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpc0RpcmVjdFN1bW1hcnkgPSBtYXRjaGVzLmNhbGwobm9kZSwgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyk7XG4gIHZhciBub2RlVW5kZXJEZXRhaWxzID0gaXNEaXJlY3RTdW1tYXJ5ID8gbm9kZS5wYXJlbnRFbGVtZW50IDogbm9kZTtcbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlVW5kZXJEZXRhaWxzLCAnZGV0YWlsczpub3QoW29wZW5dKSAqJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWRpc3BsYXlDaGVjayB8fCBkaXNwbGF5Q2hlY2sgPT09ICdmdWxsJyB8fCBkaXNwbGF5Q2hlY2sgPT09ICdsZWdhY3ktZnVsbCcpIHtcbiAgICBpZiAodHlwZW9mIGdldFNoYWRvd1Jvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgd2Ugc2hvdWxkIGNvbnNpZGVyIHRoZSBub2RlIHRvIGJlIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyBhbmQgdXNlIHRoZVxuICAgICAgLy8gICdub24temVyby1hcmVhJyBmYWxsYmFja1xuICAgICAgdmFyIG9yaWdpbmFsTm9kZSA9IG5vZGU7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgdmFyIHJvb3ROb2RlID0gZ2V0Um9vdE5vZGUkMShub2RlKTtcbiAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQgJiYgIXBhcmVudEVsZW1lbnQuc2hhZG93Um9vdCAmJiBnZXRTaGFkb3dSb290KHBhcmVudEVsZW1lbnQpID09PSB0cnVlIC8vIGNoZWNrIGlmIHRoZXJlJ3MgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5vZGUgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyB3aGljaCBtZWFucyB3ZSBjYW4gb25seSB0cmVhdCBpdCBhcyBhIGJsYWNrIGJveCwgc28gd2VcbiAgICAgICAgICAvLyAgZmFsbCBiYWNrIHRvIGEgbm9uLXplcm8tYXJlYSB0ZXN0XG4gICAgICAgICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIHNsb3RcbiAgICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmVudEVsZW1lbnQgJiYgcm9vdE5vZGUgIT09IG5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgIC8vIGNyb3NzIHNoYWRvdyBib3VuZGFyeVxuICAgICAgICAgIG5vZGUgPSByb290Tm9kZS5ob3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgbm9ybWFsIGRvbVxuICAgICAgICAgIG5vZGUgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlID0gb3JpZ2luYWxOb2RlO1xuICAgIH1cbiAgICAvLyBlbHNlLCBgZ2V0U2hhZG93Um9vdGAgbWlnaHQgYmUgdHJ1ZSwgYnV0IGFsbCB0aGF0IGRvZXMgaXMgZW5hYmxlIHNoYWRvdyBET00gc3VwcG9ydFxuICAgIC8vICAoaS5lLiBpdCBkb2VzIG5vdCBhbHNvIHByZXN1bWUgdGhhdCBhbGwgbm9kZXMgbWlnaHQgaGF2ZSB1bmRpc2Nsb3NlZCBzaGFkb3dzKTsgb3JcbiAgICAvLyAgaXQgbWlnaHQgYmUgYSBmYWxzeSB2YWx1ZSwgd2hpY2ggbWVhbnMgc2hhZG93IERPTSBzdXBwb3J0IGlzIGRpc2FibGVkXG5cbiAgICAvLyBTaW5jZSB3ZSBkaWRuJ3QgZmluZCBpdCBzaXR0aW5nIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyAob3Igc2hhZG93cyBhcmUgZGlzYWJsZWQpXG4gICAgLy8gIG5vdyB3ZSBjYW4ganVzdCB0ZXN0IHRvIHNlZSBpZiBpdCB3b3VsZCBub3JtYWxseSBiZSB2aXNpYmxlIG9yIG5vdCwgcHJvdmlkZWQgaXQnc1xuICAgIC8vICBhdHRhY2hlZCB0byB0aGUgbWFpbiBkb2N1bWVudC5cbiAgICAvLyBOT1RFOiBXZSBtdXN0IGNvbnNpZGVyIGNhc2Ugd2hlcmUgbm9kZSBpcyBpbnNpZGUgYSBzaGFkb3cgRE9NIGFuZCBnaXZlbiBkaXJlY3RseSB0b1xuICAgIC8vICBgaXNUYWJiYWJsZSgpYCBvciBgaXNGb2N1c2FibGUoKWAgLS0gcmVnYXJkbGVzcyBvZiBgZ2V0U2hhZG93Um9vdGAgb3B0aW9uIHNldHRpbmcuXG5cbiAgICBpZiAoaXNOb2RlQXR0YWNoZWQobm9kZSkpIHtcbiAgICAgIC8vIHRoaXMgd29ya3Mgd2hlcmV2ZXIgdGhlIG5vZGUgaXM6IGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGNsaWVudCByZWN0LCBpdCdzXG4gICAgICAvLyAgc29tZWhvdyBkaXNwbGF5ZWQ7IGl0IGFsc28gY292ZXJzIHRoZSBDU1MgJ2Rpc3BsYXk6IGNvbnRlbnRzJyBjYXNlIHdoZXJlIHRoZVxuICAgICAgLy8gIG5vZGUgaXRzZWxmIGlzIGhpZGRlbiBpbiBwbGFjZSBvZiBpdHMgY29udGVudHM7IGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoXG4gICAgICAvLyAgdXAgdGhlIGhpZXJhcmNoeSBlaXRoZXJcbiAgICAgIHJldHVybiAhbm9kZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBFbHNlLCB0aGUgbm9kZSBpc24ndCBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoZSBgZ2V0Q2xpZW50UmVjdHMoKWBcbiAgICAvLyAgQVBJIHdpbGwgX19hbHdheXNfXyByZXR1cm4gemVybyByZWN0cyAodGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgUmVhY3RcbiAgICAvLyAgaXMgdXNlZCB0byByZW5kZXIgbm9kZXMgb250byBhIGRldGFjaGVkIHRyZWUsIGFzIGNvbmZpcm1lZCBpbiB0aGlzIHRocmVhZDpcbiAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy85MTE3I2lzc3VlY29tbWVudC0yODQyMjg4NzApXG4gICAgLy9cbiAgICAvLyBJdCBhbHNvIG1lYW5zIHRoYXQgZXZlbiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgLy8gIGJlY2F1c2Ugc3R5bGVzIGFyZSBvbmx5IGNvbXB1dGVkIGZvciBub2RlcyB0aGF0IGFyZSBpbiB0aGUgZG9jdW1lbnQuXG4gICAgLy9cbiAgICAvLyBOT1RFOiBUSElTIEhBUyBCRUVOIFRIRSBDQVNFIEZPUiBZRUFSUy4gSXQgaXMgbm90IG5ldywgbm9yIGlzIGl0IGNhdXNlZCBieSB0YWJiYWJsZVxuICAgIC8vICBzb21laG93LiBUaG91Z2ggaXQgd2FzIG5ldmVyIHN0YXRlZCBvZmZpY2lhbGx5LCBhbnlvbmUgd2hvIGhhcyBldmVyIHVzZWQgdGFiYmFibGVcbiAgICAvLyAgQVBJcyBvbiBub2RlcyBpbiBkZXRhY2hlZCBjb250YWluZXJzIGhhcyBhY3R1YWxseSBpbXBsaWNpdGx5IHVzZWQgdGFiYmFibGUgaW4gd2hhdFxuICAgIC8vICB3YXMgbGF0ZXIgKGFzIG9mIHY1LjIuMCBvbiBBcHIgOSwgMjAyMSkgY2FsbGVkIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIG1vZGUgLS0gZXNzZW50aWFsbHlcbiAgICAvLyAgY29uc2lkZXJpbmcgX19ldmVyeXRoaW5nX18gdG8gYmUgdmlzaWJsZSBiZWNhdXNlIG9mIHRoZSBpbm5hYmlsaXR5IHRvIGRldGVybWluZSBzdHlsZXMuXG4gICAgLy9cbiAgICAvLyB2Ni4wLjA6IEFzIG9mIHRoaXMgbWFqb3IgcmVsZWFzZSwgdGhlIGRlZmF1bHQgJ2Z1bGwnIG9wdGlvbiBfX25vIGxvbmdlciB0cmVhdHMgZGV0YWNoZWRcbiAgICAvLyAgbm9kZXMgYXMgdmlzaWJsZSB3aXRoIHRoZSAnbm9uZScgZmFsbGJhY2suX19cbiAgICBpZiAoZGlzcGxheUNoZWNrICE9PSAnbGVnYWN5LWZ1bGwnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gaGlkZGVuXG4gICAgfVxuICAgIC8vIGVsc2UsIGZhbGxiYWNrIHRvICdub25lJyBtb2RlIGFuZCBjb25zaWRlciB0aGUgbm9kZSB2aXNpYmxlXG4gIH0gZWxzZSBpZiAoZGlzcGxheUNoZWNrID09PSAnbm9uLXplcm8tYXJlYScpIHtcbiAgICAvLyBOT1RFOiBFdmVuIHRob3VnaCB0aGlzIHRlc3RzIHRoYXQgdGhlIG5vZGUncyBjbGllbnQgcmVjdCBpcyBub24temVybyB0byBkZXRlcm1pbmVcbiAgICAvLyAgd2hldGhlciBpdCdzIGRpc3BsYXllZCwgYW5kIHRoYXQgYSBkZXRhY2hlZCBub2RlIHdpbGwgX19hbHdheXNfXyBoYXZlIGEgemVyby1hcmVhXG4gICAgLy8gIGNsaWVudCByZWN0LCB3ZSBkb24ndCBzcGVjaWFsLWNhc2UgZm9yIHdoZXRoZXIgdGhlIG5vZGUgaXMgYXR0YWNoZWQgb3Igbm90LiBJblxuICAgIC8vICB0aGlzIG1vZGUsIHdlIGRvIHdhbnQgdG8gY29uc2lkZXIgbm9kZXMgdGhhdCBoYXZlIGEgemVybyBhcmVhIHRvIGJlIGhpZGRlbiBhdCBhbGxcbiAgICAvLyAgdGltZXMsIGFuZCB0aGF0IGluY2x1ZGVzIGF0dGFjaGVkIG9yIG5vdC5cbiAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgfVxuXG4gIC8vIHZpc2libGUsIGFzIGZhciBhcyB3ZSBjYW4gdGVsbCwgb3IgcGVyIGN1cnJlbnQgYGRpc3BsYXlDaGVjaz1ub25lYCBtb2RlLCB3ZSBhc3N1bWVcbiAgLy8gIGl0J3MgdmlzaWJsZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBmb3JtIGZpZWxkcyAobmVzdGVkKSBpbnNpZGUgYSBkaXNhYmxlZCBmaWVsZHNldCBhcmUgbm90IGZvY3VzYWJsZS90YWJiYWJsZVxuLy8gIHVubGVzcyB0aGV5IGFyZSBpbiB0aGUgX2ZpcnN0XyA8bGVnZW5kPiBlbGVtZW50IG9mIHRoZSB0b3AtbW9zdCBkaXNhYmxlZFxuLy8gIGZpZWxkc2V0XG52YXIgaXNEaXNhYmxlZEZyb21GaWVsZHNldCA9IGZ1bmN0aW9uIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQobm9kZSkge1xuICBpZiAoL14oSU5QVVR8QlVUVE9OfFNFTEVDVHxURVhUQVJFQSkkLy50ZXN0KG5vZGUudGFnTmFtZSkpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAvLyBjaGVjayBpZiBgbm9kZWAgaXMgY29udGFpbmVkIGluIGEgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS50YWdOYW1lID09PSAnRklFTERTRVQnICYmIHBhcmVudE5vZGUuZGlzYWJsZWQpIHtcbiAgICAgICAgLy8gbG9vayBmb3IgdGhlIGZpcnN0IDxsZWdlbmQ+IGFtb25nIHRoZSBjaGlsZHJlbiBvZiB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnROb2RlLmNoaWxkcmVuLml0ZW0oaSk7XG4gICAgICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgPGxlZ2VuZD4gKGluIGRvY3VtZW50IG9yZGVyKSBpcyBmb3VuZFxuICAgICAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnTEVHRU5EJykge1xuICAgICAgICAgICAgLy8gaWYgaXRzIHBhcmVudCA8ZmllbGRzZXQ+IGlzIG5vdCBuZXN0ZWQgaW4gYW5vdGhlciBkaXNhYmxlZCA8ZmllbGRzZXQ+LFxuICAgICAgICAgICAgLy8gcmV0dXJuIHdoZXRoZXIgYG5vZGVgIGlzIGEgZGVzY2VuZGFudCBvZiBpdHMgZmlyc3QgPGxlZ2VuZD5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwocGFyZW50Tm9kZSwgJ2ZpZWxkc2V0W2Rpc2FibGVkXSAqJykgPyB0cnVlIDogIWNoaWxkLmNvbnRhaW5zKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PiBjb250YWluaW5nIGBub2RlYCBoYXMgbm8gPGxlZ2VuZD5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIGVsc2UsIG5vZGUncyB0YWJiYWJsZS9mb2N1c2FibGUgc3RhdGUgc2hvdWxkIG5vdCBiZSBhZmZlY3RlZCBieSBhIGZpZWxkc2V0J3NcbiAgLy8gIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGVcbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlID0gZnVuY3Rpb24gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKSB7XG4gIGlmIChub2RlLmRpc2FibGVkIHx8XG4gIC8vIHdlIG11c3QgZG8gYW4gaW5lcnQgbG9vayB1cCB0byBmaWx0ZXIgb3V0IGFueSBlbGVtZW50cyBpbnNpZGUgYW4gaW5lcnQgYW5jZXN0b3JcbiAgLy8gIGJlY2F1c2Ugd2UncmUgbGltaXRlZCBpbiB0aGUgdHlwZSBvZiBzZWxlY3RvcnMgd2UgY2FuIHVzZSBpbiBKU0RvbSAoc2VlIHJlbGF0ZWRcbiAgLy8gIG5vdGUgcmVsYXRlZCB0byBgY2FuZGlkYXRlU2VsZWN0b3JzYClcbiAgaXNJbmVydChub2RlKSB8fCBpc0hpZGRlbklucHV0KG5vZGUpIHx8IGlzSGlkZGVuKG5vZGUsIG9wdGlvbnMpIHx8XG4gIC8vIEZvciBhIGRldGFpbHMgZWxlbWVudCB3aXRoIGEgc3VtbWFyeSwgdGhlIHN1bW1hcnkgZWxlbWVudCBnZXRzIHRoZSBmb2N1c1xuICBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB8fCBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUgPSBmdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSkge1xuICBpZiAoaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHx8IGdldFRhYmluZGV4KG5vZGUpIDwgMCB8fCAhaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUoc2hhZG93SG9zdE5vZGUpIHtcbiAgdmFyIHRhYkluZGV4ID0gcGFyc2VJbnQoc2hhZG93SG9zdE5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG4gIGlmIChpc05hTih0YWJJbmRleCkgfHwgdGFiSW5kZXggPj0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElmIGEgY3VzdG9tIGVsZW1lbnQgaGFzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIHRhYmluZGV4LFxuICAvLyBicm93c2VycyB3aWxsIG5vdCBhbGxvdyB0YWIgdGFyZ2V0aW5nIHNhaWQgZWxlbWVudCdzIGNoaWxkcmVuLlxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlU2NvcGU+fSBjYW5kaWRhdGVzXG4gKiBAcmV0dXJucyBFbGVtZW50W11cbiAqL1xudmFyIHNvcnRCeU9yZGVyID0gZnVuY3Rpb24gc29ydEJ5T3JkZXIoY2FuZGlkYXRlcykge1xuICB2YXIgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICB2YXIgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuICBjYW5kaWRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICB2YXIgaXNTY29wZSA9ICEhaXRlbS5zY29wZVBhcmVudDtcbiAgICB2YXIgZWxlbWVudCA9IGlzU2NvcGUgPyBpdGVtLnNjb3BlUGFyZW50IDogaXRlbTtcbiAgICB2YXIgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRUYWJpbmRleChlbGVtZW50LCBpc1Njb3BlKTtcbiAgICB2YXIgZWxlbWVudHMgPSBpc1Njb3BlID8gc29ydEJ5T3JkZXIoaXRlbS5jYW5kaWRhdGVzKSA6IGVsZW1lbnQ7XG4gICAgaWYgKGNhbmRpZGF0ZVRhYmluZGV4ID09PSAwKSB7XG4gICAgICBpc1Njb3BlID8gcmVndWxhclRhYmJhYmxlcy5wdXNoLmFwcGx5KHJlZ3VsYXJUYWJiYWJsZXMsIGVsZW1lbnRzKSA6IHJlZ3VsYXJUYWJiYWJsZXMucHVzaChlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgZG9jdW1lbnRPcmRlcjogaSxcbiAgICAgICAgdGFiSW5kZXg6IGNhbmRpZGF0ZVRhYmluZGV4LFxuICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICBpc1Njb3BlOiBpc1Njb3BlLFxuICAgICAgICBjb250ZW50OiBlbGVtZW50c1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9yZGVyZWRUYWJiYWJsZXMuc29ydChzb3J0T3JkZXJlZFRhYmJhYmxlcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHNvcnRhYmxlKSB7XG4gICAgc29ydGFibGUuaXNTY29wZSA/IGFjYy5wdXNoLmFwcGx5KGFjYywgc29ydGFibGUuY29udGVudCkgOiBhY2MucHVzaChzb3J0YWJsZS5jb250ZW50KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSkuY29uY2F0KHJlZ3VsYXJUYWJiYWJsZXMpO1xufTtcbnZhciB0YWJiYWJsZSA9IGZ1bmN0aW9uIHRhYmJhYmxlKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogZmFsc2UsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgICBzaGFkb3dSb290RmlsdGVyOiBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoZWwsIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICB9XG4gIHJldHVybiBzb3J0QnlPcmRlcihjYW5kaWRhdGVzKTtcbn07XG52YXIgZm9jdXNhYmxlID0gZnVuY3Rpb24gZm9jdXNhYmxlKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3RcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhlbCwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcbnZhciBpc1RhYmJhYmxlID0gZnVuY3Rpb24gaXNUYWJiYWJsZShub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG52YXIgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi9jYW5kaWRhdGVTZWxlY3RvcnMuY29uY2F0KCdpZnJhbWUnKS5qb2luKCcsJyk7XG52YXIgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiBpc0ZvY3VzYWJsZShub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGBmb2N1cy10cmFwL3RhYmJhYmxlYCBvcHRpb25zLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC90YWJiYWJsZSN0YWJiYWJsZVxuICovXG5jb25zdCB0YWJiYWJsZU9wdGlvbnMgPSB7XG4gIGdldFNoYWRvd1Jvb3Q6IHRydWVcbn07XG4vKipcbiAqIFRoaXMgaGVscGVyIHdpbGwgZ3VhcmFudGVlIGFuIElEIG9uIHRoZSBwcm92aWRlZCBlbGVtZW50LlxuICpcbiAqIElmIGl0IGFscmVhZHkgaGFzIGFuIElELCBpdCB3aWxsIGJlIHByZXNlcnZlZCwgb3RoZXJ3aXNlIGEgdW5pcXVlIG9uZSB3aWxsIGJlIGdlbmVyYXRlZCBhbmQgYXNzaWduZWQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBBbiBlbGVtZW50LlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVsZW1lbnQncyBJRC5cbiAqL1xuZnVuY3Rpb24gZW5zdXJlSWQoZWwpIHtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHJldHVybiAoZWwuaWQgPSBlbC5pZCB8fCBgJHtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9LSR7Z3VpZCgpfWApO1xufVxuLyoqXG4gKiBUaGlzIGhlbHBlciByZXR1cm5zIGFuIGFycmF5IGZyb20gYSBOb2RlTGlzdC5cbiAqXG4gKiBAcGFyYW0ge05vZGVMaXN0fSBub2RlTGlzdCBBIE5vZGVMaXN0LlxuICogQHJldHVybnMge0VsZW1lbnRbXX0gQW4gYXJyYXkgb2YgZWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIG5vZGVMaXN0VG9BcnJheShub2RlTGlzdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShub2RlTGlzdCkgPyBub2RlTGlzdCA6IEFycmF5LmZyb20obm9kZUxpc3QpO1xufVxuLyoqXG4gKiBUaGlzIGhlbHBlciByZXR1cm5zIHRoZSBDYWxjaXRlIFwibW9kZVwiIG9mIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgQW4gZWxlbWVudC5cbiAqIEByZXR1cm5zIHtcImxpZ2h0XCJ8XCJkYXJrXCJ9IFRoZSBDYWxjaXRlIG1vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVOYW1lKGVsKSB7XG4gIGNvbnN0IGNsb3Nlc3RFbFdpdGhNb2RlID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsLCBgLiR7Q1NTX1VUSUxJVFkuZGFya01vZGV9LCAuJHtDU1NfVVRJTElUWS5saWdodE1vZGV9YCk7XG4gIHJldHVybiBjbG9zZXN0RWxXaXRoTW9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKFwiY2FsY2l0ZS1tb2RlLWRhcmtcIikgPyBcImRhcmtcIiA6IFwibGlnaHRcIjtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgcmV0dXJucyB0aGUgZGlyZWN0aW9uIG9mIGEgSFRNTCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEFuIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7RGlyZWN0aW9ufSBUaGUgZGlyZWN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRFbGVtZW50RGlyKGVsKSB7XG4gIGNvbnN0IHByb3AgPSBcImRpclwiO1xuICBjb25zdCBzZWxlY3RvciA9IGBbJHtwcm9wfV1gO1xuICBjb25zdCBjbG9zZXN0ID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsLCBzZWxlY3Rvcik7XG4gIHJldHVybiBjbG9zZXN0ID8gY2xvc2VzdC5nZXRBdHRyaWJ1dGUocHJvcCkgOiBcImx0clwiO1xufVxuLyoqXG4gKiBUaGlzIGhlbHBlciByZXR1cm5zIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBBbiBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBBbiBhdHRyaWJ1dGUgbmFtZS5cbiAqIEBwYXJhbSB7YW55fSBmYWxsYmFja1ZhbHVlIEEgZmFsbGJhY2sgdmFsdWUuXG4gKiBAcmV0dXJucyB7YW55fSBUaGUgdmFsdWUuXG4gKiBAZGVwcmVjYXRlZFxuICovXG5mdW5jdGlvbiBnZXRFbGVtZW50UHJvcChlbCwgYXR0cmlidXRlLCBmYWxsYmFja1ZhbHVlKSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gYFske2F0dHJpYnV0ZX1dYDtcbiAgY29uc3QgY2xvc2VzdCA9IGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICByZXR1cm4gY2xvc2VzdCA/IGNsb3Nlc3QuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgOiBmYWxsYmFja1ZhbHVlO1xufVxuLyoqXG4gKiBUaGlzIGhlbHBlciByZXR1cm5zIHRoZSByb290Tm9kZSBvZiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgQW4gZWxlbWVudC5cbiAqIEByZXR1cm5zIHtEb2N1bWVudHxTaGFkb3dSb290fSBUaGUgZWxlbWVudCdzIHJvb3Qgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdE5vZGUoZWwpIHtcbiAgcmV0dXJuIGVsLmdldFJvb3ROb2RlKCk7XG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHJldHVybnMgdGhlIG5vZGUncyBzaGFkb3dSb290IHJvb3Qgbm9kZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBUaGUgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtTaGFkb3dSb290fG51bGx9IFRoZSBlbGVtZW50J3Mgcm9vdCBub2RlIFNoYWRvd1Jvb3QuXG4gKi9cbmZ1bmN0aW9uIGdldFNoYWRvd1Jvb3ROb2RlKGVsKSB7XG4gIGNvbnN0IHJvb3ROb2RlID0gZ2V0Um9vdE5vZGUoZWwpO1xuICByZXR1cm4gXCJob3N0XCIgaW4gcm9vdE5vZGUgPyByb290Tm9kZSA6IG51bGw7XG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHJldHVybnMgdGhlIGhvc3Qgb2YgYSBTaGFkb3dSb290LlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnQgfCBTaGFkb3dSb290fSByb290IEEgcm9vdCBlbGVtZW50LlxuICogQHJldHVybnMge0VsZW1lbnQgfCBudWxsfSBUaGUgaG9zdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBnZXRIb3N0KHJvb3QpIHtcbiAgcmV0dXJuIHJvb3QuaG9zdCB8fCBudWxsO1xufVxuLyoqXG4gKiBUaGlzIGhlbHBlciBxdWVyaWVzIGFuIGVsZW1lbnQncyByb290Tm9kZSBhbmQgYW55IGFuY2VzdG9yIHJvb3ROb2Rlcy5cbiAqXG4gKiBJZiBib3RoIGFuICdpZCcgYW5kICdzZWxlY3RvcicgYXJlIHN1cHBsaWVkLCAnaWQnIHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXIgJ3NlbGVjdG9yJy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgQW4gZWxlbWVudC5cbiAqIEBwYXJhbSByb290MFxuICogQHBhcmFtIHJvb3QwLnNlbGVjdG9yXG4gKiBAcGFyYW0gcm9vdDAuaWRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBBbiBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBxdWVyeUVsZW1lbnRSb290cyhlbGVtZW50LCB7IHNlbGVjdG9yLCBpZCB9KSB7XG4gIC8vIEdldHMgdGhlIHJvb3ROb2RlIGFuZCBhbnkgYW5jZXN0b3Igcm9vdE5vZGVzIChzaGFkb3dSb290IG9yIGRvY3VtZW50KSBvZiBhbiBlbGVtZW50IGFuZCBxdWVyaWVzIHRoZW0gZm9yIGEgc2VsZWN0b3IuXG4gIC8vIEJhc2VkIG9uOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvNTQ1MjA1NTQvMTk0MjE2XG4gIGZ1bmN0aW9uIHF1ZXJ5RnJvbShlbCkge1xuICAgIGlmICghZWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZWwuYXNzaWduZWRTbG90KSB7XG4gICAgICBlbCA9IGVsLmFzc2lnbmVkU2xvdDtcbiAgICB9XG4gICAgY29uc3Qgcm9vdE5vZGUgPSBnZXRSb290Tm9kZShlbCk7XG4gICAgY29uc3QgZm91bmQgPSBpZFxuICAgICAgPyBcImdldEVsZW1lbnRCeUlkXCIgaW4gcm9vdE5vZGVcbiAgICAgICAgPyAvKlxuICAgICAgICAgIENoZWNrIHRvIG1ha2Ugc3VyZSAnZ2V0RWxlbWVudEJ5SWQnIGV4aXN0cyBpbiBjYXNlcyB3aGVyZSBlbGVtZW50IGlzIG5vIGxvbmdlciBjb25uZWN0ZWQgdG8gdGhlIERPTSBhbmQgZ2V0Um9vdE5vZGUoKSByZXR1cm5zIHRoZSBlbGVtZW50LlxuICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9wdWxsLzQyODBcbiAgICAgICAgICAgKi9cbiAgICAgICAgICByb290Tm9kZS5nZXRFbGVtZW50QnlJZChpZClcbiAgICAgICAgOiBudWxsXG4gICAgICA6IHNlbGVjdG9yXG4gICAgICAgID8gcm9vdE5vZGUucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGhvc3QgPSBnZXRIb3N0KHJvb3ROb2RlKTtcbiAgICByZXR1cm4gZm91bmQgPyBmb3VuZCA6IGhvc3QgPyBxdWVyeUZyb20oaG9zdCkgOiBudWxsO1xuICB9XG4gIHJldHVybiBxdWVyeUZyb20oZWxlbWVudCk7XG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHJldHVybnMgdGhlIGNsb3Nlc3QgZWxlbWVudCBtYXRjaGluZyB0aGUgc2VsZWN0b3IgYnkgY3Jvc3NpbmcgaGUgc2hhZG93IGJvdW5kYXJ5IGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIHN0YXJ0aW5nIGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIHNlbGVjdG9yLlxuICogQHJldHVybnMge0VsZW1lbnR9IFRoZSB0YXJnZXRlZCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgLy8gYmFzZWQgb24gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzU0NTIwNTU0LzE5NDIxNlxuICBmdW5jdGlvbiBjbG9zZXN0RnJvbShlbCkge1xuICAgIHJldHVybiBlbCA/IGVsLmNsb3Nlc3Qoc2VsZWN0b3IpIHx8IGNsb3Nlc3RGcm9tKGdldEhvc3QoZ2V0Um9vdE5vZGUoZWwpKSkgOiBudWxsO1xuICB9XG4gIHJldHVybiBjbG9zZXN0RnJvbShlbGVtZW50KTtcbn1cbi8qKlxuICogVGhpcyB1dGlsaXR5IGhlbHBzIGludm9rZSBhIGNhbGxiYWNrIGFzIGl0IHRyYXZlcnNlcyBhIG5vZGUgYW5kIGl0cyBhbmNlc3RvcnMgdW50aWwgcmVhY2hpbmcgdGhlIHJvb3QgZG9jdW1lbnQuXG4gKlxuICogUmV0dXJuaW5nIGVhcmx5IG9yIHVuZGVmaW5lZCBpbiBgb25WaXNpdGAgd2lsbCBjb250aW51ZSB0cmF2ZXJzaW5nIHVwIHRoZSBET00gdHJlZS4gT3RoZXJ3aXNlLCB0cmF2ZXJzYWwgd2lsbCBoYWx0IHdpdGggdGhlIHJldHVybmVkIHZhbHVlIGFzIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEFuIGVsZW1lbnQuXG4gKiBAcGFyYW0geyhub2RlOiBOb2RlKSA9PiBFbGVtZW50fSBvblZpc2l0IFRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHtFbGVtZW50fSBUaGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiB3YWxrVXBBbmNlc3RyeShlbGVtZW50LCBvblZpc2l0KSB7XG4gIHJldHVybiB2aXNpdChlbGVtZW50LCBvblZpc2l0KTtcbn1cbmZ1bmN0aW9uIHZpc2l0KG5vZGUsIG9uVmlzaXQpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG9uVmlzaXQobm9kZSk7XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgeyBwYXJlbnROb2RlIH0gPSBub2RlO1xuICByZXR1cm4gdmlzaXQocGFyZW50Tm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyBwYXJlbnROb2RlLmhvc3QgOiBwYXJlbnROb2RlLCBvblZpc2l0KTtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgcmV0dXJucyB0cnVlIHdoZW4gYW4gZWxlbWVudCBoYXMgdGhlIGRlc2NlbmRhbnQgaW4gcXVlc3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBzdGFydGluZyBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBtYXliZURlc2NlbmRhbnQgVGhlIGRlc2NlbmRhbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIG1heWJlRGVzY2VuZGFudCkge1xuICByZXR1cm4gISF3YWxrVXBBbmNlc3RyeShtYXliZURlc2NlbmRhbnQsIChub2RlKSA9PiAobm9kZSA9PT0gZWxlbWVudCA/IHRydWUgOiB1bmRlZmluZWQpKTtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgcmV0dXJucyB0cnVlIHdoZW4gYW4gZWxlbWVudCBoYXMgYSBzZXRGb2N1cyBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBBbiBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzQ2FsY2l0ZUZvY3VzYWJsZShlbCkge1xuICByZXR1cm4gdHlwZW9mIGVsPy5zZXRGb2N1cyA9PT0gXCJmdW5jdGlvblwiO1xufVxuLyoqXG4gKiBUaGlzIGhlbHBlciBmb2N1c2VzIGFuIGVsZW1lbnQgdXNpbmcgdGhlIGBzZXRGb2N1c2AgbWV0aG9kIGlmIGF2YWlsYWJsZSBhbmQgZmFsbHMgYmFjayB0byB1c2luZyB0aGUgYGZvY3VzYCBtZXRob2QgaWYgbm90IGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIEFuIGVsZW1lbnQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZvY3VzRWxlbWVudChlbCkge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBpc0NhbGNpdGVGb2N1c2FibGUoZWwpID8gZWwuc2V0Rm9jdXMoKSA6IGVsLmZvY3VzKCk7XG59XG4vKipcbiAqIEhlbHBlciB0byBmb2N1cyB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBodG1sIGVsZW1lbnQgY29udGFpbmluZyB0YWJiYWJsZSBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gZm9jdXNGaXJzdFRhYmJhYmxlKGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gICh0YWJiYWJsZShlbGVtZW50LCB0YWJiYWJsZU9wdGlvbnMpWzBdIHx8IGVsZW1lbnQpLmZvY3VzKCk7XG59XG5jb25zdCBkZWZhdWx0U2xvdFNlbGVjdG9yID0gXCI6bm90KFtzbG90XSlcIjtcbmZ1bmN0aW9uIGdldFNsb3R0ZWQoZWxlbWVudCwgc2xvdE5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKHNsb3ROYW1lICYmICFBcnJheS5pc0FycmF5KHNsb3ROYW1lKSAmJiB0eXBlb2Ygc2xvdE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICBvcHRpb25zID0gc2xvdE5hbWU7XG4gICAgc2xvdE5hbWUgPSBudWxsO1xuICB9XG4gIGNvbnN0IHNsb3RTZWxlY3RvciA9IHNsb3ROYW1lXG4gICAgPyBBcnJheS5pc0FycmF5KHNsb3ROYW1lKVxuICAgICAgPyBzbG90TmFtZS5tYXAoKG5hbWUpID0+IGBbc2xvdD1cIiR7bmFtZX1cIl1gKS5qb2luKFwiLFwiKVxuICAgICAgOiBgW3Nsb3Q9XCIke3Nsb3ROYW1lfVwiXWBcbiAgICA6IGRlZmF1bHRTbG90U2VsZWN0b3I7XG4gIGlmIChvcHRpb25zPy5hbGwpIHtcbiAgICByZXR1cm4gcXVlcnlNdWx0aXBsZShlbGVtZW50LCBzbG90U2VsZWN0b3IsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBxdWVyeVNpbmdsZShlbGVtZW50LCBzbG90U2VsZWN0b3IsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0RGlyZWN0Q2hpbGRyZW4oZWwsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBlbCA/IEFycmF5LmZyb20oZWwuY2hpbGRyZW4gfHwgW10pLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkPy5tYXRjaGVzKHNlbGVjdG9yKSkgOiBbXTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5TXVsdGlwbGUoZWxlbWVudCwgc2xvdFNlbGVjdG9yLCBvcHRpb25zKSB7XG4gIGxldCBtYXRjaGVzID0gc2xvdFNlbGVjdG9yID09PSBkZWZhdWx0U2xvdFNlbGVjdG9yXG4gICAgPyBnZXREaXJlY3RDaGlsZHJlbihlbGVtZW50LCBkZWZhdWx0U2xvdFNlbGVjdG9yKVxuICAgIDogQXJyYXkuZnJvbShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2xvdFNlbGVjdG9yKSk7XG4gIG1hdGNoZXMgPSBvcHRpb25zICYmIG9wdGlvbnMuZGlyZWN0ID09PSBmYWxzZSA/IG1hdGNoZXMgOiBtYXRjaGVzLmZpbHRlcigoZWwpID0+IGVsLnBhcmVudEVsZW1lbnQgPT09IGVsZW1lbnQpO1xuICBtYXRjaGVzID0gb3B0aW9ucz8ubWF0Y2hlcyA/IG1hdGNoZXMuZmlsdGVyKChlbCkgPT4gZWw/Lm1hdGNoZXMob3B0aW9ucy5tYXRjaGVzKSkgOiBtYXRjaGVzO1xuICBjb25zdCBzZWxlY3RvciA9IG9wdGlvbnM/LnNlbGVjdG9yO1xuICByZXR1cm4gc2VsZWN0b3JcbiAgICA/IG1hdGNoZXNcbiAgICAgIC5tYXAoKGl0ZW0pID0+IEFycmF5LmZyb20oaXRlbS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkpXG4gICAgICAucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+IFsuLi5wcmV2aW91c1ZhbHVlLCAuLi5jdXJyZW50VmFsdWVdLCBbXSlcbiAgICAgIC5maWx0ZXIoKG1hdGNoKSA9PiAhIW1hdGNoKVxuICAgIDogbWF0Y2hlcztcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2luZ2xlKGVsZW1lbnQsIHNsb3RTZWxlY3Rvciwgb3B0aW9ucykge1xuICBsZXQgbWF0Y2ggPSBzbG90U2VsZWN0b3IgPT09IGRlZmF1bHRTbG90U2VsZWN0b3JcbiAgICA/IGdldERpcmVjdENoaWxkcmVuKGVsZW1lbnQsIGRlZmF1bHRTbG90U2VsZWN0b3IpWzBdIHx8IG51bGxcbiAgICA6IGVsZW1lbnQucXVlcnlTZWxlY3RvcihzbG90U2VsZWN0b3IpO1xuICBtYXRjaCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kaXJlY3QgPT09IGZhbHNlID8gbWF0Y2ggOiBtYXRjaD8ucGFyZW50RWxlbWVudCA9PT0gZWxlbWVudCA/IG1hdGNoIDogbnVsbDtcbiAgbWF0Y2ggPSBvcHRpb25zPy5tYXRjaGVzID8gKG1hdGNoPy5tYXRjaGVzKG9wdGlvbnMubWF0Y2hlcykgPyBtYXRjaCA6IG51bGwpIDogbWF0Y2g7XG4gIGNvbnN0IHNlbGVjdG9yID0gb3B0aW9ucz8uc2VsZWN0b3I7XG4gIHJldHVybiBzZWxlY3RvciA/IG1hdGNoPy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA6IG1hdGNoO1xufVxuLyoqXG4gKiBGaWx0ZXJzIGRpcmVjdCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIEFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIHNlbGVjdG9yLlxuICogQHJldHVybnMge0VsZW1lbnRbXX0gQW4gYXJyYXkgb2YgZWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckRpcmVjdENoaWxkcmVuKGVsLCBzZWxlY3Rvcikge1xuICByZXR1cm4gQXJyYXkuZnJvbShlbC5jaGlsZHJlbikuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQubWF0Y2hlcyhzZWxlY3RvcikpO1xufVxuLyoqXG4gKiBTZXQgYSBkZWZhdWx0IGljb24gZnJvbSBhIGRlZmluZWQgc2V0IG9yIGFsbG93IGFuIG92ZXJyaWRlIHdpdGggYW4gaWNvbiBuYW1lIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaWNvbk9iamVjdCBUaGUgaWNvbiBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZyB8IGJvb2xlYW59IGljb25WYWx1ZSBUaGUgaWNvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaGVkVmFsdWUgVGhlIG1hdGNoZWQgdmFsdWUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gVGhlIHJlc3VsdGluZyBpY29uIHZhbHVlLlxuICovXG5mdW5jdGlvbiBzZXRSZXF1ZXN0ZWRJY29uKGljb25PYmplY3QsIGljb25WYWx1ZSwgbWF0Y2hlZFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaWNvblZhbHVlID09PSBcInN0cmluZ1wiICYmIGljb25WYWx1ZSAhPT0gXCJcIikge1xuICAgIHJldHVybiBpY29uVmFsdWU7XG4gIH1cbiAgZWxzZSBpZiAoaWNvblZhbHVlID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGljb25PYmplY3RbbWF0Y2hlZFZhbHVlXTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGhlbHBlciByZXR1cm5zIHRydWUgd2hlbiB0d28gcmVjdGFuZ2xlcyBpbnRlcnNlY3QuXG4gKlxuICogQHBhcmFtIHtET01SZWN0fSByZWN0MSBUaGUgZmlyc3QgcmVjdGFuZ2xlLlxuICogQHBhcmFtIHtET01SZWN0fSByZWN0MiBUaGUgc2Vjb25kIHJlY3RhbmdsZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpbnRlcnNlY3RzKHJlY3QxLCByZWN0Mikge1xuICByZXR1cm4gIShyZWN0Mi5sZWZ0ID4gcmVjdDEucmlnaHQgfHxcbiAgICByZWN0Mi5yaWdodCA8IHJlY3QxLmxlZnQgfHxcbiAgICByZWN0Mi50b3AgPiByZWN0MS5ib3R0b20gfHxcbiAgICByZWN0Mi5ib3R0b20gPCByZWN0MS50b3ApO1xufVxuLyoqXG4gKiBUaGlzIGhlbHBlciBtYWtlcyBzdXJlIHRoYXQgYm9vbGVhbiBhcmlhIGF0dHJpYnV0ZXMgYXJlIHByb3Blcmx5IGNvbnZlcnRlZCB0byBhIHN0cmluZy5cbiAqXG4gKiBJdCBzaG91bGQgb25seSBiZSB1c2VkIGZvciBhcmlhIGF0dHJpYnV0ZXMgdGhhdCByZXF1aXJlIGEgc3RyaW5nIHZhbHVlIG9mIFwidHJ1ZVwiIG9yIFwiZmFsc2VcIi5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzdHJpbmcgY29udmVyc2lvbiBvZiBhIGJvb2xlYW4gdmFsdWUgKFwidHJ1ZVwiIHwgXCJmYWxzZVwiKS5cbiAqL1xuZnVuY3Rpb24gdG9BcmlhQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSkudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRhcmdldCBgc2xvdGAgZWxlbWVudCBmcm9tIHRoZSBgb25TbG90Y2hhbmdlYCBldmVudCBoYXMgYW4gYXNzaWduZWQgZWxlbWVudC5cbiAqXG4gKiBgYGBcbiAqIDxzbG90IG9uU2xvdGNoYW5nZT17KGV2ZW50KSA9PiB0aGlzLm15U2xvdEhhc0VsZW1lbnQgPSBzbG90Q2hhbmdlSGFzQXNzaWduZWRFbGVtZW50KGV2ZW50KX0gLz59XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgc2xvdCBoYXMgYW55IGFzc2lnbmVkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBzbG90Q2hhbmdlSGFzQXNzaWduZWRFbGVtZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIXNsb3RDaGFuZ2VHZXRBc3NpZ25lZEVsZW1lbnRzKGV2ZW50KS5sZW5ndGg7XG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHJldHVybnMgdGhlIGFzc2lnbmVkIGVsZW1lbnRzIG9uIGEgYHNsb3RgIGVsZW1lbnQgZnJvbSB0aGUgYG9uU2xvdGNoYW5nZWAgZXZlbnQuXG4gKlxuICogYGBgXG4gKiA8c2xvdCBvblNsb3RjaGFuZ2U9eyhldmVudCkgPT4gdGhpcy5teVNsb3RFbGVtZW50cyA9IHNsb3RDaGFuZ2VHZXRBc3NpZ25lZEVsZW1lbnRzKGV2ZW50KX0gLz59XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgc2xvdCBoYXMgYW55IGFzc2lnbmVkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBzbG90Q2hhbmdlR2V0QXNzaWduZWRFbGVtZW50cyhldmVudCkge1xuICByZXR1cm4gZXZlbnQudGFyZ2V0LmFzc2lnbmVkRWxlbWVudHMoe1xuICAgIGZsYXR0ZW46IHRydWVcbiAgfSk7XG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnRlciBldmVudCBmaXJlZCBmcm9tIHRoZSBwcmltYXJ5IGJ1dHRvbiBvZiB0aGUgZGV2aWNlLlxuICpcbiAqIFNlZSBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jdGhlLWJ1dHRvbi1wcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZlbnQgVGhlIHBvaW50ZXIgZXZlbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBpc1ByaW1hcnlQb2ludGVyQnV0dG9uKGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5pc1ByaW1hcnkgJiYgZXZlbnQuYnV0dG9uID09PSAwKTtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgc2V0cyBmb2N1cyBvbiBhbmQgcmV0dXJucyBhIGRlc3RpbmF0aW9uIGVsZW1lbnQgZnJvbSB3aXRoaW4gYSBncm91cCBvZiBwcm92aWRlZCBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnRbXX0gZWxlbWVudHMgQW4gYXJyYXkgb2YgZWxlbWVudHMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGN1cnJlbnRFbGVtZW50IFRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0ge0ZvY3VzRWxlbWVudEluR3JvdXBEZXN0aW5hdGlvbn0gZGVzdGluYXRpb24gVGhlIHRhcmdldCBkZXN0aW5hdGlvbiBlbGVtZW50IHRvIGZvY3VzLlxuICogQHBhcmFtIHtib29sZWFufSBjeWNsZSBTaG91bGQgbmF2aWdhdGlvbiBjeWNsZSB0aHJvdWdoIGVsZW1lbnRzIG9yIHN0b3AgYXQgZXh0ZW50IC0gZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqIEByZXR1cm5zIHtFbGVtZW50fSBUaGUgZm9jdXNlZCBlbGVtZW50XG4gKi9cbmNvbnN0IGZvY3VzRWxlbWVudEluR3JvdXAgPSAoZWxlbWVudHMsIGN1cnJlbnRFbGVtZW50LCBkZXN0aW5hdGlvbiwgY3ljbGUgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRJbmRleCA9IGVsZW1lbnRzLmluZGV4T2YoY3VycmVudEVsZW1lbnQpO1xuICBjb25zdCBpc0ZpcnN0SXRlbSA9IGN1cnJlbnRJbmRleCA9PT0gMDtcbiAgY29uc3QgaXNMYXN0SXRlbSA9IGN1cnJlbnRJbmRleCA9PT0gZWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgaWYgKGN5Y2xlKSB7XG4gICAgZGVzdGluYXRpb24gPVxuICAgICAgZGVzdGluYXRpb24gPT09IFwicHJldmlvdXNcIiAmJiBpc0ZpcnN0SXRlbSA/IFwibGFzdFwiIDogZGVzdGluYXRpb24gPT09IFwibmV4dFwiICYmIGlzTGFzdEl0ZW0gPyBcImZpcnN0XCIgOiBkZXN0aW5hdGlvbjtcbiAgfVxuICBsZXQgZm9jdXNUYXJnZXQ7XG4gIGlmIChkZXN0aW5hdGlvbiA9PT0gXCJwcmV2aW91c1wiKSB7XG4gICAgZm9jdXNUYXJnZXQgPSBlbGVtZW50c1tjdXJyZW50SW5kZXggLSAxXSB8fCBlbGVtZW50c1tjeWNsZSA/IGVsZW1lbnRzLmxlbmd0aCAtIDEgOiBjdXJyZW50SW5kZXhdO1xuICB9XG4gIGVsc2UgaWYgKGRlc3RpbmF0aW9uID09PSBcIm5leHRcIikge1xuICAgIGZvY3VzVGFyZ2V0ID0gZWxlbWVudHNbY3VycmVudEluZGV4ICsgMV0gfHwgZWxlbWVudHNbY3ljbGUgPyAwIDogY3VycmVudEluZGV4XTtcbiAgfVxuICBlbHNlIGlmIChkZXN0aW5hdGlvbiA9PT0gXCJsYXN0XCIpIHtcbiAgICBmb2N1c1RhcmdldCA9IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGVsc2Uge1xuICAgIGZvY3VzVGFyZ2V0ID0gZWxlbWVudHNbMF07XG4gIH1cbiAgZm9jdXNFbGVtZW50KGZvY3VzVGFyZ2V0KTtcbiAgcmV0dXJuIGZvY3VzVGFyZ2V0O1xufTtcblxuZXhwb3J0IHsgaXNGb2N1c2FibGUgYXMgQSwgdGFiYmFibGVPcHRpb25zIGFzIEIsIENTU19VVElMSVRZIGFzIEMsIGF1dG9Nb2RlIGFzIGEsIGdldFNsb3R0ZWQgYXMgYiwgZ2V0RWxlbWVudERpciBhcyBjLCBkYXJrTW9kZSBhcyBkLCBzbG90Q2hhbmdlSGFzQXNzaWduZWRFbGVtZW50IGFzIGUsIHNldFJlcXVlc3RlZEljb24gYXMgZiwgZ2V0RWxlbWVudFByb3AgYXMgZywgZm9jdXNFbGVtZW50SW5Hcm91cCBhcyBoLCBpc1ByaW1hcnlQb2ludGVyQnV0dG9uIGFzIGksIGZvY3VzRWxlbWVudCBhcyBqLCBmb2N1c0ZpcnN0VGFiYmFibGUgYXMgaywgZW5zdXJlSWQgYXMgbCwgaW50ZXJzZWN0cyBhcyBtLCBub2RlTGlzdFRvQXJyYXkgYXMgbiwgZ2V0Um9vdE5vZGUgYXMgbywgZmlsdGVyRGlyZWN0Q2hpbGRyZW4gYXMgcCwgZ2V0TW9kZU5hbWUgYXMgcSwgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IGFzIHIsIHNsb3RDaGFuZ2VHZXRBc3NpZ25lZEVsZW1lbnRzIGFzIHMsIHRvQXJpYUJvb2xlYW4gYXMgdCwgcXVlcnlFbGVtZW50Um9vdHMgYXMgdSwgZ2V0U2hhZG93Um9vdE5vZGUgYXMgdiwgY29udGFpbnNDcm9zc1NoYWRvd0JvdW5kYXJ5IGFzIHcsIHRhYmJhYmxlIGFzIHgsIGZvY3VzYWJsZSBhcyB5LCBpc1RhYmJhYmxlIGFzIHogfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjQuMlxuICovXG5mdW5jdGlvbiBnZW4oY291bnRzKSB7XG4gIHJldHVybiBjb3VudHNcbiAgICAubWFwKChjb3VudCkgPT4ge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgb3V0ICs9ICgoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApIHwgMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfSlcbiAgICAuam9pbihcIi1cIik7XG59XG5jb25zdCBndWlkID0gKCkgPT4gZ2VuKFsyLCAxLCAxLCAxLCAzXSk7XG5cbmV4cG9ydCB7IGd1aWQgYXMgZyB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuNC4yXG4gKi9cbmV4cG9ydCB7IGdldEFzc2V0UGF0aCwgc2V0QXNzZXRQYXRoLCBzZXROb25jZSwgc2V0UGxhdGZvcm1PcHRpb25zIH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvaW5kZXguanMnO1xuaW1wb3J0IHsgZCBhcyBkYXJrTW9kZSwgYSBhcyBhdXRvTW9kZSB9IGZyb20gJy4vZG9tLmpzJztcblxuLyoqXG4gKiBFbWl0cyB3aGVuIHRoZSBtb2RlIGlzIGR5bmFtaWNhbGx5IHRvZ2dsZWQgYmV0d2VlbiBsaWdodCBhbmQgZGFyayBvbiA8Ym9keT4gb3IgaW4gT1MgcHJlZmVyZW5jZXMuXG4gKi9cbmZ1bmN0aW9uIGluaXRNb2RlQ2hhbmdlRXZlbnQoKSB7XG4gIGNvbnN0IHsgY2xhc3NMaXN0IH0gPSBkb2N1bWVudC5ib2R5O1xuICBjb25zdCBwcmVmZXJzRGFyayA9IHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzO1xuICBjb25zdCBnZXRNb2RlID0gKCkgPT4gY2xhc3NMaXN0LmNvbnRhaW5zKGRhcmtNb2RlKSB8fCAoY2xhc3NMaXN0LmNvbnRhaW5zKGF1dG9Nb2RlKSAmJiBwcmVmZXJzRGFyaykgPyBcImRhcmtcIiA6IFwibGlnaHRcIjtcbiAgY29uc3QgZW1pdE1vZGVDaGFuZ2UgPSAobW9kZSkgPT4gZG9jdW1lbnQuYm9keS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImNhbGNpdGVNb2RlQ2hhbmdlXCIsIHsgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiB7IG1vZGUgfSB9KSk7XG4gIGNvbnN0IG1vZGVDaGFuZ2VIYW5kbGVyID0gKG5ld01vZGUpID0+IHtcbiAgICBjdXJyZW50TW9kZSAhPT0gbmV3TW9kZSAmJiBlbWl0TW9kZUNoYW5nZShuZXdNb2RlKTtcbiAgICBjdXJyZW50TW9kZSA9IG5ld01vZGU7XG4gIH07XG4gIGxldCBjdXJyZW50TW9kZSA9IGdldE1vZGUoKTtcbiAgLy8gZW1pdHMgZXZlbnQgb24gcGFnZSBsb2FkXG4gIGVtaXRNb2RlQ2hhbmdlKGN1cnJlbnRNb2RlKTtcbiAgLy8gZW1pdHMgZXZlbnQgd2hlbiBjaGFuZ2luZyBPUyBtb2RlIHByZWZlcmVuY2VzXG4gIHdpbmRvd1xuICAgIC5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKVxuICAgIC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChldmVudCkgPT4gbW9kZUNoYW5nZUhhbmRsZXIoZXZlbnQubWF0Y2hlcyA/IFwiZGFya1wiIDogXCJsaWdodFwiKSk7XG4gIC8vIGVtaXRzIGV2ZW50IHdoZW4gdG9nZ2xpbmcgYmV0d2VlbiBtb2RlIGNsYXNzZXMgb24gPGJvZHk+XG4gIG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IG1vZGVDaGFuZ2VIYW5kbGVyKGdldE1vZGUoKSkpLm9ic2VydmUoZG9jdW1lbnQuYm9keSwge1xuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXR0cmlidXRlRmlsdGVyOiBbXCJjbGFzc1wiXVxuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgaXMgaW1wb3J0ZWQgaW4gU3RlbmNpbCdzIGBnbG9iYWxTY3JpcHRgIGNvbmZpZyBvcHRpb24uXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9zdGVuY2lsanMuY29tL2RvY3MvY29uZmlnI2dsb2JhbHNjcmlwdH1cbiAqL1xuZnVuY3Rpb24gYXBwR2xvYmFsU2NyaXB0ICgpIHtcbiAgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHdpbmRvdy5sb2NhdGlvbiA9PT0gbG9jYXRpb24gJiZcbiAgICB3aW5kb3cuZG9jdW1lbnQgPT09IGRvY3VtZW50O1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiaW50ZXJhY3RpdmVcIikge1xuICAgICAgaW5pdE1vZGVDaGFuZ2VFdmVudCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IGluaXRNb2RlQ2hhbmdlRXZlbnQoKSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBnbG9iYWxTY3JpcHRzID0gYXBwR2xvYmFsU2NyaXB0O1xuXG5nbG9iYWxTY3JpcHRzKCk7XG4iLCJjb25zdCBCVUlMRCA9IHtcbiAgICBhbGxSZW5kZXJGbjogZmFsc2UsXG4gICAgY21wRGlkTG9hZDogdHJ1ZSxcbiAgICBjbXBEaWRVbmxvYWQ6IGZhbHNlLFxuICAgIGNtcERpZFVwZGF0ZTogdHJ1ZSxcbiAgICBjbXBEaWRSZW5kZXI6IHRydWUsXG4gICAgY21wV2lsbExvYWQ6IHRydWUsXG4gICAgY21wV2lsbFVwZGF0ZTogdHJ1ZSxcbiAgICBjbXBXaWxsUmVuZGVyOiB0cnVlLFxuICAgIGNvbm5lY3RlZENhbGxiYWNrOiB0cnVlLFxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrOiB0cnVlLFxuICAgIGVsZW1lbnQ6IHRydWUsXG4gICAgZXZlbnQ6IHRydWUsXG4gICAgaGFzUmVuZGVyRm46IHRydWUsXG4gICAgbGlmZWN5Y2xlOiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lcjogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXRXaW5kb3c6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0RG9jdW1lbnQ6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0Qm9keTogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQ6IGZhbHNlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldDogdHJ1ZSxcbiAgICBtZW1iZXI6IHRydWUsXG4gICAgbWV0aG9kOiB0cnVlLFxuICAgIG1vZGU6IHRydWUsXG4gICAgb2JzZXJ2ZUF0dHJpYnV0ZTogdHJ1ZSxcbiAgICBwcm9wOiB0cnVlLFxuICAgIHByb3BNdXRhYmxlOiB0cnVlLFxuICAgIHJlZmxlY3Q6IHRydWUsXG4gICAgc2NvcGVkOiB0cnVlLFxuICAgIHNoYWRvd0RvbTogdHJ1ZSxcbiAgICBzbG90OiB0cnVlLFxuICAgIGNzc0Fubm90YXRpb25zOiB0cnVlLFxuICAgIHN0YXRlOiB0cnVlLFxuICAgIHN0eWxlOiB0cnVlLFxuICAgIHN2ZzogdHJ1ZSxcbiAgICB1cGRhdGFibGU6IHRydWUsXG4gICAgdmRvbUF0dHJpYnV0ZTogdHJ1ZSxcbiAgICB2ZG9tWGxpbms6IHRydWUsXG4gICAgdmRvbUNsYXNzOiB0cnVlLFxuICAgIHZkb21GdW5jdGlvbmFsOiB0cnVlLFxuICAgIHZkb21LZXk6IHRydWUsXG4gICAgdmRvbUxpc3RlbmVyOiB0cnVlLFxuICAgIHZkb21SZWY6IHRydWUsXG4gICAgdmRvbVByb3BPckF0dHI6IHRydWUsXG4gICAgdmRvbVJlbmRlcjogdHJ1ZSxcbiAgICB2ZG9tU3R5bGU6IHRydWUsXG4gICAgdmRvbVRleHQ6IHRydWUsXG4gICAgd2F0Y2hDYWxsYmFjazogdHJ1ZSxcbiAgICB0YXNrUXVldWU6IHRydWUsXG4gICAgaG90TW9kdWxlUmVwbGFjZW1lbnQ6IGZhbHNlLFxuICAgIGlzRGVidWc6IGZhbHNlLFxuICAgIGlzRGV2OiBmYWxzZSxcbiAgICBpc1Rlc3Rpbmc6IGZhbHNlLFxuICAgIGh5ZHJhdGVTZXJ2ZXJTaWRlOiBmYWxzZSxcbiAgICBoeWRyYXRlQ2xpZW50U2lkZTogZmFsc2UsXG4gICAgbGlmZWN5Y2xlRE9NRXZlbnRzOiBmYWxzZSxcbiAgICBsYXp5TG9hZDogZmFsc2UsXG4gICAgcHJvZmlsZTogZmFsc2UsXG4gICAgc2xvdFJlbG9jYXRpb246IHRydWUsXG4gICAgYXBwZW5kQ2hpbGRTbG90Rml4OiBmYWxzZSxcbiAgICBjbG9uZU5vZGVGaXg6IGZhbHNlLFxuICAgIGh5ZHJhdGVkQXR0cmlidXRlOiBmYWxzZSxcbiAgICBoeWRyYXRlZENsYXNzOiB0cnVlLFxuICAgIHNhZmFyaTEwOiBmYWxzZSxcbiAgICBzY3JpcHREYXRhT3B0czogZmFsc2UsXG4gICAgc2NvcGVkU2xvdFRleHRDb250ZW50Rml4OiBmYWxzZSxcbiAgICBzaGFkb3dEb21TaGltOiBmYWxzZSxcbiAgICBzbG90Q2hpbGROb2Rlc0ZpeDogZmFsc2UsXG4gICAgaW52aXNpYmxlUHJlaHlkcmF0aW9uOiB0cnVlLFxuICAgIHByb3BCb29sZWFuOiB0cnVlLFxuICAgIHByb3BOdW1iZXI6IHRydWUsXG4gICAgcHJvcFN0cmluZzogdHJ1ZSxcbiAgICBjc3NWYXJTaGltOiBmYWxzZSxcbiAgICBjb25zdHJ1Y3RhYmxlQ1NTOiB0cnVlLFxuICAgIGNtcFNob3VsZFVwZGF0ZTogdHJ1ZSxcbiAgICBkZXZUb29sczogZmFsc2UsXG4gICAgZHluYW1pY0ltcG9ydFNoaW06IGZhbHNlLFxuICAgIHNoYWRvd0RlbGVnYXRlc0ZvY3VzOiB0cnVlLFxuICAgIGluaXRpYWxpemVOZXh0VGljazogZmFsc2UsXG4gICAgYXN5bmNMb2FkaW5nOiBmYWxzZSxcbiAgICBhc3luY1F1ZXVlOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1UYWdOYW1lOiBmYWxzZSxcbiAgICBhdHRhY2hTdHlsZXM6IHRydWUsXG59O1xuY29uc3QgRW52ID0ge307XG5jb25zdCBOQU1FU1BBQ0UgPSAvKiBkZWZhdWx0ICovICdhcHAnO1xuXG5leHBvcnQgeyBCVUlMRCwgRW52LCBOQU1FU1BBQ0UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==